- [4. 结构型模式](#4-结构型模式)
	- [4.1 Adapter(适配器)---类对象结构型](#41-adapter适配器---类对象结构型)
	- [4.2 Bridge(桥接)---对象结构型](#42-bridge桥接---对象结构型)
	- [4.3 Composite(组成)---对象结构型](#43-composite组成---对象结构型)
	- [4.4 Decorator(装饰)---对象结构型](#44-decorator装饰---对象结构型)
	- [4.5 Facade(外观)---对象结构型](#45-facade外观---对象结构型)
	- [4.6 Flyweight(享元)---对象结构型](#46-flyweight享元---对象结构型)
	- [4.7 Proxy(代理)---对象结构型](#47-proxy代理---对象结构型)
	- [4.8 结构型模式的讨论](#48-结构型模式的讨论)
		- [4.8.1 Adapter与Bridge](#481-adapter与bridge)
		- [4.8.2 Composite、Decorator与Proxy](#482-compositedecorator与proxy)

# 4. 结构型模式

结构型模式涉及到如何组合类和对象以获得更大的结构。结构型类模式采用继承机制来组合接口或实现。一个简单的例子是采用多重继承方法将两个以上的类组合成一个类，结果这个类包含了所有父类的性质。这一模式尤其有助于多个独立开发的类库协同工作。另外一个例子是类形式的[4.1 Adapter(适配器)](4.结构型模式.md#41-adapter适配器---类对象结构型)模式。一般来说，适配器使得一个接口(adaptee的接口)与其他接口兼容，从而给出了多个不同接口的统一抽象。为此，类适配器对一个adaptee类进行私有继承。这样，适配器就可以用adaptee的接口表示它的接口

结构型对象模式不是对接口和实现进行组合，而是描述了如何对一些对象进行组合，而实现新功能的一些方法。因为可以在运行时刻改变对象组合关系，所以对象组合方式具有更大的灵活性，而这种机制用静态类组合是不可能实现的

[4.3 Composite(组成)](4.结构型模式.md#43-composite组成---对象结构型)模式是结构型对象模式的一个实例。它描述了如何构造一个类层次式结构，这一结构由两种类型的对象(基元对象和组合对象)所对应的类构成。其中的组合对象使得你可以组合基元对象以及其他的组合对象，从而形成任意复杂的结构。

在[4.7 Proxy(代理)](4.结构型模式.md#47-proxy代理---对象结构型)模式中，proxy对象作为其他对象的一个方便的替代或占位符。它的使用可以有多种形式。例如它可以在局部空间中代表一个远程地址空间中的对象，也可以表示一个要求被加载的较大的对象，还可以用来保护对敏感对象的访问。Proxy模式还提供了对对象的一些特有性质的一定程度上的间接访问，从而它可以限制、增强或修改这些性质

[4.6 Flyweight(享元)](4.结构型模式.md#46-flyweight享元---对象结构型)模式为了共享对象定义了一个结构。至少有两个原因要求对象共享：效率和一致性。Flyweight的对象共享机制主要强调对象的空间效率。使用很多对象的应用必需考虑每一个对象的开销。使用对象共享而不是进行对象复制，可以节省大量的空间资源。但是仅当这些对象没有定义与上下文相关的状态时，它们才可以被共享。Flyweight的对象没有这样的状态。任何执行任务时需要的其他一些信息仅当需要时才传递过去。由于不存在与上下文相关的状态，因此Flyweight对象可以被自由地共享

如果说Flyweight模式说明了如何生成很多较小的对象，那么[4.5 Facade(外观)](4.结构型模式.md#45-facade外观---对象结构型)模式则描述了如何用单个对象表示整个子系统。模式中的facade用来表示一组对象，facade的职责是将消息转发给它所表示的对象。[4.2 Bridge(桥接)](4.结构型模式.md#42-bridge桥接---对象结构型)模式将对象的抽象和其实现分离，从而可以独立地改变它们

[4.4 Decorator(装饰)](4.结构型模式.md#44-decorator装饰---对象结构型)模式描述了如何动态地为对象添加职责。Decorator模式是一种结构型模式。这一模式采用递归方式组合对象，从而允许你添加任意多的对象职责。例如，一个包含用户界面组件的Decorator对象可以将边框或阴影这样的装饰添加到该组件中，或者它可以将窗口滚动和缩放这样的功能添加的组件中。我们可以将一个Decorator对象嵌套在另外一个对象中就可以很简单地增加两个装饰，添加其他的装饰也是如此。因此，每个Decorator对象必须与其组件的接口兼容并旦保证将消息传递给介。Decorator模式在转发一条信息之前或之后都可以完成它的工作(比如绘制组件的边框)

许多结构型模式在某种程度上具有相关性，我们将在本章末讨论这些关系

## 4.1 Adapter(适配器)---类对象结构型

1. 意图：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作

2. 别名：包装器Wrapper

3. 适用性：以下情况使用Adapter模式

	* 你想使用一个已经存在的类，而它的接口不符合你的需求

	* 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类(即那些接口可能不一定兼容的类)协同工作

	* (仅适用于对象Adapter)你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口

4. 参与者

	* Target：定义Client要使用的与特定领域相关的接口

	* Client：与符合Target接口的对象协同

	* Adaptee：定义一个已经存在的接口，这个接口需要被适配

	* Adapter：对Adaptee的接口与Target接口进行适配

5. 协作：Client在Adapter实例上调用一些操作，接着适配器调用Adaptee的操作实现这个请求

6. 效果

	* 类适配器：

		* 用一个具体的Adapter类对Adaptee和Target进行匹配。结果是当我们想要匹配一个类以及所有它的子类时，类Adapter将不能胜任工作

		* 使得Adapter可以重定义Adaptee的部分行为，因为Adapter是Adaptee的一个子类

		* 仅仅引入了一个对象，并不需要额外的指针以间接得到adaptee

	* 对象适配器：

		* 允许一个Adapter与多个Adaptee(即Adaptee本身以及它的所有子类(如果有子类的话))同时工作。Adapter也可以一次给所有的Adaptee添加功能

		* 使得重定义Adaptee的行为比较困难。这就需要生成Adaptee的子类并且使得Adapter引用这个子类而不是引用Adaptee本身

	1. **Adapter的匹配程度**：对Adaptee的接口与Target的接口进行匹配的工作量各个Adapter可能不一样。工作范围可能是，从简单的接口转换(例如改变操作名)到支持完全不同的操作集合。Adapter的工作量取决于Target接口与Adaptee接口的相似程度

	2. **可插入的Adapter**：当其他的类使用一个类时，如果所需的假定条件越少，这个类就更具可复用性。如果将接口匹配构建为一个类，就不需要假定对其他的类可见的是一个相同的接口。也就是说，接口匹配使得我们可以将自己的类加入到一些现有的系统中去，而这些系统对这个类的接口可能会有所不同

	3. **使用双向适配器提供透明操作**：使用适配器的一个潜在问题是，它们不对所有的客户都透明。被适配的对象不再兼容Adaptee的接口，因此并不是所有Adaptee对象可以被使用的地方它都可以被使用。双向适配器提供了这样的透明性。在两个不同的客户需要用不同的方法查看同一个对象时，双向适配器尤其有用

7. 实现

	1. **使用C++实现适配器类**：在使用C++实现适配器类时Adapter类应该采用公共方式继承Target类，并且用私有方式继承Adaptee类。因此Adapter类应该是Target的子类型，但不星Adaptee的子类型

	2. **可插入的适配器**：有许多方法可以实现可插入的适配器。例如，前面描述的TreeDiSplay窗口组件可以自动的布置和显示层次式结构，对于它有三种实现方法:首先(这也是所有这三种实现都要做的)是为Adaptee找到一个"窄"接口，即可用于适配的最小操作集。因为包含较少操作的窄接口相对包含较多操作的宽接口比较容易进行匹配。对于TreeDisplay而言，被匹配的对象可以是任何一个层次式结构。因此最小接口集合仅包含两个操作:一个操作定义如何在层次结构中表示一个节点，另一个操作返回该节点的子节点。对这个窄接口，有以下三个实现途径:

		1. **使用抽象操作**：在TreeDisplay类中定义窄Adaptee接口相应的抽象操作。这样就由子类来实现这此抽象操作并匹配具体的树结构的对象例如，DirectoryTreeDisplay子类将通过访问目录结构实现这些操作。DirectoryTreeDisplay对这个窄接口加以特化，使得它的DirectoryBrowser客户可以用它来显示目录结构。

		2. **使用代理对象**：在这种方法中，TreeDisplay将访问树结构的请求转发到代理对象。TreeDisplay的客户进行一些选择，并将这些选择提供给**代理**对象，这样客户就可以对适配加以控制。在C++这样的静态类型语言中，需要一个代理的显式接口定义。我们将TreeDisplay需要的窄接口放入纯虚类TreeAccessorDelegate中，从而指定这样的一个接口。然后我们可以运用继承机制将这个接口融合到我们所选择的代理中---这里我们选择DirectoryBrowser。如果DirectoryBrowser没有父类我们将采用单继承，否则采用多继承。这种将类融合在一起的方法相对于引入一个新的TreeDisplay子类并单独实现它的操作的方法要容易一些

		3. **参数化的适配器**：通常在Smalltalk中支持可插入适配器的方法是，用一个或多个模块对适配器进行参数化。模块构造支持无子类化的适配。一个模块可以匹配一个请求，并且适配器可以为每个请求存储一个模块。在本例中意昧着，TreeDisplay存储的一个模块用来将一个节点转化成为一个GraphicNode，另外一个模块用来存取一个节点的子节点

8. 代码示例

实现一个绘图编辑器，这个绘图编辑器的关键抽象是图形对象。图形对象有一个可编辑的形状，并可以绘制自身。图形对象的接口由一个称为Shape的抽象类定义。绘图编辑器为每一种图形对象定义了一个Shape的子类，TextShape子类可以显示和编辑正文，实现相当困难，成品的用户界面工具箱已经提供了一个复杂的TextView类用于显示和编辑正文。理想的情况是我们可以复用这个TextView类以实现TextShape类，但是工具箱的设计者当时并没有考虑Shape的存在，因此TextView和Shape对象不能互换

定义一个TextShape类，由它来适配TextView的接口和Shape的接口。我们可以用两种方法做这件事:1.继承Shape类的接口和TextView的实现；2.将一个TextView实例作为TextShape的组成部分，并且使用TextView的接口实现TextShape。这两种方法恰恰对应于Adapter模式的类和对象版本↓：

```C++
class Shape {
	// 假定有一个边框，由相对的两角定义
public:
	Shape();
	virtual void BoundingBox(Point& bottomLeft, Point& topRight) const;
	virtual Manipulator* CreateManipulator() const;	// 工厂方法
	// 当用户操作一个图形时，Manipulator对象知道如何驱动这个图形
};

class TextView {
	// 由左下角顶点、宽度和高度定义
public:
	TextView();
	void GetOrigin(Coord& x, Coord& y) const;
	void GetExtent(Coord& width, Coord& height) const;
	virtual bool IsEmpty() const;
}
```

* 类适配器：

TextShape类是这些不同接口间的适配器。类适配器采用多重继承适配接口。类适配器的关键是用一个分支继承接口，而用另外一个分支继承接口的实现部分。通常C++中作出这一区分的方法是：用公共方式继承接口；用私有方式继承接口的实现↓：

```C++
class TextShape : public Shape, private TextView {
public:
	TextShape();

	virtual void BoundingBox(Point* bottomLeft, Point& topRight) const;
	virtual bool IsEmpty() const;
	virtual Manipulator* CreateManipulator() const;
};

// BoundingBox操作对TextView的接口进行转换使之匹配Shape的接口
void TextShape::BoundingBox(Point& bottomLeft, Point& topRight) const {
	Coord bottom, left, width, height;

	GetOrigin(bottom, left);
	GetExtent(width, height);

	bottomLeft = Point(bottom, left);
	topRight = Point(bottom + height, left + width);
}

// IsEmpty操作给出了在适配器实现过程中常用的一种方法：直接转发请求
bool TextShape::IsEmpty() const {
	return TextView::IsEmpty();
}

// 最后定义CreateManipulator(TextView不支持该操作)
// 假定已经实现了支持TextShape操作的类TextManipulator
Manipulator* TextShape::CreateManipulator() const {
	return new TextManipulator(this);
}
```

* 对象适配器

对象适配器采用对象组合的方法将具有不同接口的类组合在一起。在该方法中，适配器TextShape维护一个指向TextView的指针↓：

```C++
class TextShape : public Shape {
public:
	TextShape(TextView);

	virtual void BoundingBox(Point& bottomLeft, Point& topRight) const;
	virtual bool IsEmpty() const;
	virtual Manipulator* CreateManipulator() const;

private:
	TextView* _text;
};

// TextShape必须在构造器中对指闯TextView实例的指针进行初始化
// 当它自身的操作被调用时，它还必须对它的TextView对象调用相应的操作
// 在本例中，假设客户创建了TextView对象并且将其传递给TextShape的构造器
TextShape::TextShape(TextView* t) {
	_text = t;
}

void TextShape::BoundingBox(Point& bottomLeft, Point& topRight) const {
	Coord bottom, left, width, height;

	_text->GetOrigin(bottom, left);
	_text->GetExtent(width, height);

	bottomLeft = Point(bottom, left);
	topRight = Point(bottom + height, left + width);
}

bool TextShape::IsEmpty() const {
	return _text->IsEmpty();
}

// CreateManipulator的实现代码与类适配器版本的实现代码一样
// 因为它的实现从零开始，没有复用任何TextView已有的函数
Manipulator* TextShape::CreateManipulator() const {
	return new TextManipulator(this);
}
```

将这段代码与类适配器的相应代码进行比较，可以看出编写对象适配器代码相对麻烦一些，但是它比较灵活。例如，客户仅需将TextView子类的一个实例传给TextShape类的构造函数，对象适配器版本的TextShape就同样可以与TextView子类一起很好的工作

9. 相关模式

模式[4.2 Bridge(桥接)](4.结构型模式.md#42-bridge桥接---对象结构型)的结构与对象适配器类似，但是Bridge模式的出发点不同：Bridge目的是将接口部分和实现部分分离，从而对它们可以较为容易也相对独立的加以改变。而Adapter则意昧着改变一个已有对象的接口

[4.4 Decorator(装饰)](4.结构型模式.md#44-decorator装饰---对象结构型)模式增强了其他对象的功能而同时又不改变它的接口。因此decorator对应用程序的透明性比适配器要好。结果是decorator支持递归组合，而纯粹使用适配器是不可能实现这一点的

[4.7 Proxy(代理)](4.结构型模式.md#47-proxy代理---对象结构型)在不改变它的接口的条件下，为另一个对象定义了一个代理

## 4.2 Bridge(桥接)---对象结构型

1. 意图：将抽象部分与它的实现部分分离，使他们都可以独立地变化

2. 别名：Handle/Body

3. 适用性：以下一些情况使用Bridge模式

	* 不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换

	* 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时Bridge模式可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充

	* 对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译

	* 在C++中想对客户完全隐藏抽象的实现部分，在C++中类的表示在类接口中是可见的

	* 有许多类要生成。这样一种类层次结构说明必须将一个对象分解成两个部分。Rumbaugh称这种类层次结构为"嵌套的普化"

	* 想在多个对象间共享实现(可能使用引用计数)，但同时要求客户并不知道这一点。一个简单的例子便是Coplien的String类，在这个类中多个对象可以共享同一个字符串表示

4. 参与者

	* Abstraction：定义抽象类的接口；维护一个指向Implementor类型对象的指针

	* RefinedAbstraction：扩充由Abstraction定义的接口

	* Implementor：定义实现类的接口，该接口不一定要与Abstraction的接口完全一致；事实上这两个接口可以完全不同。一般来讲，Implementor接口仅提供基本操作，而Abstraction则定义了基于这些基本操作的较高层次的操作

	* ConcreteImplementor：实现Implementor接口并定义它的具体实现

5. 协作：Abstraction将client的请求转发给它的Implementor对象

6. 效果

	1. **分离接口及其实现部分**：一个实现未必不变地绑定在一个接口上。抽象类的实现可以在运行时刻进行配置，一个对象甚至可以在运行时刻改变它的实现。将Abstraction与Implementor分离有助于降低对实现部分编译时刻的依赖性，当改变一个实现类时，并不需要重新编译Abstraction类和它的客户程序。为了保证一个类库的不同版本之间的二进制兼容性，一定要有这个性质；另外，接口与实现分离有助于分层，从而产生更好的结构化系统，系统的高层部分仅需知道Abstraction和Implementor即可

	2. **提高可扩充性**：可以独立地对Abstraction和Implementor层次结构进程扩充

	3. **实现细节对客户透明**：可以对客户隐藏实现细节，例如共享Implementor对象以及相应的引用计数机制(如果有的话)

7. 实现

	1. **仅有一个Implementor**：在仅有一个实现的时候，没有必要创建一个抽象的Implementor类。这是Bridge模式的退化情况；在Abstraction与Implementor之间有一种一对一的关系。尽管如此，当你希望改变一个类的实现不会影响已有的客户程序时，模式的分离机制还是非常有用的---也就是说，不必重新编译它们，仅需重新连接即可。在C++中，Implementor类的类接口可以在一个私有的头文件中定义，这个文件不提供给客户。这样你就对客户彻底隐藏了一个类的实现部分

	2. **创建正确的Implementor对象**：当存在多个Implementor类的时候，你应该用何种方法，在何时何处确定创建哪一个Implementor类呢?

		1. 如果Abstraction知道所有的ConcreteImplementor类，它就可以在它的构造器中对其中的一个类进行实例化，它可以通过传递给构造器的参数确定实例化哪一个类。例如，如果一个collection类支持多重实现，就可以根据collection的大小决定实例化哪一个类。链表的实现可以用于较小的collection类，而hash表则可用于较大的collection类。

		2. 另外一种方法是首先选择一个缺省的实现，然后根据需要改变这个实现。例如，如果一个collection的大小超出了一定的阈值时，它将会切换它的实现，使之更适用于表目较多的collection，

		3. 也可以代理给另一个对象，由它一次决定。在下面的代码示例的Window/WindowImp的例子中，我们可以引入一个factory对象(参见[3.1 Abstract Factory(抽象工厂)](3.创建型模式.md#31-abstract-factory抽象工厂---对象创建型模式))，该对象的唯一职责就是封装系统平台的细节。这个对象知道应该为所用的平台创建何种类型的WindowImp；Window仅需向它请求一个WindowImp，而它会返回正确类型的WindowImp对象。这种方法的优点是Abstraction类不和任何一个Implementor类直接耦合

	3. **共享Implementor对象**：Coplien闸明了如何用C++中常用的Handle/Body方法在多个对象间共享一些实现。其中Body有一个对象引用计数器，Handle对它进行增减操作。将共享程序体赋给句柄的代码一般具有以下形式↓：

		```C++
		Handle& Handle::operator= (const Handle& other) {
			other._body->Ref();
			_body->Unref();

			if (_body->RefCount() == 0)
				delete _body;
			_body = other._body;

			return *this;
		}
		```

	1. **采用多重继承机制**：在C++中可以使用多重继承机制将抽象接口和它的实现部分结合起来。例如，一个类可以用public方式继承Abstraction而以private方式继承ConcreteImplementor。但是由于这种方法依赖于静态继承，它将实现部分与接口固定不变的绑定在一起。因此不可能使用多重继承的方法实现真正的Bridge模式---至少用C++不行

8. 代码示例

让我们考虑在一个用户界面工具箱中，一个可移植的Window抽象部分的实现。例如，这一抽象部分应该允许用户开发一些在XWindowSystem和IBM的PresentationManager(PM)系统中都可以使用的应用程序。运用继承机制，我们可以定义Window抽象类和它的两个子类XWindow与PMWindow，由它们分别实现不同系统平台上的Window界面。但是继承机制有两个不足之处:1.扩展Window抽象使之适用于不同种类的窗口或新的系统平台很不方便；2.继承机制使得客户代码与平台相关。Bridge模式解决以上问题的方法是，将Window抽象和它的实现部分分别放在独立的类层次结构中。其中一个类层次结构针对窗口接口(Window、IconWindow、TransientWindow)，另外一个独立的类层次结构针对平台相关的窗口实现部分，这个类层次结构的根类为WindowImp。对Window子类的所有操作都是用WindowImp接口中的抽象操作实现的。这就将窗口的抽象与系统平台相关的实现部分分离开来。因此，我们将Window与WindowImp之间的关系称之为桥接，因为它在抽象类与它的实现之间起到了桥梁作用，使它们可以独立地变化↓：

```C++
// Window类为客户应用程序定义了窗口抽象类
class Window {
public:
	Window(View* contents);

	// 由window处理的请求
	virtual void DrawContents();

	virtual void Open();
	virtual void Close();
	virtual void Iconify()
	virtual void Deiconify();

	// 转发给实现的请求
	virtual void SetOrigin(const Point& at);
	virtual void SetExtent(const Point& extent);
	virtual void Raise();
	virtual void Lower();
	virtual void DrawLine(const Point&, const Point&);
	virtual void DrawRect(const Point&, const Point&);
	virtual void DrawPolygon(const Point[], int n);
	virtual void DrawText(const char*, const Point&);

protected:
	WindowImp* GetWindowImp();
	View* GetView();

private:
	WindowImp* _imp;// 维护一个对WindowImp的引用
	View*_contents;	// 窗口内容
};

// 定义了一个对底层窗口系统的接口
class WindowImp {
public:
	virtual void ImpTop() = 0;
	virtual void ImoBottom() = 0;
	virtual void ImpSetExtent(const Point&) = 0;
	virtual void ImpSetOrigin(const Point&) = 0;

	virtual void DeviceRect(Coord, Coord, Coord, Coord) = 0;
	virtual void DeviceText(const char*, Coord, Coord) = 0;
	virtual void DeviceBitmap(const char*, Coord, Coord) = 0;
	// 省略更多的绘制函数

protected:
	WindowImp();
};
```

Window的子类定义了应用程序可能用到的不同类型的窗口，如应用窗口、图标、对话框临时窗口以及工具箱的移动面板等↓：

```C++
// ApplicationWindow类将实现DrawContents操作以绘制它所存储的View实例
class ApplicationWindow : public Window {
public:
	// ...
	virtual void DrawContents();
};
void ApplicationWindow::DrawContents() {
	GetView()->DrawOn(this);
}

// IconWindow中存储了它所显示的图标对应的位图名并且实现DrawContents操作将这个位图绘制在窗口上
class IconWindow : public Window {
public:
	// ...
	virtual void DrawContents();

private:
	const char* _bitmapName;
};
void IconWindow::DrawContents() {
	WindowImp* imp = GetWindowImp();
	if (im ！= 0)
		imp->DeviceBitmap(_bitmapName, 0.0, 0.0);
}
```

Window的操作由WindowImp的接口定义。例如在调用WindowImp操作在窗口中绘制矩形之前，DrawRect必须从它的两个Point参数中提取四个坐标值↓：

```C++
void Window::DrawRect(const Point& p1, const Point& p2) {
	WindowImp* imp = GetWindowImp();
	imp->DevicesRect(p1.X(), p1.Y(), p2.X(), p2.Y());
}
```

具体的WindowImp子类可支持不同的窗口系统↓：

```C++
// XwindowImp子类支持X Window窗口系统
class XWindowImp : public WindowImp {
public:
	XWindowImp();

	virtual void DeviceRect(Coord, Coord, Coord, Coord);
	// 其余的public接口

private:
	// 许多X window窗口系统特定的状态，包括↓
	Display* _dpy;
	Drawable _winid;	// window id
	GC _gc;	// window 图形上下文
}；

// 对于Presentation Manager(PM)，我们定义PMWindowImp类
class PMWindowImp : public WindowImp {
public:
	PMWindowImp();
	virtual void DeviceRect(Coord, Coord, Coord, Coord);
	// 其余的public接口

private:
	// 许多PM window窗口系统特定的状态，包括↓
	HP _hps;
};
```

这些子类用窗口系统的基本的操作实现WindowImp操作↓：

```C++
// 对于X窗口系统这样实现DeviceRect↓
void XWindowImp::DeviceRect(Coord x0, Coors y0, Coord x1, Coord y1) {
	int x = round(min(x0, x1));
	int y = round(min(y0, y1));
	int w = round(abs(x0 - x1));
	int h = round(abs(y0 - y1));
	XDrawRectangle(_dpy, _winid, _gc, x, y, w, h);
}

// PM的实现部分可能像下面这样↓
void PMWindowImp::DeviceRect(Coord x0, Coord y0, Coord x1, Coord y1) {
	Coord left = min(x0, x1);
	Coord right = max(x0, x1);
	Coord bottom = min(y0, y1);
	Coord top = max(y0, y1);
	PPOINTL point[4];

	point[0].x = left;	point[0].y = top;
	point[1].x = right;	point[1].y = top;
	point[2].x = right;	point[2].y = bottom;
	point[3].x = left;	point[4].y = bottom;

	if ((GpiBeginPath(_hps, 1L) == false) ||
		(GpiSetCurrentPosition(_hps, &point[3]) == false) ||
		(GpiPolyLine(_hps, 4L, point) == GPI_ERROR) ||
		(GpiEndPath(_hps) == false)) {
			// report error
		} else
			GpiStrokePath(_hps, 1L, 0L);
}
```

那么一个窗口怎么得到正确的WindowImp子类的实例呢？在本例我们假设Window类具有这个职责，它的GetWindowImp操作负责从一个[Abstract Factory](3.创建型模式.md#31-abstract-factory抽象工厂---对象创建型模式)得到正确的实例，这个抽象工厂封装了所有窗口系统的细节↓：

```C++
Window* Window::GetWindowImp() {
	if (_imp == 0)
		_imp = WindowSystemFactory::Instance()->MakeWindowImp();
	return _imp;
}
```

WindowSystemFactory::Instance()函数返回一个抽象工厂，该工厂负责处理所有与特定窗口系统相关的对象。为简化起见，我们将它创建一个[Singleton](3.创建型模式.md#35-singleton单件---对象创建型模式)，允许Window直接访问这个工厂

9. 相关模式

[3.1 Abstract Factory(抽象工厂)](3.创建型模式.md#31-abstract-factory抽象工厂---对象创建型模式)可以用来创建和配置一个特定的Bridge模式

[4.1 Adapter(适配器)](4.结构型模式.md#41-adapter适配器---类对象结构型)用来帮助无关的类协同工作，它通常在系统设计完成后才会被使用。然而，Bridge模式则是在系统开始时就被使用，它使得抽象接口和实现部分可以独立进行改变

## 4.3 Composite(组成)---对象结构型

1. 意图：将对象组合成树形结构以表示"部分-整体"的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性

2. 适用性：以下情况使用Composite模式

	* 想表示对象的部分-整体层次结构

	* 希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象

3. 参与者

	* Component：为组合中的对象声明接口；在适当的情况下，实现所有类共有接口的缺省行为；声明一个接口用于访问和管理Component的子组件；(可选)在递归结构中定义一个接口，用于访问一个父部件，并在合适的情况下实现它

	* Leaf：在组合中表示叶节点对象，叶节点没有子节点、在组合中定义图元对象的行为

	* Composite：定义有子部件的那些部件的行为；存储子部件、在Component接口中实现与子部件有关的操作

	* Client：通过Component接口操纵组合部件的对象

4. 协作

用户使用Component类接口与组合结构中的对象进行交互。如果接收者是一个叶节点，则直接处理请求。如果接收者是Composite，它通常将请求发送给它的子部件，在转发请求之前与/或之后可能执行一些辅助操作

5. 效果

	1. **定义了包含基本对象和组合对象的类层次结构**：基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断的递归下去。客户代码中，任何用到基本对象的地方都可以使用组合对象

	2. **简化客户代码**：客户可以一致地使用组合结构和单个对象。通常用户不知道(也不关心)处理的是一个叶节点还是一个组合组件。这就简化了客户代码，因为在定义组合的那些类中不需要写一些充斥着选择语句的函数

	3. **使得更容易增加新类型的组件**：新定义的Composite或Leaf子类自动地与已有的结构和客户代码一起工作，客户程序不需因新的Component类而改变

	4. **使你的设计变得更加一般化**：容易增加新组件也会产生一些问题，那就是很难限制组合中的组件。有时你希望一个组合只能有某些特定的组件。使用Composite时你不能依赖类型系统施加这些约束，而必须在运行时刻进行检查

6. 实现

	1. **显式的父部件引用**:
		保持从子部件到父部件的引用能简化组合结构的遍历和管理。父部件引用可以简化结构的上移和组件的删除，同时父部件引用也支持[5.1 Chain Of Responsibility(职责链)](5.行为模式.md#51-chain-of-responsibility职责链---对象行为型模式)模式。通常在Component类中定义父部件引用。Leaf和Composite类可以继承这个引用以及管理这个引用的那些操作

		对于父部件引用，必须维护一个不变式，即一个组合的所有子节点以这个组合为父节点，而反之该组合以这些节点为子节点。保证这一点最容易的办法是，仅当在一个组合中增加或删除一个组件时，改变这个组件的父部件。如果能在Composite类的Add和Remove操作中实现这种方法，那么所有的子类都可以继承这一方法，并且将自动维护这一不变式

	2. **共享组件**：共享组件是很有用的，比如它可以减少对存贮的需求。但是当一个组件只有一个父部件时，很难共享组件。一个可行的解决办法是为子部件存贮多个父部件，但当一个请求在结构中向上传递时，这种方法会导致多义性。[4.6 Flyweight(享元)](4.结构型模式.md#46-flyweight享元---对象结构型)模式讨论了如何修改设计以避免将父部件存贮在一起的方法。如果子部件可以将一些状态(或是所有的状态)存储在外部，从而不需要向父部件发送请求，那么这种方法是可行的

	3. **最大化Component接口**：

		Composite模式的目的之一是使得用户不知道他们正在使用的具体的Leaf和Composite类。为了达到这一目的，Composite类应为Leaf和Composite类尽可能多定义一些公共操作。Composite类通常为这些操作提供缺省的实现，而Leaf和Composite子类可以对它们进行重定义

		然而，这个目标有时可能会与类层次结构设计原则相冲突，该原则规定:一个类只能定义那些对它的子类有意义的操作。有许多Component所支持的操作对Leaf类似乎没有什么意义，那么Component怎样为它们提供一个缺省的操作呢?

		有时一点创造性可以使得一个看起来仅对Component才有意义的操作，将它移入Component类中，就会对所有的Component都适用。例如，访问子节点的接口是Composite类的一个基本组成部分，但对Leaf类来说并不必要。但是如果我们把一个Leaf看成一个没有子节点的Component，就可以为在Component类中定义一个缺省的操作，用于对子节点进行访问，这个缺省的操作不返回任何一个子节点。Leaf类可以使用缺省的实现，而Composite类则会重新实现这个操作以返回它们的子类

		管理子部件的操作比较复杂，我们将在下一项中予以讨论

	4. **声明管理子部件的操作**：

		虽然Composite类实现了Add和Remove操作用于管理子部件，但在Composite模式中一个重要的问题是:在Composite类层次结构中哪一些类声明这些操作。我们是应该在Component中声明这些操作，并使这些操作对Leaf类有意义呢，还是只应该在Composite和它的子类中声明并定义这些操作呢?这需要在安全性和透明性之间做出权衡选择：

		* 在类层次结构的根部定义子节点管理接口的方法具有良好的**透明性**，因为你可以一致地使用所有的组件，但是这一方法是以安全性为代价的，因为客户有可能会做一些无意义的事情，例如在Leaf中增加和删除对象等

		* 在Composite类中定义管理子部件的方法具有良好的**安全性**，因为在像C++这样的静态类型语言中，在编译时任何从Leaf中增加或删除对象的尝试都将被发现。但是这又损失了透明性，因为Leaf和Composite具有不同的接口

		在这一模式中，相对于安全性，我们比较强调透明性。如果你选择了安全性，有时你可能会丢失类型信息，并且不得不将一个组件转换成一个组合。这样的类型转换必定不是类型安全的

		一种办法是在Component类中声明一个操作`Composite* GetComposite()`。Component提供了一个返回空指针的缺省操作。Composite类重新定义这个操作并通过this指针返回它自身↓：

		```C++
		class Composite;

		class Component {
		public:
			// ...
			virtual Composite* GetComposite() {return 0;}
		};

		class Composite : public Component {
		public:
			void Add(Component*);
			// ...
			virtual Composite* GetComposite() {return this;}
		};

		class Leaf : public Component {
			// ...
		};
		```

		GetComposite允许你查询一个组件看它是否是一个组合，你可以对返回的组合安全地执行Add和Remove操作↓：

		```C++
		Composite* aComposite = new Composite;
		Leaf* aLeaf = new Leaf;

		Component* aComponent;
		Composite test;

		aComponent = aComposite;
		if (test == aComponent->GetComposite())
			test->Add(new Leaf);

		aComponent = aLeaf;

		if (test = aComponent->GetComposite())
			test->Add(new Leaf);	// 将不会添加leaf
		```

		可以使用C++中的dynamic_cast结构对Composite做相似的实验，当然这里的问题是对所有的组件的处理并不一致。在进行适当的动作之前，我们必须检测不同的类型

		提供透明性的唯一方法是在Component中定义缺省Add和Remove操作。这又带来了一个新的问题：`Component::Add`的实现不可避免地会有失败的可能性。你可以不让`Component::Add`做任何事情，但这就忽略了一个很重要的问题：企图向叶节点中增加一些东西时可能会引入错误。这时Add操作会产生垃圾。你可以让Add操作删除它的参数，但可能客户并不希望这样。如果该组件不允许有子部件，或者Remove的参数不是该组件的子节点时，通常最好使用缺省方式(可能是产生一个异常)处理Add和Remove的失败

		另一个办法是对"删除"的含义做一些改变，如果该组件有一个父部件引用，我们可以重新定义Component::Remove，在它的父组件中删除掉这个组件。然而对应的Add操作仍然没有合理的解释

	5. **Component是否应该实现一个Component列表**：你可能希望在Component类中将子节点集合定义为一个实例变量，而这个Component类中也声明了一些操作对子节点进行访问和管理。但是在基类中存放子类指针，对叶节点来说会导致空间浪费，因为叶节点根本没有子节点。只有当该结构中子类数目相对较少时，才值得使用这种方法

	6. **子部件排序**：许多设计指定了Composite的子部件顺序。如果Composite表示语法分析树，Composite子部件的顺序必须反映程序结构，而组合语句就是这样一些Composite的实例。如果需要考虑子节点的顺序时，必须仔细地设计对子节点的访问和管理接口，以便管理子节点序列。[5.4 Iterator(迭代器)](5.行为模式.md#54-iterator迭代器---对象行为型模式)模式可以在这方面给予一些定的指导

	7. **使用高速缓冲存贮改善性能**：如果你需要对组合进行频繁的遍历或查找，Composite类可以缓冲存储对它的子节点进行遍历或查找的相关信息。Composite可以缓冲存储实际结果或者仅仅是一些用于缩短遍历或查询长度的信息。一个组件发生变化时，它的父部件原先缓冲存贮的信息也变得无效。在组件知道其父部件时，这种方法最为有效。因此，如果你使用高速缓冲存贮，你需要定义一个接口来通知组合组件它们所缓冲存贮的信息无效

	8. **应该由谁删除Component**：在没有垃圾回收机制的语言中，当一个Composite被销毁时，通常最好由Composite负责删除其子节点。但有一种情况除外，即Leaf对象不会改变，因此可以被共享

	9. **存贮组件最好用哪一种数据结构**：Composite可使用多种数据结构存贮它们的子节点，包括连接列表、树、数组和hash表。数据结构的选择取决于效率。事实上，使用通用数据结构根本没有必要。有时对每个子节点，Composite都有一个变量与之对应，这就要求Composite的每个子类都要实现自己的管理接口。参见[5.3 Interpreter(解释器)](5.行为模式.md#53-interpreter解释器---类行为型模式)模式中的例子

7. 代码示例

计算机和立体声组合音响这样的设备经常被组装成部分-整体层次结构或者是容器层次结构。例如，底盘可包含驱动装置和平面板，总线含有多个插件，机柜包括底盘、总线等。这种结构可以很自然地用Composite模式进行模拟

Equipment(设备)类为在部分-整体层次结构中的所有设备定义了一个接口↓：

```C++
class Equipment {
public:
	virtual ~Equipment();

	const char* Name() {return _name;}

	virtual Watt Power();
	virtual Currency NetPrice();	// 净价
	virtual Currency DiscountPrice();	// 折扣价

	virtual void Add(Equipment*);
	virtual void Remove(Equipment*);
	virtual Iterator<Equipment*>* CreateIterator();
	// 为访问它的零件返回一个Iterator，缺省实现返回一个NullIterator，在空集上迭代

protected:
	Equipment(const char*);

private:
	const char* _name;
};

// 软盘
class FloppyDisk : public Equipment {
public:
	FloppyDisk(const char*);
	virtual ~FloppyDisk();

	virtual Watt Power();
	virtual Currency NetPrice();
	virtual Currency DiscountPrice();
};
```

CompositeEquipment是包含其他设备的基类，它也是Equipment的子类↓：

```C++
class CompositeEquipment : public Equipment {
public:
	virtual ~CompositeEquipment();

	virtual Watt Power();
	virtual Currency NetPrice();
	virtual Currency DiscountPrice();

	// 对存储在_equipment成员变量中的设备列表进行操作
	virtual void Add(Equipment*);
	virtual void Remove(Equipment*);
	virtual Iterator<Equipment*>* CreateIterator();

protected:
	CompositeEquipment(const char*);

private:
	List<Equipment*> _equipment;
};

// NetPrice的缺省实现使用CreateIterator来累加子设备的实际价格
Currency CompositeEquipment::NetPrice() {
	Iterator<Equipment*>* i = CreateIterator();
	Currency total = 0;

	for (i->First(); !i->IsDone(); i->Next()
		total += i->CurrentItem()->NetPrice();

	delete i;
	return total;
}
```

将计算机的底盘表示为CompositeEquipment的子类Chassis。Chassis从CompositeEquipment继承了与子类有关的操作↓：

```C++
class Chassis : public CompositeEquipment {
public:
	Chassis(const char*);
	virtual ~Chassis();

	virtual Watt Power();
	virtual Currency NetPrice();
	virtual Currency DiscountPrice();
};
```

可用相似的方式定义其他设备容器，如Cabinet和Bus。这样就得到了组装一台个人计算机所需的所有设备↓：

```C++
Cabinet* cabinet = new Cabinet("PC Cabinet");
Chassis* chassis = new Chassis("PC Chassis");

cabinet->Add(chassis);

Bus* bus = new Bus("MCA Bus");
bus->Add(new Card("16Mbs Token Ring"));

chassid->Add(bus);
chassis->Add(new FloppyDisk(3.5in Floppy"));

cout << "The net price is " << chassis->NetPrice() << endl;
```

8. 相关模式

通常部件-父部件连接用于[5.1 Chain Of Responsibility(职责链)](5.行为模式.md#51-chain-of-responsibility职责链---对象行为型模式)模式

[4.4 Decorator(装饰)](4.结构型模式.md#44-decorator装饰---对象结构型)模式经常与Composite模式一起使用。当装饰和组合一起使用时，它们通常有一个公共的父类。因此装饰必须支持具有Add、Remove和GetChild操作的Component接口

[4.6 Flyweight(享元)](4.结构型模式.md#46-flyweight享元---对象结构型)让你共享组件，但不再能引用他们的父部件

[5.4 Iterator(迭代器)](5.行为模式.md#54-iterator迭代器---对象行为型模式)可用来遍历Composite

[5.11 Visitor(访问者)](5.行为模式.md#511-visitor访问者---对象行为型模式)将本来应该分布在Composite和Leaf类中的操作和行为局部化

## 4.4 Decorator(装饰)---对象结构型

1. 意图：动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活

2. 别名：包装器Wrapper

3. 适用性：以下情况使用Decorator模式

	* 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责

	* 处理那些可以撤消的职责

	* 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类

4. 参与者

	* Component：定义一个对象接口，可以给这些对象动态地添加职责

	* ConcreteComponent：定义一个对象，可以给这个对象添加一些职责

	* Decorator：维持一个指向Component对象的指针，并定义一个与Component接口一致的接口

	* ConcreteDecorator：向组件添加职责

5. 协作：Decorator将请求转发给它的Component对象，并有可能在转发请求前后执行一些附加的动作

6. 效果

	1. **比静态继承更灵活**：与对象的静态继承(多重继承)相比，Decorator模式提供了更加灵活的向对象添加职责的方式。可以用添加和分离的方法，用装饰在运行时刻增加和删除职责。相比之下，继承机制要求为每个添加的职责创建一个新的子类。这会产生许多新的类，并且会增加系统的复杂度。此外，为一个特定的Component类提供多个不同的Decorator类，这就使得你可以对一些职责进行混合和匹配。使用Decorator模式可以很容易地重复添加一个特性，例如在TextView上添加双边框时，仅需将添加两个BorderDecorator即可。而两次继承Border类则极容易出错的

	2. **避免在层次结构高层的类有太多的特征**：Decorator模式提供了一种"即用即付"的方法来添加职责。它并不试图在一个复杂的可定制的类中支持所有可预见的特征，相反，你可以定义一个简单的类，并且用Decorator类给它逐渐地添加功能。可以从简单的部件组合出复杂的功能。这样，应用程序不必为不需要的特征付出代价。同时也更易于不依赖于Decorator所扩展(甚至是不可预知的扩展)的类而独立地定义新类型的Decorator。扩展一个复杂类的时候，很可能会暴露与添加的职责无关的细节

	3. **Decorator与它的Component不一样**：Decorator是一个透明的包装。如果我们从对象标识的观点出发，一个被装饰了的组件与这个组件是有差别的，因此，使用装饰时不应该依赖对象标识

	4. **有许多小对象**：采用Decorator模式进行系统设计往往会产生许多看上去类似的小对象，这些对象仅仅在他们相互连接的方式上有所不同，而不是它们的类或是它们的属性值有所不同。尽管对于那此了解这些系统的人来说很容易对它们进行定制，但是很难学习这些系统，排错也很困难

7. 实现

	1. **接口的一致性**：装饰对象的接口必须与它所装饰的Component的接口是一致的，因此，所有的ConcreteDecorator类必须有一个公共的父类(至少在C++中如此)

	2. **省略抽象的Decorator类**：当你仅需要添加一个职责时，没有必要定义抽象Decorator。你常常需要处理现存的类层次结构而不是设计一个新系统，这时你可以把Decorator向Component转发请求的职责合并到ConcreteDecorator中

	3. **保持Component类的简单性**：为了保证接口的一致性，组件和装饰必须有一个公共的Component父类。因此保持这个类的简单性是很重要的;即它应集中于定义接口而不是存储数据。对数据表示的定义应延迟到子类中，否则Component类会变得过于复杂和庞大，因而难以大量使用。赋予Component太多的功能也使得具体的子类有一些它们并不需要的功能的可能性大大增加

	4. **改变对象外壳与改变对象内核**：

		我们可以将Decorator看作一个对象的外壳，它可以改变这个对象的行为。另外一种方法是改变对象的内核。例如[5.9 Strategy(策略)](5.行为模式.md#59-strategy策略---对象行为型模式)模式就是一个用于改变内核的很好的模式。当Component类原本就很庞大时，使用Decorator模式代价太高，Strategy模式相对更好一些。在Strategy模式中，组件将它的一些行为转发给一个独立的策略对象，我们可以替换strategy对象，从而改变或扩充组件的功能

		由于Decorator模式仅从外部改变组件，因此组件无需对它的装饰有任何了解，也就是说，这些装饰对该组件是透明的；在Strategy模式中，component组件本身知道可能进行哪些扩充，因此它必须引用并维护相应的策略

		基于Strategy的方法可能需要修改component组件以适应新的扩充。另一方面，一个策略可以有自己特定的接口，而装饰的接口则必须与组件的接口一致，这意味着即使Component类很庞大时，策略也可以很小

8. 代码示例

以下C++代码说明了如何实现用户接口装饰，假定已经存在一个是Component类的VisualComponent↓：

```C++
class VisualComponent {
public:
	VisualComponent();

	virtual void Draw();
	virtual void Resize();
	// ...
};
```

定义VisualComponent的一个子类Decorator，将生成Decorator的子类以获取不同的装饰↓：

```C++
class Decorator : public VisualComponent {
public:
	Decorator(VisualComponent*);

	virtual void Draw();
	virtual void Resize();
	// ...

private:
	VisualComponent* _component;
	// 在构造器中被初始化，对于VisualComponent接口中定义的每一个操作
	// Decorator类都定义了一个缺省的实现，这一实现请求将转发给_component
};

void Decorator::Draw() {
	_component->Draw();
}

void Decorator::Resize() {
	_component->Resize();
}
```

Decorator的子类定义了特殊的装饰功能，例如BorderDecorator类为它所包含的组件添加了一个边框。BorderDecorator是Decorator的子类，它重定义Draw操作用于绘制边框。同时BorderDecorator还定义了一个私有的辅助操作DrawBorder，由它绘制边框。这些子类继承了Decorator类所有其他的操作↓：

```C++
class BorderDecorator : public Decorator {
public:
	BorderDecorator(VisualComponent*, int borderWidth);

	virtual void Draw();

private:
	void DrawBorder(int);
	int _width;
};

void BorderDecorator::Draw() {
	Decorator::Draw();
	DrawBorder(_width);
}
```

类似的可以实现ScrollDecorator和DropShadowDecorator，它们给可视组件添加滚动和阴影功能。现在我们组合这些类的实例以提供不同的装饰效果，以下代码展示了如何使用Decorator创建一个具有边界的可滚动TextView↓：

```C++
// 首先将一个可视组件放入窗口对象中，假设Window类已经为此提供了一个SetContents操作
void Window::SetContents(VisualComponent* contents) {
	// ...
}

// 创建一个正文视图以及放入这个正文视图的窗口
Window* window = new Window;
TextView* textView = new TextView;

// TextView是一个VisualComponent，可以放入窗中
// 但我们想要一个有边界的可以滚动的TextView，因此在将它放入窗口之前对其进行装饰
window->SetContents(
	new BorderDecorator(
		new ScrollDecorator(textView), 1));
window->SetContents(textView);
```

由于Window通过VisualComponent接口访问它的内容，因此它并不知道存在该装饰。如果需要直接与正文视图交互，例如想调用一些操作，而这些操作不是VisualComponent接口的一部分，此时可以跟踪正文视图。依赖于组件标识的客户也应该直接引用它

9.相关模式

[4.1 Adapter(适配器)](4.结构型模式.md#41-adapter适配器---类对象结构型)模式：[Decorator](4.结构型模式.md#44-decorator装饰---对象结构型)模式不同于[Adapter](4.结构型模式.md#41-adapter适配器---类对象结构型)模式，因为装饰仅改变对象的职质而不改变它的接口;而适配器将给对象一个全新的接口

[4.3 Composite(组成)](4.结构型模式.md#43-composite组成---对象结构型)模式：可以将装饰视为一个退化的、仅有一个组件的组合。然而，装饰仅给对象添加一些额外的职责---它的目的不在于对象聚集

[5.9 Strategy(策略)](5.行为模式.md#59-strategy策略---对象行为型模式)模式：用一个装饰你可以改变对象的外表;而[trategy](5.行为模式.md#59-strategy策略---对象行为型模式)模式使得你可以改变对象的内核。这是改变对象的两种途径

## 4.5 Facade(外观)---对象结构型

1. 意图：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用

2. 适用性：在遇到以下情况使用Facade模式

	* 当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过facade层

	* 客户程序与抽象类的实现部分之间存在着很大的依赖性。引入facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性

	* 当你需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过facade进行通讯，从而简化了它们之间的依赖关系

3. 参与者

	* Facade：知道哪些子系统类负责处理请求；将客户的请求代理给适当的子系统对象

	* Subsystem classes：实现子系统的功能；处理由Facade对象指派的任务；没有facade的任何相关信息，即没有指向facade的指针

4. 协作

	* 客户程序通过发送请求给Facade的方式与子系统通讯，Facade将这些消息转发给适当的子系统对象。尽管是子系统中的有关对象在做实际工作，但Facade模式本身也必须将它的接口转换成子系统的接口

	* 使用Facade的客户程序不需要直接访问子系统对象

5. 效果

	1. 它对客户屏蔽子系统组件，因而减少了客户处理的对象的数目并使得子系统使用起来更加方便。

	2. 它实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件往往是紧耦合的。松耦合关系使得子系统的组件变化不会影响到它的客户。Facade模式有助于建立层次结构系统，也有助于对对象之间的依赖关系分层。Facade模式可以消除复杂的循环依赖关系。这一点在客户程序与子系统是分别实现的时候尤为重要

		在大型软件系统中降低编译依赖性至关重要。在子系统类改变时，希望尽量减少重编译工作以节省时间。用Facade可以降低编译依赖性，限制重要系统中较小的变化所需的重编译工作。Facade模式同样也有利于简化系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统

	3. 如果应用需要，它并不限制它们使用子系统类。因此你可以在系统易用性和通用性之间加以选择

6. 实现

	1. **降低客户-子系统之间的耦合度**：

		用抽象类实现Facade而它的具体子类对应于不同的子系统实现，这可以进一步降低客户与子系统的耦合度。这样，客户就可以通过抽象的Facade类接口与子系统通讯。这种抽象耦合关系使得客户不知道它使用的是子系统的哪一个实现

		除生成子类的方法以外，另一种方法是用不同的子系统对象配置Facade对象。为定制facade，仅需对它的子系统对象(一个或多个)进行替换即可

	2. **公共子系统类与私有子系统类**：一个子系统与一个类的相似之处是，它们都有接口并且它们都封装了一些东西---类封装了状态和操作，而子系统封装了一些类。考虑一个类的公共和私有接口是有益的，我们也可以考虑子系统的公共和私有接口

		子系统的公共接口包含所有的客户程序可以访问的类;私有接口仅用于对子系统进行扩充。当然，Facade类是公共接口的一部分，但它不是唯一的部分，子系统的其他部分通常也是公共的。例如编译子系统中的Parser类和Scanner类就是公共接口的一部分

		私有化子系统类确实有用，但是很少有面向对象的编程语言支持这一点。C++和Smalltalk语言仅在传统意义下为类提供了一个全局名空间。然而，最近C++标准化委员会在C++语言增加了一些名字空间，这些名字空间使得你可以仅暴露公共子系统类

7. 代码示例

如何在一个编译子系统中使用Facade。编译子系统定义了一个BytecodeStream类，它实现了一个Bytecode对象流(stream)。Bytecode对象封装一个字节码，这个字节码可用于指定机器指令。该子系统中还定义了一个Token类，它封装了编程语言中的标识符

Scanner类接收字符流并产生一个标识符流，一次产生一个标识符(token)↓：

```C++
class Scanner {
public:
	Scanner(istream&);
	virtual ~Scanner();

	virtual Token& Scan();

private:
	istream& _inputStream;
};
```

用ProgramNodeBuilder，Parser类由Scanner生成的标识符构建一棵语法分析树↓：

```C++
class Parser {
public:
	Parser();
	virtual ~Parser();

	virtual void Parse(Scanner&, ProgramNodeBuilder&);
};
```

Parser回调ProgramNodeBuilder逐步建立语法分析树，这些类遵循[3.2 Builder(生成器)](3.创建型模式.md#32-builder生成器---对象创建型模式)模式进行交互操作↓：

```C++
class ProgramNodeBuilder {
public:
	ProgramNodeBuilder();

	virtual ProgramNode* NewVariable(const char* variableName) const;
	virtual ProgramNode* NewAssignment(ProgramNode* variable, ProgramNode* expression) const;
	virtual ProgramNode* NewReturnStatement(ProgramNode* value) const;
	virtual ProgramNode* NewCondition(ProgramNode* condition, Program* truePart, ProgramNode* falsePart) const;
	// ...
	ProgramNode* GetRootNode();

private:
	programNode* _node;
};
```

语法分析树由ProgramNode子类(例如StatementNode和ExpressionNode等)的实例构成。ProgramNode层次结构是[4.3 Composite(组成)](4.结构型模式.md#43-composite组成---对象结构型)模式的一个应用实例。ProgramNode定义了一个接口用于操作程序节点和它的子节点(如果有的话)↓：

```C++
class ProgramNode {
public:
	// program node manipulation(操作)
	virtual void GetSourcePosition(int& line, int& index);
	// ...

	// child manipulation
	virtual void Add(ProgramNode*);
	virtual void Remove(ProgramNode*);
	// ...

	virtual void Traverse(CodeGenerator&);

protected:
	ProgramNode();
};
```

Traverse(遍历)操作以一个CodeGenerator对象为参数，ProgramNode子类使用这个对象产生机器代码，机器代码格式为BytecodeStream中的ByteCode对象。其中的CodeGenerator类是一个访问者(参见[5.11 Visitor(访问者)](5.行为模式.md#511-visitor访问者---对象行为型模式))↓：

```C++
class CodeGenerator {
public:
	virtual void Visit(StatementNode*);
	virtual void Visit(ExpressionNode*);
	// ...

protected:
	CodeGenerator(BytecodeStream&);
	BytecodeStream& _output;
};
```

例如CodeGenerator类有两个子类StackMachineCodeGenerator和RISCCodeGenerator，分别为不同的硬件体系结构生成机器代码

ProgramNode的每个子类在实现Traverse时，对它的ProgramNode子对象调用Traverse。每个子类一次对它的子节点做同样的动作，这样一直递归下去。例如ExpressionNode如下定义Traverse↓：

```C++
void ExpressionNode::Traverse (CodeGenerator& cg) {
	cg.Visit(this);

	ListIterator<ProgramNode*> i(_children);

	for(i.First(); !i.IsDone(); i.Next())
		i.CurrentItem()->Traverse(cg);
}
```

我们上述讨论的类构成了编译子系统，现在我们引入Compiler类，Complier类是一个facade，它将所有部件集成在一起。Compiler提供了一个简单的接口用于为特定的机器编译源代码并生成可执行代码↓：

```C++
class Compiler {
public:
	Compiler();

	virtual void Compile(istream&, BytecodeStream&);
};

void Compiler::Compile(istream& input, BytecodeStream& output) {
	Scanner scanner(input);
	ProgramNodeBuilder builder;
	Parser parser;

	parser.Parse(scanner, builder);

	RISCCodeGenerator generator(output);
	ProgramNode* parseTree = builder.GetRootNode();
	parseTree->Traverse(generator);
}
```

上面的实现在代码中固定了要使用的代码生成器的种类，因此程序员不需要指定目标机的结构。在仅有一种目标机的情况下，这是合理的。如果有多种目标机，我们可能希望改变Compiler构造函数使之能接受CodeGenerator为参数，这样程序员可以在实例化Compiler时指定要使用的生成器。编译器的facade还可以对Scanner和ProgramNodeBuilder这样的其他一些参与者进行参数化以增加系统的灵活性，但是这并非Facade模式的主要任务，它的主要任务是为一般情况简化接口

8. 相关模式

[3.1 Abstract Factory(抽象工厂)](3.创建型模式.md#31-abstract-factory抽象工厂---对象创建型模式)模式可以与Facade模式一起使用以提供一个接口，这一接口可用来以一种子系统独立的方式创建子系统对象。AbstractFactory也可以代替Facade模式隐藏那些与平台相关的类

[5.5 Mediator(中介者)](5.行为模式.md#55-mediator中介者---对象行为型模式)模式与Facade模式的相似之处是，它抽象了一些已有的类的功能。然而，Mediator的目的是对同事之间的任意通讯进行抽象，通常集中不属于任何单个对象的功能。Mediator的同事对象知道中介者并与它通信，而不是直接与其他同类对象通信。相对而言，Facade模式仅对子系统对象的接口进行抽象，从而使它们更容易使用;它并不定义新功能，子系统也不知道facade的存在

通常来讲，仅需要一个Facade对象，因此Facade对象通常属于[3.5 Singleton(单件)](3.创建型模式.md#35-singleton单件---对象创建型模式)模式

## 4.6 Flyweight(享元)---对象结构型

1. 意图：运用共享技术有效地支持大量细粒度的对象

2. 适用性：Flyweight模式的有效性很大程度上取决于如何使用它以及在何处使用它。当以下情况都成立时使用Flyweight模式

	* 一个应用程序使用了大量的对象

	* 完全由于使用大量的对象，造成很大的存储开销

	* 对象的大多数状态都可变为外部状态

	* 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象

	* 应用程序不依赖于对象标识。由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值

	* 注：外部状态与内部状态：

		* 内部状态存储于flyweight中，它包含了独立于flyweight场景的信息，这些信息使得flyweight可以被共享

		* 外部状态取决于flyweight场景，并根据场景而变化，因此不可共享。用户对象负责在必要的时候将外部状态传递给flyweight

3. 参与者

	* Flyweight：描述一个接口，通过这个接口flyweight可以接受并作用于外部状态

	* ConcreteFlyweight：实现Flyweight接口，并为内部状态(如果有的话)增加存储空间。ConcreteFlyweight对象必须是可共享的。它所存储的状态必须是内部的；即它必须独立于ConcreteFlyweight对象的场景

	* UnsharedConcreteFlyweight：并非所有的Flyweight子类都需要被共享。Flyweight接口使共享成为可能，但它并不强制共享。在Flyweight对象结构的某些层次，UnsharedConcreteFlyweight对象通常将ConcreteFlyweight对象作为子节点

	* FlyweightFactory：创建并管理flyweight对象；确保合理地共享flyweight，当用户请求一个flyweight，FlyweightFactory对象提供一个已创建的实例或者创建一个实例(如果不存在的话)

	* Client：维持一个对flyweight的引用；计算或存储一个(多个)flyweight的外部状态

4. 协作

	* flyweight执行时所需的状态必定是内部的或外部的。内部状态存储于ConcreteFlyweight对象之中;而外部对象则由Client对象存储或计算。当用户调用flyweight对象的操作时，将该状态传递给它

	* 用户不应直接对ConcreteFlyweight类进行实例化，而只能从FlyweightFactory对象得到ConcreteFlyweight对象，这可以保证对它们适当地进行共享

5. 效果

	使用Flyweight模式时，传输、查找和/或计算外部状态都会产生运行时的开销，尤其当flyweight原先被存储为内部状态时。然而，空间上的节省抵消了这些开销。共享的flyweight越多，空间节省也就越大

	存储节约由以下几个因素决定:因为共享，实例总数减少的数目；对象内部状态的平均数目；外部状态是计算的还是存储的

	共享的Flyweight越多，存储节约也就越多。节约量随着共享状态的增多而增大。当对象使用大量的内部及外部状态，并且外部状态是计算出来的而非存储的时候，节约量将达到最大。所以可以用两种方法来节约存储:用共享减少内部状态的消耗，用计算时间换取对外部状态的存储

	Flyweight模式经常和[4.3 Composite(组成)](4.结构型模式.md#43-composite组成---对象结构型)模式结合起来表示一个层次式结构，这一层次式结构是一个共享叶节点的图。共享的结果是，Flyweight的叶节点不能存储指向父节点的指针。而父节点的指针将传给Flyweight作为它的外部状态的部分。这对于该层次结构中对象之间相互通讯的方式将产生很大的影响

6. 实现

	1. **删除外部状态**：

		该模式的可用性在很大程度上取决于是否容易识别外部状态并将它从共享对象中删除。如果不同种类的外部状态和共享前对象的数目相同的话，删除外部状态不会降低存储消耗。理想的状况是，外部状态可以由一个单独的对象结构计算得到，且该结构的存储要求非常小

		例如在文档编辑器中，可以用一个单独的结构存储排版布局信息，而不是存储每一个字符对象的字体和类型信息，布局图保持了带有相同排版信息的字符的运行轨迹。当某字符绘制自己的时候，作为绘图遍历的副作用它接收排版信息。因为通常文档使用的字体和类型数量有限，将该信息作为外部信息来存储，要比内部存储高效得多

	2. **管理共享对象**：

		因为对象是共享的，用户不能直接对它进行实例化，因此FlyweightFactory可以帮助用户查找某个特定的Flyweight对象。FlyweightFactory对象经常使用关联存储帮助用户查找感兴趣的Flyweight对象。例如在文档编辑器一例中的Flyweight工厂就有一个以字符代码为索引的Flyweight表。管理程序根据所给的代码返回相应的Flyweight，若不存在，则创建一个Flyweight

		共享还意味着某种形式的引用计数和垃圾回收，这样当一个Flyweight不再使用时，可以回收它的存储空间。然而，当Flyweight的数目固定而且很小的时候(例如用于ASCII码的Flyweight)，这两种操作都不必要。在这种情况下，Flyweight完全可以永久保存

7.代码示例

有些应用程序得益于在其整个设计过程中采用对象技术，但简单化的实现代价极大。例如，大多数文档编辑器的实现都有文本格式化和编辑功能，这些功能在一定程度上是模块化的。面向对象的文档编辑器通常使用对象来表示嵌入的成分，例如表格和图形。尽管用对象来表示文档中的每个字符会极大地提高应用程序的灵活性，但是这些编辑器通常并不这样做。字符和嵌入成分可以在绘制和格式化时统一处理，从而在不影响其他功能的情况下能对应用程序进行扩展，支持新的字符集。应用程序的对象结构可以模拟文档的物理结构。但这种设计的缺点在于代价太大。即使是一个中等大小的文档也可能要求成百上千的字符对象，这会耗费大量内存，产生难以接受的运行开销。所以通常并不是对每个字符都用一个对象来表示的。Flyweight模式描述了如何共享对象，使得可以细粒度地使用它们而无需高昂的代价

可以为Flyweight的图形对象定义一个Glyph(字形)基类。逻辑上，Glyph是一些Composite(见[4.3 Composite(组成)](4.结构型模式.md#43-composite组成---对象结构型))，它有图形化属性，并可以绘制自己。这里重点讨论字体属性，但这种方法也同样适用于Glyph的其他图形属性↓：

```C++
class Glyph {
public:
	virtual ~Glyph();

	virtual void Draw(Window*, GlyphContext&);

	virtual void SetFont(Font*, GlyphContext&);
	virtual Font* GetFont(GlyphContext&);
	virtual void First(GlyphContext&);
	virtual void Next(GlyphContext&);
	virtual bool IsDone(GlyphContext&);
	virtual Glyph* Current(GlyphContext&);

	virtual void Insert(Glyph*, GlyphContext&);
	virtual void Remove(GlyphContext&);

protected:
	Glyph();
};
```

Character的子类存储一个字符代码↓：

```C++
class Character : public Glyph {
public:
	Character(char);

	virtual void Draw(Window*, GlyphContext&);

private:
	char _charcode;
};
```

为了避免给每一个Glyph的字体属性都分配存储空间，我们可以将该属性外部存储于GlyphContext对象中。GlyphContext是一个外部状态的存储库，它维持Glyph与字体(以及其他一些可能的图形属性)之间的一种简单映射关系。对于任何操作，如果它需要知道在给定场景下Glyph字体，都会有一个GlyphContext实例作为参数传递给它。然后，该操作就可以查询GlyphContext以获取该场景中的字体信息了。这个场景取决于Glyph结构中的Glyph的位置。因此当使用Glyph时，Glyph子类的迭代和管理操作必须更新GlyphContext↓：

```C++
class GlyphContext {
public:
	GlyphContext();
	virtual ~GlyphContext();

	virtual void Next(int step = 1;
	virtual void Insert(int quantity = 1);

	virtual Font* GetFont();
	virtual void SetFont(Font*, int span = 1);

private:
	int _index;
	BTree* _fonts;
};
```

在遍历过程中，GlyphContext必须知道它在Glyph结构中的当前位置。随着遍历的进行，`GlyphContext::Next`增加_index的值。Glyph的子类(如Row和Column)对Next操作的实现必须使得它在遍历的每一点都调用`GlyphContext::Next`

`GlyphContext::GetFocus`将索引作为Btree结构的关键字，Btree结构存储glyph到字体的映射。树中的每个节点都标有字符串的长度，而它给这个字符串字体信息。树中的叶节点指向一种字体，而内部的字符串分成了很多子字符串，每一个对应一种子节点

字体信息的BTree结构可能如下:内部节点定义Glyph索引的范围。当字体改变或者在Glyph结构中添加或删除Glyph时，Btree将相应地被更新↓：

```C++
// 例如，假定我们遍历到索引102
// 以下代码将单词"except"的每个字符的字体设置为它周围的正文的字体
// 即用Time12字体，12-point Times Roman的一个实例

GlyphContext gc;
Font* times12 = new Font("Times-Roman-12");
Font* timesItalic12 = new Font("Times-Italic-12");
// ...
gc.SetFont(time12, 6);

// 假设我们要在单词"except"前用12-point Times Italic字体添加一个单词Don't
// (包括一个紧跟着的空格)
// 假定gc仍在索引位置102，以下代码通知gc这个事件
gc.Insert(6);
gc.SetFont(timesItalic12, 6);
```

当向GlyphContext查询当前Glyph的字体时，它将向下搜寻Btree，同时增加索引，直至找到当前索引的字体为止。由于字体变化频率相对较低，所以这棵树相对于Glyph结构较小。这将使得存储耗费较小，同时也不会过多的增加查询时间

FlyweightFactory是我们需要的最后一个对象，它负责创建Glyph并确保对它们进行合理共享。GlyphFactory类将实例化Character和其他类型的Glyph。我们只共享Character对象;组合的Glyph要少得多，并且它们的重要状态(如，他们的子节点)必定是内部的↓：

```C++
const int NCHARCODES = 128;

class GlyphFactory {
public:
	GlyphFactory();
	virtual ~GlyphFactory();
	virtual Character* CreateCharacter(char);
	virtual Row* CreateRow();
	virtual Column* CreateColumn();
	// ...

private:
	Character* _character[NCHARCODES];
};

// _character数组包含一些指针，指向以子母代码为索引的Character Glyphs
// 该数组在构造函数中被初始化为零
GlyphFactory::GlyphFactor() {
	for (int i = 0; i < NCHARCODE; ++i)
		_character[i] = 0;
}

// CreateCharacter在字母符号数组中查找一个字符，如果存在的话，返回相应Glyph
// 如果不存在，CreateGlyph就创建一个Glyph，将其放入数组中，并返回它
Character* GlyphFactory::CreateCharacter (char c) {
	if (!_character[c])
		_character[c] = new Character(c);
	return _character[c];
}

// 其他操作仅需在每次被调用时实例化一个新对象，因为非字符的Glyph不能被共享
Row* GlyphFactory::CreateRow() {
	return new Row;
}
Column* GlyphFactory::CreateColumn() {
	return new Column;
}
// 我们可以忽略这些操作，让用户直接实例化非共享的Glyph
// 然而如果我们想让这些符号以后可以被共享，必须改变创建它们的客户程序代码
```

8. 相关模式

Flyweight模式通常和[4.3 Composite(组成)](4.结构型模式.md#43-composite组成---对象结构型)模式结合起来，用共享叶结点的有向无环图实现一个逻辑上的层次结构

通常，最好用[Flyweight](4.结构型模式.md#46-flyweight享元---对象结构型)实现[5.8 State(状态)](5.行为模式.md#58-state状态---对象行为型模式)和[5.9 Strategy(策略)](5.行为模式.md#59-strategy策略---对象行为型模式)对象

## 4.7 Proxy(代理)---对象结构型

1. 意图:为其他对象提供一种代理以控制对这个对象的访问

2. 别名：Surrogate(代理)

3. 适用性：在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用Proxy模式。下面是一些可以使用Proxy模式的常见情况

	1. **远程代理(Remote Proxy)**：为一个对象在不同的地址空间提供局部代表

	2. **虚代理(Virtual Proxy)**：根据需要创建开销很大的对象

	3. **保护代理(Protection Proxy)**：控制对原始对象的访问。保护代理用于对象应该有不同的访问权限的时候

	4. **智能指引(Smart Reference)**：取代了简单的指针，它在访问对象时执行一些附加操作。它的典型用途包括:

		* 对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它(也称为Smart Pointers)

		* 当第一次引用一个持久对象时，将它装入内存

		* 在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它

4. 参与者

	* Proxy：

		* 保存一个引用使得代理可以访问实体。若RealSubject和Subject的接口相同，Proxy会引用Subject

		* 提供一个与Subject的接口相同的接口，这样代理就可以用来替代实体

		* 控制对实体的存取，并可能负责创建和删除它

		* 其他功能依赖于代理的类型：
			* Remote Proxy负责对请求及其参数进行编码，并向不同地址空间中的实体发送已编码的请求

			* Virtual Proxy可以缓存实体的附加信息，以便延迟对它的访问

			* Protection Proxy检查调用者是否具有实现一个请求所必需的访问权限

	* Subject：定义RealSubject和Proxy的共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy

	* RealSubject：定义Proxy所代表的实体

5. 协作：代理根据其种类，在适当的时候向RealSubject转发请求

6. 效果

	Proxy模式在访问对象时引入了一定程度的间接性。根据代理的类型，附加的间接性有多种用途：Remote Proxy可以隐藏一个对象存在于不同地址空间的事实；Virtual Proxy可以进行最优化，例如根据要求创建对象；Protection Proxies和Smart Reference都允许在访问一个对象时有一些附加的内务处理(Housekeeping task)

	Proxy模式还可以对用户隐藏另一种称之为copy-on-write(写时复制)的优化方式，该优化与根据需要创建对象有关。拷贝一个庞大而复杂的对象是一种开销很大的操作，如果这个拷贝根本没有被修改，那么这些开销就没有必要。用代理延迟这一拷贝过程，我们可以保证只有当这个对象被修改的时候才对它进行拷贝

	在实现Copy-on-write时必须对实体进行引用计数。拷贝代理仅会增加引用计数。只有当用户请求一个修改该实体的操作时，代理才会真正的拷贝它。在这种情况下，代理还必须减少实体的引用计数。当引用的数目为零时，这个实体将被删除

	Copy-on-Write可以大幅度的降低拷贝庞大实体时的开销

7. 实现

	1. 重载C++中的存取运算符：

		C++支持重载运算符->。重载这一运算符使得可以在撤销对一个对象的引用时，执行一些附加的操作。这一点可以用来实现某些种类的代理；代理的作用就像一个指针，下面的例子说明使用该计数实现一个称为ImagePtr的虚代理(Virtual Proxy)↓：

		```C++
		class Image;
		extern Image* LoadAnImageFile(const char*);	// 外部函数

		class ImagePtr {
		public:
			ImagePtr(const char* imageFile);
			virtual ~ImagePtr();

			virtual Image* operator->();
			virtual Image& operator*();

		private:
			Image* LoadImage();

			Image* _image;
			const char* _imageFile;
		};

		ImagePtr::ImagePtr(const char* theImageFile) {
			_imageFile = theImageFile;
			_image = 0;
		}

		Image* ImagePtr::LoadImage() {
			if (_image == 0)
				_image = LoadAnImageFile(_imageFile);
			return _image;
		}

		// 重载的->和*运算符使用LoadImage将_image返回给它的调用者(如果必要的话装入它)
		Image* ImagePtr::operator->() {
			return LoadImage();
		}
		Image& ImagePtr::operator*() {
			return *LoadImage();
		}

		// 该方法使得能够通过对ImagePtr对象调用Image操作
		// 而省去了把这些操作作为ImagePtr接口的一部分的麻烦
		ImagePtr image = ImagePtr("anImageFileName");
		image->Draw(Point(50, 100));
		// 等价于(image.operator->())->Draw(Point(50, 100))

		// 注意这里的image代理起到一个指针的作用，但并没有将它定义为一个指向Image的指针
		// 这意昧着不能把它当作一个真正的指向Image的指针来使用
		// 因此在使用此方法时用户应区别对待Image对象和ImagePtr对象
		```

		重载成员访问运算符并非对每一种代理来说都是好办法。有些代理需要清楚地知道调用了哪个操作，重载运算符的方法在这种情况下行不通

		正如示例代码中所示的那样，这些操作之间非常相似。一般来说，所有的操作在向实体转发请求之前，都要检验这个要求是否合法，原始对象是否存在等。但重复写这些代码很麻烦，因此我们一般用一个预处理程序自动生成它

	2. Proxy并不总是需要知道实体的类型：

		若Proxy类能够完全通过一个抽象接口处理它的实体，则无须为每一个RealSubject类都生成一个Proxy类;Proxy可以统一处理所有的RealSubject类。但是如果Proxy要实例化RealSubjects(例如在VirtualProxy中)，那么它们必须知道具体的类

		另一个实现方面的问题涉及到在实例化实体以前怎样引用它。有些代理必须引用它们的实体，无论它是在硬盘上还是在内存中。这意昧着它们必须使用某种独立于地址空间的对象标识符

8. 代码示例

对一个对象进行访问控制的一个原因是为了只有在我们确实需要这个对象时才对它进行创建和初始化。我们考虑一个可以在文档中嵌入图形对象的文档编辑器。有些图形对象(如大型光栅图像)的创建开销很大。但是打开文档必须很迅速，因此我们在打开文档时应避免一次性创建所有开销很大的对象。因为并非所有这些对象在文档中都同时可见，所以也没有必要同时创建这些对象

这一限制条件意味着，对于每一个开销很大的对象，应该根据需要进行创建，当一个图像变为可见时会产生这样的需要。问题的解决方案是使用另一个对象，即图像Proxy，替代那个真正的图像。Proxy可以代替一个图像对象，并且在需要时负责实例化这个图像对象

只有当文档编辑器激活图像代理的Draw操作以显示这个图像的时候，图像Proxy才创建真正的图像。Proxy直接将随后的请求转发给这个图像对象。因此在创建这个图像以后，它必须有一个指向这个图像的引用。我们假设图像存储在一个独立的文件中。这样我们可以把文件名作为对实际对象的引用。Proxy还存储了图像的尺寸(extent)，即它的长和宽。有了图像尺寸，Proxy无须真正实例化这个图像就可以响应格式化程序对图像尺寸的请求

文档编辑器通过抽象的Graphic类定义的接口访问嵌入的图像。ImageProxy是那些根据需要创建的图像的类，ImageProxy保存了文件名作为指向磁盘上的图像文件的指针。该文件名被作为一个参数传递给ImageProxy的构造器

ImageProxy还存储了这个图像的边框以及对真正的Image实例的指引，直到代理实例化真正的图像时，这个指引才有效。Draw操作必须保证在向这个图像转发请求之前，它已经被实例化了。GetExtent操作只有在图像被实例化后才向它传递请求，否则，ImageProxy返回它存储的图像尺寸

接下来实现上述的Virtual Proxy↓：

```C++
// Graphic为图形对象定义一个接口
class Graphic {
public:
	virtual ~Graphic();

	virtual void Draw(const Point& at) = 0;
	virtual void HandleMouse(Event& event) = 0;

	virtual const Point& GetExtent() = 0;

	virtual void Load(istream& from) = 0;
	virtual void Save(ostrean& to) = 0;

protected:
	Graphic();
};

// Image类实现了Graphic接口用来显示图像文件
// Image重定义HandleMouse操作，使得用户可以交互的调整图像的尺寸
class Image : public Graphic {
public:
	Image(const char* file);	// 从文件中加载图像
	virtual ~Image();

	virtual void Draw(const Point& at);	// 装载图像
	virtual void HandleMouse(Event& event);	// 向实际图像转发这个事件

	virtual const Point* GetExtent();	// 返回缓存的图像尺寸或从文件中装载图像

	virtual void Load(istream& from);
	virtual void Save(ostream& to);

private:
	// ...
};

// ImageProxy和Image具有相同的接口
class ImageProxy : public Graphic {
public:
	ImageProxy(const char* imageFile);
	virtual ~ImageProxy();

	virtual void Draw(const Point& at);
	virtual void HandleMouse(Event& event);
	virtual const Point* GetExtent();

	virtual void Load(istream& from);
	virtual void Save(ostream& to);

protected:
	Image* GetImage();

private:
	Image* _image;
	Point _extent;	// 范围
	char* _fileName;
};

// 构造函数保存了存储图像的文件名的本地拷贝，并初始化_extent和_image
ImageProxy::ImageProxy(const char* fileName) {
	_fileName = strdup(fileName);
	_extent = Point::Zero;	// 还不知道范围
	_image = 0;
}

Image* ImageProxy::GetImage() {
	if (_image == 0)
		_image = new Image(_fileName);
	return _image;
}

// 如果可能的话，GetExtent的实现部分返回缓存的图像尺寸
// 否则从文件中装载图像
const Point& ImageProxy::GetExtent() {
	if (_extent == Point::Zero)
		_extent = GetImage()->GetExtent();
	return _extent;
}

// Draw用来装载图像
void ImageProxy::Draw(const Point& at) {
	GetImage()->Draw(at);
}

// HandelMouse向实际图像转发这个事件
void ImageProxy::HandleMouse(Event& event) {
	GetImage()->HandleMouse(event);
}

// Save操作将缓存的图像尺寸和文件名保存在一个流中
// Load得到这个信息并初始化相应的成员函数
void ImageProxySave(ostream& to) {
	to << _extent << _fileName
}
void ImageProxy:Load(istream& from) {
	from >> _extent >> _fileName;
}

// 最后假设有一个类TextDocument能够包含Graphic对象
class TextDocument {
public:
	TextDocument();

	void Insert(Graphic*);
	// ...
};

// 可以用以下方式把ImageProxy插入到文本文件中
TextDocument* text = new TextDocument;
// ...
text->Insert(new ImageProxy("anImageFileName"));
```

9. 相关模式

[4.1 Adapter(适配器)](4.结构型模式.md#41-adapter适配器---类对象结构型)为它所适配的对象提供了一个不同的接口。相反，代理提供了与它的实体相同的接口。然而，用于访问保护的代理可能会拒绝执行实体会执行的操作，因此，它的接口实际上可能只是实体接口的一个子集

尽管[4.4 Decorator(装饰)](4.结构型模式.md#44-decorator装饰---对象结构型)的实现部分与代理相似，但decorator的目的不一样。Decorator为对象添加一个或多个功能，而代理则控制对对象的访问。代理的实现与decorator的实现类似，但是在相似的程度上有所差别。Protection Proxy的实现可能与decorator的实现差不多。另一方面，Remote Proxy不包含对实体的直接引用，而只是一个间接引用，如"主机ID，主机上的局部地址"。Virtual Proxy开始的时候使用一个间接引用，例如一个文件名，但最终将获取并使用一个直接引用

## 4.8 结构型模式的讨论

结构型模式之间具有相似性，尤其是它们的参与者和协作之间的相似性。这可能是因为结构型模式依赖于同一个很小的语言机制集合构造代码和对象：单继承和多重继承机制用于基于类的模式，而对象组合机制用于对象式模式。但是这些相似性掩盖了这些模式的不同意图。本节将对比这些结构型模式，使你对它们各目的优点有所了解

### 4.8.1 Adapter与Bridge

[4.1 Adapter(适配器)](4.结构型模式.md#41-adapter适配器---类对象结构型)模式和[4.2 Bridge(桥接)](4.结构型模式.md#42-bridge桥接---对象结构型)模式具有一些共同的特征。它们都给另一对象提供了一定程度上的间接性，因而有利于系统的灵活性。它们都涉及到从自身以外的一个接口向这个对象转发请求

这些模式的不同之处主要在于它们各自的用途。
[Adapter](4.结构型模式.md#41-adapter适配器---类对象结构型)模式主要是为了解决两个已有接口之间不匹配的问题。它不考虑这些接口是怎样实现的，也不考虑它们各自可能会如何演化。这种方式不需要对两个独立设计的类中的任一个进行重新设计，就能够使它们协同工作。另一方面，[Bridge](4.结构型模式.md#42-bridge桥接---对象结构型)模式则对抽象接口与它的(可能是多个)实现部分进行桥接。虽然这一模式允许你修改实现它的类，它仍然为用户提供了一个稳定的接口。[Bridge](4.结构型模式.md#42-bridge桥接---对象结构型)模式也会在系统演化时适应新的实现

由于这些不同点，[Adapter](4.结构型模式.md#41-adapter适配器---类对象结构型)和[Bridge](4.结构型模式.md#42-bridge桥接---对象结构型)模式通常被用于软件生命周期的不同阶段。当你发现两个不兼容的类必须同时工作时，就有必要使用[Adapter](4.结构型模式.md#41-adapter适配器---类对象结构型)模式，其目的一般是为了避免代码重复。此处耦合不可预见。相反，[Bridge](4.结构型模式.md#42-bridge桥接---对象结构型)的使用者必须事先知道:一个抽象将有多个实现部分，并且抽象和实现两者是独立演化的。[Adapter](4.结构型模式.md#41-adapter适配器---类对象结构型)模式在类已经设计好后实施;而[Bridge](4.结构型模式.md#42-bridge桥接---对象结构型)模式在设计类之前实施。这并不意味着[Adapter](4.结构型模式.md#41-adapter适配器---类对象结构型)模式不如[Bridge](4.结构型模式.md#42-bridge桥接---对象结构型)模式，只是因为它们针对了不同的问题。你可能认为[4.5 Facade(外观)](4.结构型模式.md#45-facade外观---对象结构型)是另外一组对象的适配器。但这种解释忽视了一个事实:即Facade定义一个新的接口，而[Adapter](4.结构型模式.md#41-adapter适配器---类对象结构型)则复用一个原有的接口。记住，适配器使两个已有的接口协同工作，而不是定义一个全新的接口

### 4.8.2 Composite、Decorator与Proxy

[4.3 Composite(组成)](4.结构型模式.md#43-composite组成---对象结构型)模式和[4.4 Decorator(装饰)](4.结构型模式.md#44-decorator装饰---对象结构型)模式具有类似的结构图，这说明它们都基于递归组合来组织可变数目的对象。这一共同点可能会使你认为，decorator对象是一个退化的composite，但这一观点没有领会[Decorator](4.结构型模式.md#44-decorator装饰---对象结构型)模式要点。相似点仅止于递归组合，同样，这是因为这两个模式的目的不同

[Decorator](4.结构型模式.md#44-decorator装饰---对象结构型)旨在使你能够不需要生成子类即可给对象添加职责。这就避免了静态实现所有功能组合，从而导致子类急剧增加。[Composite](4.结构型模式.md#43-composite组成---对象结构型)则有不同的目的，它旨在构造类，使多个相关的对象能够以统一的方式处理，而多重对象可以被当作一个对象来处理。它重点不在于修饰，而在于表示

尽管它们的目的截然不同，但却具有互补性。因此[Composite](4.结构型模式.md#43-composite组成---对象结构型)和[Decorator](4.结构型模式.md#44-decorator装饰---对象结构型)模式通常协同使用。在使用这两种模式进行设计时，我们无需定义新的类，仅需将一些对象插接在一起即可构建应用。这时系统中将会有一个抽象类，它有一些composite子类和decorator子类，还有一些实现系统的基本构建模块。此时，composites和decorator将拥有共同的接口。从[Decorator](4.结构型模式.md#44-decorator装饰---对象结构型)模式的角度看，composite是一个ConcreteComponent。而从[Composite](4.结构型模式.md#43-composite组成---对象结构型)模式的角度看，decorator则是一个Leaf。当然，他们不一定要同时使用，正如我们所见，它们的目的有很大的差别

另一种与[Decorator](4.结构型模式.md#44-decorator装饰---对象结构型)模式结构相似的模式是[4.7 Proxy(代理)](4.结构型模式.md#47-proxy代理---对象结构型)。这两种模式都描述了怎样为对象提供一定程度上的间接引用，proxy和decorator对象的实现部分都保留了指向另一个对象的指针，它们向这个对象发送请求。然而同样，它们具有不同的设计目的

像[Decorator](4.结构型模式.md#44-decorator装饰---对象结构型)模式一样，[Proxy](4.结构型模式.md#47-proxy代理---对象结构型)模式构成一个对象并为用户提供一致的接口。但与[Decorator](4.结构型模式.md#44-decorator装饰---对象结构型)模式不同的是，[Proxy](4.结构型模式.md#47-proxy代理---对象结构型)模式不能动态地添加或分离性质，它也不是为递归组合而设计的。它的目的是，当直接访问一个实体不方便或不符合需要时，为这个实体提供一个替代者，例如，实体在远程设备上，访问受到限制或者实体是持久存储的

在[Proxy](4.结构型模式.md#47-proxy代理---对象结构型)模式中，实体定义了关键功能，而[Proxy](4.结构型模式.md#47-proxy代理---对象结构型)提供(或拒绝)对它的访问。在[Decorator](4.结构型模式.md#44-decorator装饰---对象结构型)模式中，组件仅提供了部分功能，而一个或多个Decorator负责完成其他功能。[Decorator](4.结构型模式.md#44-decorator装饰---对象结构型)模式适用于编译时不能(至少不方便)确定对象的全部功能的情况。这种开放性使递归组合成为[Decorator](4.结构型模式.md#44-decorator装饰---对象结构型)模式中一个必不可少的部分。而在Proxy模式中则不是这样，因为[Proxy](4.结构型模式.md#47-proxy代理---对象结构型)模式强调一种关系([Proxy](4.结构型模式.md#47-proxy代理---对象结构型)与它的实体之间的关系)，这种关系可以静态的表达

模式间的这些差异非常重要，因为它们针对了面向对象设计过程中一些特定的经常发生问题的解决方法。但这并不意味着这些模式不能结合使用。可以设想有一个proxy-decorator，它可以给proxy添加功能，或是一个decorator-proxy用来修饰一个远程对象。尽管这种混合可能有用(我们手边还没有现成的例子)，但它们可以分割成一些有用的模式
