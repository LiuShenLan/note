- [1. 引言](#1-引言)
	- [1.1 什么是设计模式](#11-什么是设计模式)
	- [1.3 描述设计模式](#13-描述设计模式)
	- [1.4 设计模式的编目](#14-设计模式的编目)
	- [1.5 组织编目](#15-组织编目)
	- [1.6 设计模式怎样解决设计问题](#16-设计模式怎样解决设计问题)
		- [1.6.1 寻找合适的对象](#161-寻找合适的对象)
		- [1.6.2 决定对象的粒度](#162-决定对象的粒度)
		- [1.6.3 指定对象接口](#163-指定对象接口)
		- [1.6.4 描述对象的实现](#164-描述对象的实现)
		- [1.6.5 运用复用机制](#165-运用复用机制)
		- [1.6.6 关联运行时刻和编译时刻的结构](#166-关联运行时刻和编译时刻的结构)
		- [1.6.7 设计应支持变化](#167-设计应支持变化)
	- [1.7 怎样选择设计模式](#17-怎样选择设计模式)
	- [1.8 怎样使用设计模式](#18-怎样使用设计模式)

# 1. 引言

## 1.1 什么是设计模式

**设计模式**：对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述

一个设计模式的四个基本要素：

1. **模式名称**：一个助记名，它用一两个词来描述模式的问题、解决方案和效果。 命名一个新的模式增加了我们的设计词汇。设计模式允许我们在较高的抽象层次上进行设计。 基于一个模式词汇表，我们自己以及同事之间就可以讨论模式并在编写文档时使用它们。 模式名可以帮助我们思考，便于我们与其他人交流设计思想及设计结果。 找到恰当的模式名也是我们设计模式编目工作的难点之一

2. **问题**描述了应该在何时使用模式。它解释了设计问题和问题存在的前因后果，它可能描述了特定的设计问题，如怎样用对象表示算法等。也可能描述了导致不灵活设计的类或对象结构。有时候，问题部分会包括使用模式必须满足的一系列先决条件

3. **解决方案**描述了设计的组成成分，它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合(类或对象组合)来解决这个问题

4. **效果**描述了模式应用的效果及使用模式应权衡的问题。尽管我们描述设计决策时，并不总提到模式效果，但它们对于评价设计选择和理解使用模式的代价及好处具有重要意义。软件效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统的灵活性、扩充性或可移植性的影响，显式地列出这些效果对理解和评价这些模式很有帮助

## 1.3 描述设计模式

**模式名和分类**：模式名简洁地描述了模式的本质。一个好的名字非常重要，因为它将成为你的设计词汇表中的一部分。模式的分类反映了我们将在[1.5节组织编目](#15-组织编目)介绍的方案

**意图**：是回答下列问题的简单陈述：设计模式是做什么的？它的基本原理和意图是什么？它解决的是什么样的特定设计问题？

**别名**：模式的其他名称

**动机**：用以说明一个设计问题以及如何用模式中的类、对象来解决该问题的特定情景。该情景会帮助你理解随后对模式更抽象的描述

**适用性**：什么情况下可以使用该设计模式？该模式可用来改进哪些不良设计？你怎样识别这些情况？

**结构**：采用基于对象建模技术(OMT)的表示法对模式中的类进行图形描述。我们也使用了交互图来说明对象之间的请求序列和协作关系。附录B详细描述了这些表示法

**参与者**：指设计模式中的类和/或对象以及它们各自的职责

**协作**：模式的参与者怎样协作以实现它们的职责

**效果**：模式怎样支持它的目标？使用模式的效果和所需做的权衡取舍？系统结构的哪些方面可以独立改变？

**实现**：实现模式时需要知道的一些提示、技术要点及应避免的缺陷，以及是否存在某些特定于实现语言的问题

**代码示例**：用来说明怎样用C++或Smalltalk实现该模式的代码片段

**已知应用**：实际系统中发现的模式的例子。每个模式至少包括了两个不同领域的实例

**相关模式**：与这个模式紧密相关的模式有哪些？其间重要的不同之处是什么？这个模式应与哪些其他模式一起使用？

## 1.4 设计模式的编目

[3.1 Abstract Factory(抽象工厂)](3.创建型模式.md#31-abstract-factory抽象工厂---对象创建型模式)：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类

[4.1 Adapter(适配器)](4.结构型模式.md#41-adapter适配器---类对象结构型)：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作

[4.2 Bridge(桥接)](4.结构型模式.md#42-bridge桥接---对象结构型)：将抽象部分与它的实现部分分离，使它们都可以独立地变化

[3.2 Builder(生成器)](3.创建型模式.md#32-builder生成器---对象创建型模式)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

[5.1 Chain Of Responsibility(职责链)](5.行为模式.md#51-chain-of-responsibility职责链---对象行为型模式)：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它

[5.2 Command(命令)](5.行为模式.md#52-command命令---对象行为型模式)：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作

[4.3 Composite(组成)](4.结构型模式.md#43-composite组成---对象结构型)：将对象组合成树形结构以表示"部分-整体"的层次结构。Composite使得客户对单个对象和复合对象的使用具有一致性

[4.4 Decorator(装饰)](4.结构型模式.md#44-decorator装饰---对象结构型)：动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator模式比生成子类方式更为灵活

[4.5 Facade(外观)](4.结构型模式.md#45-facade外观---对象结构型)：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用

[3.3 Factory Method(工厂方法)](3.创建型模式.md#33-factory-method工厂方法---对象创建型模式)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类

[4.6 Flyweight(享元)](4.结构型模式.md#46-flyweight享元---对象结构型)：运用共享技术有效地支持大量细粒度的对象

[5.3 Interpreter(解释器)](5.行为模式.md#53-interpreter解释器---类行为型模式)：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子

[5.4 Iterator(迭代器)](5.行为模式.md#54-iterator迭代器---对象行为型模式)：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示

[5.5 Mediator(中介者)](5.行为模式.md#55-mediator中介者---对象行为型模式)：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互

[5.6 Memento(备忘录)](5.行为模式.md#56-memento备忘录---对象行为型模式)：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态

[5.7 Observer(观察者)](5.行为模式.md#57-observer观察者---对象行为型模式)：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新

[3.4 Prototype(原型)](3.创建型模式.md#34-prototype原型---对象创建型模式)：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象

[4.7 Proxy(代理)](4.结构型模式.md#47-proxy代理---对象结构型)：为其他对象提供一个代理以控制对这个对象的访问

[3.5 Singleton(单件)](3.创建型模式.md#35-singleton单件---对象创建型模式)：保证一个类仅有一个实例，并提供一个访问它的全局访问点

[5.8 State(状态)](5.行为模式.md#58-state状态---对象行为型模式)：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类

[5.9 Strategy(策略)](5.行为模式.md#59-strategy策略---对象行为型模式)：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户

[5.10 Template Method(模板方法)](5.行为模式.md#510-template-method模板方法---类行为型模式)：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤

[5.11 Visitor(访问者)](5.行为模式.md#511-visitor访问者---对象行为型模式)：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作

## 1.5 组织编目

设计模式空间↓：

|范围\目的|创建型|结构型|行为型|
|:-:|:-:|:-:|:-:|
|类|[3.3 Factory Method(工厂方法)](3.创建型模式.md#33-factory-method工厂方法---对象创建型模式)|[4.1 Adapter(适配器)(类)](4.结构型模式.md#41-adapter适配器---类对象结构型)|[5.3 Interpreter(解释器)](5.行为模式.md#53-interpreter解释器---类行为型模式)<br>[5.10 Template Method(模板方法)](5.行为模式.md#510-template-method模板方法---类行为型模式)|
|对象|[3.1 Abstract Factory(抽象工厂)](3.创建型模式.md#31-abstract-factory抽象工厂---对象创建型模式)<br>[3.2 Builder(生成器)](3.创建型模式.md#32-builder生成器---对象创建型模式)<br>[3.4 Prototype(原型)](3.创建型模式.md#34-prototype原型---对象创建型模式)<br>[3.5 Singleton(单件)](3.创建型模式.md#35-singleton单件---对象创建型模式)|[4.1 Adapter(适配器)(对象)](4.结构型模式.md#41-adapter适配器---类对象结构型)<br>[4.2 Bridge(桥接)](4.结构型模式.md#42-bridge桥接---对象结构型)<br>[4.3 Composite(组成)](4.结构型模式.md#43-composite组成---对象结构型)<br>[4.4 Decorator(装饰)](4.结构型模式.md#44-decorator装饰---对象结构型)<br>[4.5 Facade(外观)](4.结构型模式.md#45-facade外观---对象结构型)<br>[4.6 Flyweight(享元)](4.结构型模式.md#46-flyweight享元---对象结构型)<br>[4.7 Proxy(代理)](4.结构型模式.md#47-proxy代理---对象结构型)|[5.1 Chain Of Responsibility(职责链)](5.行为模式.md#51-chain-of-responsibility职责链---对象行为型模式)<br>[5.2 Command(命令)](5.行为模式.md#52-command命令---对象行为型模式)<br>[5.4 Iterator(迭代器)](5.行为模式.md#54-iterator迭代器---对象行为型模式)<br>[5.5 Mediator(中介者)](5.行为模式.md#55-mediator中介者---对象行为型模式)<br>[5.6 Memento(备忘录)](5.行为模式.md#56-memento备忘录---对象行为型模式)<br>[5.7 Observer(观察者)](5.行为模式.md#57-observer观察者---对象行为型模式)<br>[5.8 State(状态)](5.行为模式.md#58-state状态---对象行为型模式)<br>[5.9 Strategy(策略)](5.行为模式.md#59-strategy策略---对象行为型模式)<br>[5.11 Visitor(访问者)](5.行为模式.md#511-visitor访问者---对象行为型模式)|

我们根据两条准则对模式进行分类
1. 第一是**目的准则**，即模式是用来完成什么工作的：模式依据其目的可分为创建型(Creational)、结构型(Structural)、或行为型(Behavioral)三种
	1. **创建型模式**与对象的创建有关
	2. **结构型模式**处理类或对象的组合
	3. **行为型模式**对类或对象怎样交互和怎样分配职责进行描述
2. 第二是**范围准则**，指定模式主要是用于类还是用于对象
	1. **类模式**处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了
	2. **对象模式**处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性
	3. 从某种意义上来说，几乎所有模式都使用继承机制，所以"类模式"只指那些集中于处理类间关系的模式，而大部分模式都属于对象模式的范畴
3. 相互结合后如下
	1. **创建型类模式**将对象的部分创建工作延迟到子类；**创建型对象模式**则将它延迟到另一个对象中。
	2. **结构型类模式**使用继承机制来组合类；**结构型对象模式**则描述了对象的组装方式
	3. **行为型类模式**使用继承描述算法和控制流；**行为型对象模式**则描述一组对象怎样协作完成单个对象所无法完成的任务。

![设计模式之间的关系](设计模式之间的关系.jpg)

## 1.6 设计模式怎样解决设计问题

### 1.6.1 寻找合适的对象

面向对象程序由对象组成，**对象**包括数据和对数据进行操作的过程，过程通常称为**方法**或**操作**。对象在收到**客户**的**请求**(或**消息**)后，执行相应的操作

客户请求是使对象执行操作的唯一方法，操作又是对象改变内部数据的唯一方法。由于这些限制，对象的内部状态是被**封装**的，它不能被直接访问，它的表示对于对象外部是不可见的

面向对象设计最困难的部分是将系统分解成对象集合。因为要考虑许多因素：封装、粒度、依赖关系、灵活性、性能、演化、复用等等，它们都影响着系统的分解，并且这些因素通常还是互相冲突的

### 1.6.2 决定对象的粒度

对象在大小和数目上变化极大。它们能表示下自硬件或上自整个应用的任何事物。那么我们怎样决定一个对象应该是什么呢？

设计模式很好地讲述了这个问题。[4.5 Facade(外观)](4.结构型模式.md#45-facade外观---对象结构型)描述了怎样用对象表示完整的子系统，[4.6 Flyweight(享元)](4.结构型模式.md#46-flyweight享元---对象结构型)模式描述了如何支持大量的最小粒度的对象。其他一些设计模式描述了将一个对象分解成许多小对象的特定方法。[3.1 Abstract Factory(抽象工厂)](3.创建型模式.md#31-abstract-factory抽象工厂---对象创建型模式)和[3.2 Builder(生成器)](3.创建型模式.md#32-builder生成器---对象创建型模式)产生那些专门负责生成其他对象的对象。[5.10 Template Method(模板方法)](5.行为模式.md#510-template-method模板方法---类行为型模式)和[5.2 Command(命令)](5.行为模式.md#52-command命令---对象行为型模式)生成的对象专门负责实现对其他对象或对象组的请求

### 1.6.3 指定对象接口

对象声明的每一个操作指定操作名、作为参数的对象和返回值，这就是所谓的操作的**型构**。对象操作所定义的所有操作型构的集合被称为该对象的**接口**。对象接口描述了该对象所能接受的全部请求的集合，任何匹配对象接口中型构的请求都可以发送给该对象

**类型**是用来标识特定接口的一个名字。如果一个对象接受"Window"接口所定义的所有操作请求，那么我们就说该对象具有"Window"类型。一个对象可以有许多类型，并且不同的对象可以共享同一个类型。对象接口的某部分可以用某个类型来刻画。而其他部分则可用其他类型刻画。两个类型相同的对象只需要共享它们的部分接口。接口可以包含其他接口作为子集。当一个类型的接口包含另一个类型的接口时，我们就说它是另一个类型的**子类型**，另一个类型称之为它的**超类型**。我们常说子类型继承了它的超类型的接口

在面向对象系统中，接口是基本的组成部分。对象只有通过它们的接口才能与外部交流，如果不通过对象的接口就无法知道对象的任何事情，也无法请求对象做任何事情。对象接口与其功能实现是分离的，不同对象可以对请求做不同的实现，也就是说，两个有相同接口的对象可以有完全不同的实现

当给对象发送请求时，所引起的具体操作既与请求本身有关又与接受对象有关。支持相同请求的不同对象可能对请求激发的操作有不同的实现。发送给对象的请求和它的相应操作在运行时刻的连接就称之为**动态绑定**

动态绑定是指发送的请求直到运行时刻才受你的具体的实现的约束。因而，在知道任何有正确接口的对象都将接受此请求时，你可以写一个一般的程序，它期待着那些具有该特定接口的对象。进一步讲，动态绑定允许你在运行时刻彼此替换有相同接口的对象。这种可替换性就称为**多态**，它是面向对象系统中的核心概念之一。多态允许客户对象仅要求其他对象支持特定接口，除此之外对其假设几近于无。多态简化了客户的定义，使得对象间彼此独立，并可以在运行时刻动态改变它们相互的关系

设计模式通过确定接口的主要组成成分及经接口发送的数据类型，来帮助你定义接口。设计模式也许还会告诉你接口中不应包括哪些东西。

设计模式也指定了接口之间的关系。特别地，它们经常要求一些类具有相似的接口；或它们对一些类的接口做了限制

### 1.6.4 描述对象的实现

对象的实现是由它的**类**决定的，类制定了对象的内部数据和表示，也定义了对象所能完成的操作

对象通过**实例化**类来创建，此对象被称为该类的**实例**。当实例化类时，要给对象的内部数据(由**实例变量**组成)分配存储空间，并将操作与这些数据联系起来。对象的许多类似实例是由实例化同一个类来创建的

新的类可以由已存在的类通过**类继承**来定义。当**子类**继承**父类**时，子类包含了父类定义的所有数据和操作。子类的实例对象包含所有子类和父类定义的数据，且它们能完成子类和父类定义的所有操作

**抽象类**的主要目的是为它的子类定义公共接口。一个抽象类将把它的部分或全部操作的实现延迟到子类中，因此，一个抽象类不能被实例化。在抽象类中定义却没有实现的操作被称为**抽象操作**。非抽象类称为**具体类**

子类能够改进和重新定义它们父类的操作。更具体地说，类能够**重定义**父类定义的操作，重定义使得子类能接管父类对请求的处理操作。类继承允许你只需简单的扩展其他类就可以定义新类，从而可以很容易地定义具有相近功能的对象族

**混入类**是给其他类提供可选择的接口或功能的类。它与抽象类一样不能实例化。混入类要求多继承

1. 类继承与接口继承的比较

理解对象的**类**与对象的**类型**之间的差别非常重要

一个对象的类定义了对象是怎样实现的，同时也定义了对象的内部状态和操作的实现。但是对象的类型只与它的接口有关，接口即对象能响应的请求的集合。一个对象可以有多个类型，不同类的对象可以有相同的类型

当然，对象的类和类型是有紧密关系的。因为类定义了对象所能执行的操作，也定义了对象的类型。当我们说一个对象是一个类的实例时，即指该对象支持类所定义的接口

C++语言的类既指定对象的类型又指定对象的实现

理解类继承和接口继承(或子类型化)之间的差别也十分重要。类继承根据一个对象的实现定义了另一个对象的实现。简而言之，它是代码和表示的共享机制。然而，接口继承(或子类型化)描述了一个对象什么时候能被用来替代另一个对象

因为许多语言并不显式地区分这两个概念，所以容易被混淆。在C++语言中，继承既指接口的继承又指实现的继承。C++中接口继承的标准方法是公有继承一个含(纯)虚成员函数的类。C++中纯接口继承接近于公有继承纯抽象类，纯实现继承或纯类继承接近于私有继承

2. 对接口编程，而不是对实现编程

类继承是一个通过复用父类功能而扩展应用功能的基本机制。它允许你根据旧对象快速定义新对象。它允许你从已存在的类中继承所需要的绝大部分功能，从而几乎无需任何代价就可以获得新的实现

然而，实现的复用只是成功的一半，继承所拥有的定义具有相同接口的对象族的能力也是很重要的(通常可以从抽象类来继承)，因为多态依赖于这种能力

当继承被恰当使用时，所有从抽象类导出的类将共享该抽象类的接口。这意味着子类仅仅添加或重定义操作，而没有隐藏父类的操作。这时，所有的子类都能响应抽象类接口中的请求，从而子类的类型都是抽象类的子类型

只根据抽象类中定义的接口来操纵对象有以下两个好处：1.客户无须知道他们使用对象的特定类型，只须对象有客户所期望的接口；2.客户无须知道他们使用的对象是用什么类来实现的，他们只须知道定义接口的抽象类。这将极大地减少子系统实现之间的相互依赖关系，也产生了可复用的面向对象设计的如下原则：针对接口编程，而不是针对实现编程

不将变量声明为某个特定的具体类的实例对象，而是让它遵从抽象类所定义的接口

当你不得不在系统的某个地方实例化具体的类(即指定一个特定的实现)时，创建型模式可以帮你。通过抽象对象的创建过程，这些模式提供不同方式以在实例化时建立接口和实现的透明连接。创建型模式确保系统是采用针对接口的方式书写的，而不是针对实现而书写的

### 1.6.5 运用复用机制

理解对象、接口、类和继承之类的概念对大多数人来说并不难，问题的关键在于如何运用它们写出灵活的、可复用的软件。设计模式将告诉你怎样去做

1. 继承和组合的比较

面向对象系统中功能复用的两种最常用技术是类继承和对象组合

**类继承**允许根据其他类的实现来定义一个类的实现。这种通过生成子类的复用通常被称为**白箱复用**。术语"白箱"是相对可视性而言：在继承方式中，父类的内部细节对子类可见

**对象组合**是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为**黑箱复用**，因为对象的内部细节是不可见的。对象只以"黑箱"的形式出现

**类继承优点**：类继承是在编译时刻静态定义的，且可直接使用，因为程序设计语言直接支持类继承。类继承可以较方便地改变被复用的实现。当一个子类重定义一些而不是全部操作时，它也能影响它所继承的操作，只要在这些操作中调用了被重定义的操作

**类继承缺点**：首先，因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现。更糟的是，父类通常至少定义了部分子类的具体表示。因为继承对子类揭示了其父类的实现细节，所以继承常被认为"破坏了封装性"。子类中的实现与它的父类有如此紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化

当你需要复用子类时，实现上的依赖性就会产生一些问题。如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。一个可用的解决方法就是只继承抽象类，因为抽象类通常提供较少的实现

**对象组合优点**：是通过获得对其他对象的引用而在运行时刻动态定义的。组合要求对象遵守彼此的接口约定，进而要求更仔细地定义接口，而这些接口并不妨碍你将一个对象和其他对象一起使用。这还会产生良好的结果：因为对象只能通过接口访问，所以我们并不破坏封装性；只要类型一致，运行时刻还可以用一个对象来替代另一个对象；更进一步，因为对象的实现是基于接口写的，所以实现上存在较少的依赖关系

对象组合对系统设计还有另一个作用，即优先使用对象组合有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。另一方面，基于对象组合的设计会有更多的对象(而有较少的类)，且系统的行为将依赖于对象间的关系而不是被定义在某个类中。这导出了我们的面向对象设计的第二个原则：优先使用对象组合，而不是类继承

理想情况下，你不应为获得复用而去创建新的构件。你应该能够只使用对象组合技术，通过组装已有的构件就能获得你需要的功能。但是事实很少如此，因为可用构件的集合实际上并不足够丰富。使用继承的复用使得创建新的构件要比组装旧的构件来得容易。这样，继承和对象组合常一起使用。然而，我们的经验表明：设计者往往过度使用了继承这种复用技术。但依赖于对象组合技术的设计却有更好的复用性(或更简单)。你将会看到设计模式中一再使用对象组合技术

2. 委托

**委托**是一种组合方法，它使组合具有与继承同样的复用能力。在委托方式下，有两个对象参与处理一个请求，接受请求的对象将操作委托给它的**代理者**。这类似于子类将请求交给它的父类处理。使用继承时，被继承的操作总能引用接受请求的对象，C++中通过this成员变量。委托方式为了得到同样的效果，接受请求的对象将自己传给被委托者(代理人)，使被委托的操作可以引用接受请求的对象

委托的主要**优点**在于它便于运行时刻组合对象操作以及改变这些操作的组合方式。

委托与那些通过对象组合以取得软件灵活性的技术一样，具有如下**不足之处**：动态的、高度参数化的软件比静态软件更难于理解。还有运行低效问题，不过从长远来看人的低效才是更主要的。只有当委托使设计比较简单而不是更复杂时，它才是好的选择。要给出一个能确切告诉你什么时候可以使用委托的规则是很困难的。因为委托可以得到的效率是与上下文有关的，并且还依赖于你的经验。委托最适用于符合特定程式的情形，即标准模式的情形

有一些模式使用了委托，如[5.8 State(状态)](5.行为模式.md#58-state状态---对象行为型模式)、[5.9 Strategy(策略)](5.行为模式.md#59-strategy策略---对象行为型模式)和[5.11 Visitor(访问者)](5.行为模式.md#511-visitor访问者---对象行为型模式)。在State模式中，一个对象将请求委托给一个描述当前状态的State对象来处理。在Strategy模式中，一个对象将一个特定的请求委托给一个描述请求执行策略的对象，一个对象只会有一个状态，但它对不同的请求可以有许多策略。这两个模式的目的都是通过改变受托对象来改变委托对象的行为。在Visitor中，对象结构的每个元素上的操作总是被委托到Visitor对象

其他模式则没有这么多地用到委托。
[5.5 Mediator(中介者)](5.行为模式.md#55-mediator中介者---对象行为型模式)引进了一个中介其他对象间通信的对象。有时，Mediator对象只是简单地将请求转发给其他对象；有时，它沿着指向自己的引用来传递请求，使用真正意义的委托。[5.1 Chain Of Responsibility(职责链)](5.行为模式.md#51-chain-of-responsibility职责链---对象行为型模式)通过将请求沿着对象链传递来处理请求，有时，这个请求本身带有一个接受请求对象的引用，这时该模式就使用了委托。[4.2 Bridge(桥接)](4.结构型模式.md#42-bridge桥接---对象结构型)将实现和抽象分离开，如果抽象和一个特定实现非常匹配，那么这个实现可以代理抽象的操作

委托是对象组合的特例。它告诉你对象组合作为一个代码复用机制可以替代继承。

3. 继承和参数化类型的比较

另一种功能复用技术(并非严格的面向对象技术)是**参数化类型**，也就是**模板**(C++)。它允许你在定义一个类型时并不指定该类型所用到的其他所有类型。未经指定的类型在使用时以参数形式提供。例如，一个列表类能够以它所包含元素的类型来进行参数化。如果你想声明一个Integer列表，只需将Integer类型作为列表参数化类型的参数值；声明一个String列表，只需提供String类型作为参数值。语言的实现将会为各种元素类型创建相应的列表类模板的定制版本

参数化类型给我们提供除了类继承和对象组合外的第三种方法来组合面向对象系统中的行为。许多设计可以使用这三种技术中的任何一种来实现。这些技术存在着极大的不同之处。对象组合技术允许你在运行时刻改变被组合的行为，但是它存在间接性，比较低效。继承允许你提供操作的缺省实现，并通过子类重定义这些操作。参数化类型允许你改变类所用到的类型。但是继承和参数化类型都不能在运行时刻改变。哪一种方法最佳，取决于你设计和实现的约束条件

参数化类型在编译时刻不进行类型检查的语言中是完全不必要的

### 1.6.6 关联运行时刻和编译时刻的结构

一个面向对象程序运行时刻的结构通常与它的代码结构相差较大。代码结构在编译时刻就被确定下来了，它由继承关系固定的类组成。而程序的运行时刻结构是由快速变化的通信对象网络组成。事实上两个结构是彼此独立的，试图由一个去理解另一个就好像试图从静态的动、植物分类去理解活生生的生态系统的动态性。反之亦然

考虑对象**聚合**和**相识**的差别以及它们在编译和运行时刻的表示是多么的不同

**聚合**意味着一个对象拥有另一个对象或对另一个对象负责。一般我们称一个对象包含另一个对象或者是另一个对象的一部分。聚合意味着聚合对象和其所有者具有相同的生命周期

**相识**意味着一个对象仅仅知道另一个对象。有时相识也被称为"关联"或"引用"关系。相识的对象可能请求彼此的操作，但是它们不为对方负责。相识是一种比聚合要弱的关系，它只标识了对象间较松散的耦合关系

聚合和相识很容易混淆，因为它们通常以相同的方法实现。C++中，聚合可以通过定义表示真正实例的成员变量来实现，但更通常的是将这些成员变量定义为实例指针或引用；相识也是以指针或引用来实现

从根本上讲，是聚合还是相识是由你的意图而不是由显式的语言机制决定的。尽管它们之间的区别在编译时刻的结构中很难看出来，但这些区别还是很大的。聚合关系使用较少且比相识关系更持久；而相识关系则出现频率较高，但有时只存在于一个操作期间，相识也更具动态性，使得它在源代码中更难被辨别出来

程序的运行时刻结构和编译时刻结构存在这么大的差别，很明显代码不可能揭示关于系统如何工作的全部。系统的运行时刻结构更多地受到设计者的影响，而不是编程语言。对象和它们的类型之间的关系必须更加仔细地设计，因为它们决定了运行时刻程序结构的好坏

许多设计模式(特别是那些属于对象范围的)显式地记述了编译时刻。[4.3 Composite(组成)](4.结构型模式.md#43-composite组成---对象结构型)和[4.4 Decorator(装饰)](4.结构型模式.md#44-decorator装饰---对象结构型)对于构造复杂的运行时刻结构特别有用。[5.7 Observer(观察者)](5.行为模式.md#57-observer观察者---对象行为型模式)与运行时刻结构有关，但这些结构对于不了解该模式的人来说是很难理解的。[5.1 Chain Of Responsibility(职责链)](5.行为模式.md#51-chain-of-responsibility职责链---对象行为型模式)也产生了继承所无法展现的通信模式。总之，只有理解了模式，你才能清楚代码中的运行时刻结构

### 1.6.7 设计应支持变化

获得最大限度复用的关键在于对新需求和已有需求发生变化时的预见性，要求你的系统设计要能够相应地改进

为了设计适应这种变化、且具有健壮性的系统，你必须考虑系统在它的生命周期内会发生怎样的变化。一个不考虑系统变化的设计在将来就有可能需要重新设计。这些变化可能是类的重新定义和实现，修改客户和重新测试。重新设计会影响软件系统的许多方面，并且未曾料到的变化总是代价巨大的

设计模式可以确保系统能以特定方式变化，从而帮助你避免重新设计系统。每一个设计模式允许系统结构的某个方面的变化独立于其他方面，这样产生的系统对于某一种特殊变化将更健壮。下面阐述了一些导致重新设计的一般原因，以及解决这些问题的设计模式：

1. 通过显式地指定一个类来创建对象

在创建对象时指定类名将使你受特定实现的约束而不是特定接口的约束。这会使未来的变化更复杂。要避免这种情况，应该间接地创建对象

设计模式：[3.1 Abstract Factory(抽象工厂)](3.创建型模式.md#31-abstract-factory抽象工厂---对象创建型模式)，[3.3 Factory Method(工厂方法)](3.创建型模式.md#33-factory-method工厂方法---对象创建型模式)，[3.4 Prototype(原型)](3.创建型模式.md#34-prototype原型---对象创建型模式)

2. 对特殊操作的依赖

当你为请求指定一个特殊的操作时，完成该请求的方式就固定下来了。为避免把请求代码写死，你将可以在编译时刻或运行时刻很方便地改变响应请求的方法

设计模式：[5.1 Chain Of Responsibility(职责链)](5.行为模式.md#51-chain-of-responsibility职责链---对象行为型模式)，[5.2 Command(命令)](5.行为模式.md#52-command命令---对象行为型模式)

3. 对硬件和软件平台的依赖

外部的操作系统接口和应用编程接口(API)在不同的软硬件平台上是不同的。依赖于特定平台的软件将很难移植到其他平台上，甚至都很难跟上本地平台的更新。所以设计系统时限制其平台相关性就很重要了

设计模式：[3.1 Abstract Factory(抽象工厂)](3.创建型模式.md#31-abstract-factory抽象工厂---对象创建型模式)，[4.2 Bridge(桥接)](4.结构型模式.md#42-bridge桥接---对象结构型)

4. 对对象表示或实现的依赖

知道对象怎样表示、保存、定位或实现的客户在对象发生变化时可能也需要变化。对客户隐藏这些信息能阻止连锁变化

设计模式：
[3.1 Abstract Factory(抽象工厂)](3.创建型模式.md#31-abstract-factory抽象工厂---对象创建型模式)，[4.2 Bridge(桥接)](4.结构型模式.md#42-bridge桥接---对象结构型)，[5.6 Memento(备忘录)](5.行为模式.md#56-memento备忘录---对象行为型模式)，[4.7 Proxy(代理)](4.结构型模式.md#47-proxy代理---对象结构型)

5. 算法依赖

算法在开发和复用时常常被扩展、优化和替代。依赖于某个特定算法的对象在算法发生变化时不得不变化。因此有可能发生变化的算法应该被孤立起来

设计模式：[3.2 Builder(生成器)](3.创建型模式.md#32-builder生成器---对象创建型模式)，[5.4 Iterator(迭代器)](5.行为模式.md#54-iterator迭代器---对象行为型模式)，[5.9 Strategy(策略)](5.行为模式.md#59-strategy策略---对象行为型模式)，[5.10 Template Method(模板方法)](5.行为模式.md#510-template-method模板方法---类行为型模式)，[5.11 Visitor(访问者)](5.行为模式.md#511-visitor访问者---对象行为型模式)

6. 紧耦合

紧耦合的类很难独立地被复用，因为它们是互相依赖的。紧耦合产生单块的系统，要改变或删掉一个类，你必须理解和改变其他许多类。这样的系统是一个很难学习、移植和维护的密集体

松散耦合提高了一个类本身被复用的可能性，并且系统更易于学习、移植、修改和扩展。设计模式使用抽象耦合和分层技术来提高系统的松散耦合性

设计模式：[3.1 Abstract Factory(抽象工厂)](3.创建型模式.md#31-abstract-factory抽象工厂---对象创建型模式)，[5.2 Command(命令)](5.行为模式.md#52-command命令---对象行为型模式)，[4.5 Facade(外观)](4.结构型模式.md#45-facade外观---对象结构型)，[5.5 Mediator(中介者)](5.行为模式.md#55-mediator中介者---对象行为型模式)，[5.7 Observer(观察者)](5.行为模式.md#57-observer观察者---对象行为型模式)，[5.1 Chain Of Responsibility(职责链)](5.行为模式.md#51-chain-of-responsibility职责链---对象行为型模式)

7. 通过生成子类来扩充功能―通常很难通过定义子类来定制对象。每一个新类都有固定的实现开销(初始化、终止处理等)。定义子类还需要对父类有深入的了解。如，重定义一个操作可能需要重定义其他操作。一个被重定义的操作可能需要调用继承下来的操作。并且子类方法会导致类爆炸，因为即使对于一个简单的扩充，你也不得不引入许多新的子类

一般的对象组合技术和具体的委托技术，是继承之外组合对象行为的另一种灵活方法。新的功能可以通过以新的方式组合已有对象，而不是通过定义已存在类的子类的方式加到应用中去。另一方面，过多使用对象组合会使设计难于理解。许多设计模式产生的设计中，你可以定义一个子类，且将它的实例和已存在实例进行组合来引入定制的功能

设计模式：[4.2 Bridge(桥接)](4.结构型模式.md#42-bridge桥接---对象结构型)，[5.1 Chain Of Responsibility(职责链)](5.行为模式.md#51-chain-of-responsibility职责链---对象行为型模式)，[4.3 Composite(组成)](4.结构型模式.md#43-composite组成---对象结构型)，[4.4 Decorator(装饰)](4.结构型模式.md#44-decorator装饰---对象结构型)，[5.7 Observer(观察者)](5.行为模式.md#57-observer观察者---对象行为型模式)，[5.9 Strategy(策略)](5.行为模式.md#59-strategy策略---对象行为型模式)

8. 不能方便地对类进行修改有时你不得不改变一个难以修改的类。也许你需要源代码而又没有(对于商业类库就有这种情况)，或者可能对类的任何改变会要求修改许多已存在的其他子类。设计模式提供在这些情况下对类进行修改的方法

设计模式：[4.1 Adapter(适配器)](4.结构型模式.md#41-adapter适配器---类对象结构型)，[4.4 Decorator(装饰)](4.结构型模式.md#44-decorator装饰---对象结构型)，[5.11 Visitor(访问者)](5.行为模式.md#511-visitor访问者---对象行为型模式)

* **框架**是构成一类特定软件可复用设计的一组相互协作的类。
	* 框架规定了你的应用的体系结构。它定义了整体结构，类和对象的分割，各部分的主要责任，类和对象怎么协作，以及控制流程。框架预定义了这些设计参数，以便于应用设计者或实现者能集中精力于应用本身的特定细节。框架记录了其应用领域的共同的设计决策。因而框架更强调设计复用，尽管框架常包括具体的立即可用的子类

	* 因为模式和框架有些类似，人们常常对它们有怎样的区别和它们是否有区别感到疑惑。它们最主要的不同在于如下三个方面：
		1. 设计模式比框架更抽象框架能够用代码表示，而设计模式只有其实例才能表示为代码。框架的威力在于它们能够使用程序设计语言写出来，它们不仅能被学习，也能被直接执行和复用。而本书中的设计模式在每一次被复用时，都需要被实现。设计模式还解释了它的意图、权衡和设计效果
		2. 设计模式是比框架更小的体系结构元素﹐一个典型的框架包括了多个设计模式，而反之决非如此。
		3. 框架比设计模式更加特例化框架总是针对一个特定的应用领域。一个图形编辑器框架可能被用于一个工厂模拟，但它不会被错认为是一个模拟框架。而本书收录的设计模式几乎能被用于任何应用。当然比我们的模式更特殊的设计模式也是可能的(如，分布式系统和并发程序的设计模式)，尽管这些模式不会像框架那样描述应用的体系结构
	* 框架变得越来越普遍和重要。它们是面向对象系统获得最大复用的方式。较大的面向对象应用将会由多层彼此合作的框架组成。应用的大部分设计和代码将来自于它所使用的框架或受其影响

## 1.7 怎样选择设计模式

* 考虑设计模式是怎样解决设计问题的

[1.6 设计模式怎样解决设计问题](#16-设计模式怎样解决设计问题)讨论了设计模式怎样帮助你找到合适的对象、决定对象的粒度、指定对象接口以及设计模式解决设计问题的几个其他方法。参考这些讨论会有助于你找到合适的模式

* 浏览模式的意图部分

[1.4 设计模式的编目](#14-设计模式的编目)列出了目录中所有模式的意图部分。通读每个模式的意图，找出和你的问题相关的一个或多个模式。你可以使用[设计模式空间表](#15-组织编目)所显示的分类方法缩小你的搜查范围

* 研究模式怎样互相关联

* 研究目的相似的模式

模式分类描述部分共有三章，一章介绍创建型模式，一章介绍结构型模式，一章介绍行为型模式。每一章都以对模式介绍性的评价开始，以一个小节的比较和对照结束。这些小节使你得以洞察具有相似目的的模式之间的共同点和不同点

* 检查重新设计的原因

看一看从[1.6.7 设计应支持变化](#167-设计应支持变化)小节开始讨论的引起重新设计的各种原因，再看看你的问题是否与它们有关，然后再找出哪些模式可以帮助你避免这些会导致重新设计的因素

* 考虑你的设计中哪些是可变的

这个方法与关注引起重新设计的原因刚好相反。它不是考虑什么会迫使你的设计改变，而是考虑你想要什么变化却又不会引起重新设计。最主要的一点是封装变化的概念，这是许多设计模式的主题

下表列出了设计模式允许你独立变化的方面，你可以改变它们而又不会导致重新设计↓：

|目的|设计模式|可变的方面|
|:-:|:-:|:-:|
|创建|[3.1 Abstract Factory(抽象工厂)](3.创建型模式.md#31-abstract-factory抽象工厂---对象创建型模式)|产品对象家族|
|-|[3.2 Builder(生成器)](3.创建型模式.md#32-builder生成器---对象创建型模式)|如何创建一个组合对象|
|-|[3.3 Factory Method(工厂方法)](3.创建型模式.md#33-factory-method工厂方法---对象创建型模式)|被实例化的子类|
|-|[3.4 Prototype(原型)](3.创建型模式.md#34-prototype原型---对象创建型模式)|被实例化的类|
|-|[3.5 Singleton(单件)](3.创建型模式.md#35-singleton单件---对象创建型模式)|一个类的唯一实例|
|结构|[4.1 Adapter(适配器)](4.结构型模式.md#41-adapter适配器---类对象结构型)|对象的接口|
|-|[4.2 Bridge(桥接)](4.结构型模式.md#42-bridge桥接---对象结构型)|对象的实现|
|-|[4.3 Composite(组成)](4.结构型模式.md#43-composite组成---对象结构型)|一个对象的结构的组成|
|-|[4.4 Decorator(装饰)](4.结构型模式.md#44-decorator装饰---对象结构型)|对象的职责，不生成子类|
|-|[4.5 Facade(外观)](4.结构型模式.md#45-facade外观---对象结构型)|一个子系统的接口|
|-|[4.6 Flyweight(享元)](4.结构型模式.md#46-flyweight享元---对象结构型)|对象的存储开销|
|-|[4.7 Proxy(代理)](4.结构型模式.md#47-proxy代理---对象结构型)|如何访问一个对象；该对象的位置|
|行为|[5.1 Chain Of Responsibility(职责链)](5.行为模式.md#51-chain-of-responsibility职责链---对象行为型模式)|满足一个请求的对象|
|-|[5.2 Command(命令)](5.行为模式.md#52-command命令---对象行为型模式)|何时、怎样满足一个请求|
|-|[5.3 Interpreter(解释器)](5.行为模式.md#53-interpreter解释器---类行为型模式)|一个语言的文法及解释|
|-|[5.4 Iterator(迭代器)](5.行为模式.md#54-iterator迭代器---对象行为型模式)|如何遍历、访问一个聚合的各元素|
|-|[5.5 Mediator(中介者)](5.行为模式.md#55-mediator中介者---对象行为型模式)|对象间怎样交互、和谁交互|
|-|[5.6 Memento(备忘录)](5.行为模式.md#56-memento备忘录---对象行为型模式)|一个对象中那些私有信息存放在该对象之外，以及在什么时候存储|
|-|[5.7 Observer(观察者)](5.行为模式.md#57-observer观察者---对象行为型模式)|多个对象依赖于另外一个对象，而这些对象又如何保持一致|
|-|[5.8 State(状态)](5.行为模式.md#58-state状态---对象行为型模式)|对象的状态|
|-|[5.9 Strategy(策略)](5.行为模式.md#59-strategy策略---对象行为型模式)|算法|
|-|[5.10 Template Method(模板方法)](5.行为模式.md#510-template-method模板方法---类行为型模式)|算法中的某些步骤|
|-|[5.11 Visitor(访问者)](5.行为模式.md#511-visitor访问者---对象行为型模式)|某些可作用于一个(组)对象上的操作，但不修改这些对象的类|

## 1.8 怎样使用设计模式

1. 大致浏览一遍模式特别注意其适用性部分和效果部分，确定它适合你的问题

2. 回头研究结构部分、参与者部分和协作部分：确保你理解这个模式的类和对象以及它们是怎样关联的

3. 看代码示例部分，看看这个模式代码形式的具体例子：研究代码将有助于你实现模式

4. 选择模式参与者的名字，使它们在应用上下文中有意义：设计模式参与者的名字通常过于抽象而不会直接出现在应用中。然而，将参与者的名字和应用中出现的名字合并起来是很有用的。这会帮助你在实现中更显式的体现出模式来。例如，如果你在文本组合算法中使用了Strategy模式，那么你可能有名为SimpleLayoutStrategy或TeXLayoutStrategy这样的类

5. 定义类：声明它们的接口，建立它们的继承关系，定义代表数据和对象引用的实例变量。识别模式会影响到的你的应用中存在的类，做出相应的修改

6. 定义模式中专用于应用的操作名称：这里再一次体现出，名字一般依赖于应用。使用与每一个操作相关联的责任和协作作为指导。还有，你的名字约定要一致。例如，可以使用"Create"前缀统一标记Factory方法

7. 实现执行模式中责任和协作的操作实现部分提供线索指导你进行实现。代码示例部分的例子也能提供帮助

关于设计模式，如果不提一下它们的使用限制，那么关于怎样使用它们的讨论就是不完整的。设计模式不能够随意使用。通常你通过引入额外的间接层次获得灵活性和可变性的同时，你也使设计变得更复杂并/或牺牲了一定的性能。一个设计模式只有当它提供的灵活性是真正需要的时候，才有必要使用。当衡量一个模式的得失时，它的效果部分是最能提供帮助的
