- [2.实例研究：设计一个文档编辑器](#2实例研究设计一个文档编辑器)
	- [2.1 设计问题](#21-设计问题)
	- [2.2 文档结构](#22-文档结构)
		- [2.2.1 递归组合](#221-递归组合)
		- [2.2.2 图元](#222-图元)
		- [2.2.3 组合模式](#223-组合模式)
	- [2.3 格式化](#23-格式化)
		- [2.3.1 封装格式化算法](#231-封装格式化算法)
		- [2.3.2 Compositor和Composition](#232-compositor和composition)
		- [2.3.3 策略模式](#233-策略模式)
	- [2.4 修饰用户界面](#24-修饰用户界面)
		- [2.4.1 透明围栏](#241-透明围栏)
		- [2.4.3 Decorator模式](#243-decorator模式)
	- [2.5 支持多种视感标准](#25-支持多种视感标准)
		- [2.5.3 Abstract Factory模式](#253-abstract-factory模式)
	- [2.6 支持多种窗口系统](#26-支持多种窗口系统)
		- [2.6.1 我们是否可以使用Abstract Factory模式](#261-我们是否可以使用abstract-factory模式)
		- [2.6.2 封装实现依赖关系](#262-封装实现依赖关系)
		- [2.6.4 Bridge模式](#264-bridge模式)
	- [2.7 用户操作](#27-用户操作)
		- [2.7.5 Command模式](#275-command模式)
	- [2.8 拼写检查和断字处理](#28-拼写检查和断字处理)
		- [2.8.4 Iterator模式](#284-iterator模式)
		- [2.8.8 Visitor模式](#288-visitor模式)

# 2.实例研究：设计一个文档编辑器

这一章将通过设计一个称为"Lexi"的"所见即所得"(或"WYSIWYG")的文档编辑器，来介绍设计模式的实际应用。我们将会看到在Lexi和类似应用中，设计模式是怎样解决设计问题的。在本章最后，通过这个例子的学习将获得8个模式的实用经验

Lexi的用户界面：文档的所见即所得的表示占据了中间的大矩形区域。文档能够以不同的格式风格自由混合文本和图形。文档的周围是通常的下拉菜单和滚动条，以及一些用来跳到特定页的页码图标

## 2.1 设计问题

1. 文档结构：对文档内部表示的选择几乎影响Lexi设计的每个方面。所有的编辑、格式安排、显示和文本分析都涉及到这种表示。我们怎样组织这个信息会影响到应用的其他方面

2. 格式化：Lexi是怎样将文本和图形安排到行和列上的？哪些对象负责执行不同的格式策略？这些策略又是怎样和内部表述相互作用的？

3. 修饰用户界面：Lexi的用户界面包括滚动条、边界和用来修饰WYSIWYG文档界面的阴影。这些修饰有可能随着Lexi用户界面的演化而发生变化。因此，在不影响应用其他方面的情况下，能自由增加和去除这些修饰就十分重要了

4. 支持多种视感(look-and-feel)标准：Lexi应不需作较大修改就能适应不同的视感标准，如Motif和Presentation Manager(PM)等

5. 支持多种窗口系统：不同的视感标准通常是在不同的窗口系统上实现的。Lexi的设计应尽可能的独立于窗口系统

6. 用户操作：用户通过不同的用户界面控制Lexi，包括按钮和下拉菜单。这些界面对应的功能分散在整个应用对象中。这里的难点在于提供一个统一的机制，既可以访问这些分散的功能，又可以对操作进行撤消

7. 拼写检查和连字符：Lexi是怎样支持像检查拼写错误和决定连字符的连字点这样的分析操作的？当我们不得不添加一个新的分析操作时，我们怎样尽量少修改相关的类？

我们将在下面的各节里讨论这些设计问题。每个问题都有一组相关联的目标集合和我们怎样达到这些目标的限制条件集合。在给出特定解决方案之前，我们会详细解释设计问题的目标和限制条件。问题和其解决方案会列举一个或多个设计模式。对每个问题的讨论将在对相关设计模式的简单介绍后结束

## 2.2 文档结构

从根本上来说，一个文档只是对字符、线、多边形和其他图形元素的一种安排。这些元素记录了文档的整个信息内容。然而，一个文档作者通常并不将这些元素看作图形项，而是看作文档的物理结构——行、列、图形、表和其他子结构。而这些子结构也有自己的子结构

Lexi的用户界面应该让用户直接操纵这些子结构。例如，一个用户应该能够将一个图表当作一个单元，而不是个别图形原语的一组集合。用户应该能够对表进行整体引用，而不是将表作为非结构化的一堆文本和图形。这有助于使界面简单和直观。为了使Lexi的实现具有类似的性质，我们选择能匹配文档物理结构的内部表示

特别的，内部表示应支持如下几点：1.保持文档的物理结构。即将文本和图形安排到行、列、表等；2.可视化生成和显示文档；3.根据显示位置来映射文档内部表示的元素。这可以使Lexi根据用户在可视化表示中所点击的某个东西来决定用户所引用的文档元素

除了这些目标外，还有一些限制条件。首先，我们应该一致对待文本和图形。应用界面允许用户在图形中自由的嵌入文本，反之亦然。我们应该避免将图形看作文本的一种特殊情形，或将文本看作图形的特例。否则，我们最后得到的是冗余的格式和操纵机制。机制集合应该使文本和图形都能满足

其次，我们的实现不应该过分强调内部表示中单个元素和元素组之间的差别。Lexi应该能够一致地对待简单元素和组合元素，这样就允许任意复杂的文档。一旦我们知道这个元素能够画出自己并指定了它的区域，那么它怎样显示在页面上和它的显示位置的确定就并不困难了

然而，为了检查拼写错误和确定连字符的连接点，需要对文本进行分析。这就与第二个限制条件产生了矛盾。我们通常并不关心一行上的元素是简单对象还是复杂对象，但是文本分析有时候依赖于被分析的对象。例如，检查多边形的拼写或以连字符连接它是没有意义的。文档内部表示设计应该考虑和权衡这个或其他潜在的彼此矛盾的限制条件

### 2.2.1 递归组合

层次结构信息的表述通常是通过一种被称为**递归组合**的技术来实现的。递归组合可以由较简单的元素逐渐建立复杂的元素，是我们通过简单图形元素构造文档的方法之一。将字符和图形从左到右排列形成文档的一行，然后由多行形成一列，再由多列形成一页，等等。我们将每一个重要元素表示成一个对象，就可以描述这种物理结构。它不仅包括字符、图形等可见元素，也包括不可见的、结构化的元素，如行和列

通过用对象表示文档的每一个字符和图形元素，我们可以提高Lexi最佳设计的灵活性。我们能够在显示、格式化和互相嵌入等方面一致对待图形和文本。我们能够扩展Lexi以支持新的字符集而不会影响其他功能。Lexi的对象结构与文档的物理结构非常相像

这里隐含了两个重要的地方。第一个很明显，对象需要相应的类。第二个就不那么明显了，因为我们要一致性地对待这些对象，所以这些类必须有兼容的接口。在像C++这样的语言中，可以通过继承来关联类，使得接口兼容

### 2.2.2 图元

为出现在文档结构中的所有对象定义一个抽象类**图元**。它的子类即定义了基本的图形元素(像字符和图像)，又定义了结构元素(像行和列)。图元有三个基本责任：怎样画出自己、它们占用多大空间、它们的父图元和子图元是什么

### 2.2.3 组合模式

递归组合不仅可用来表示文档，我们还可以用它表示任何潜在复杂的、层次式的结构。[4.3 Composite(组成)](4.结构型模式.md#43-composite组成---对象结构型)模式描述了面向对象的递归组合的本质。现在是回到此模式并学习它的时候了，需要时再回头参考这个场景

## 2.3 格式化

我们已经解决了文档物理结构的表示问题。接着，我们需要解决的问题是怎样构造一个特殊物理结构，该结构对应于一个恰当地格式化了的文档。表示和格式化是不同的，记录文档物理结构的能力并没有告诉我们怎样得到一个特殊格式化结构。这个责任大多在于Lexi，它必须将文本分解成行，将行分解成列等等。同时还要考虑用户的高层次的要求，例如，用户可能会指定边界宽度、缩进大小和表格形式、是否隔行显示以及其他可能的许多格式限制条件。Lexi的格式化算法必须考虑所有这些因素。

现在我们将"格式化"含义限制为将一个图元集合分解为若干行。下面我们可以互换使用术语"格式化"和"分行"。下面讨论的技术同样适用于将行分解为列和将列分解为页

### 2.3.1 封装格式化算法

因为格式化算法趋于复杂化，因而可以考虑将它们包含于文档结构之中，但最好是将它们彻底独立于文档结构之外。理想情况下，我们能够自由地增加一个Glyph子类而不用考虑格式算法。反过来，增加一个格式算法不应要求修改已有的图元类

这些特征要求我们设计的Lexi易于改变格式化算法。最好能在运行时刻改变这个算法，如果难以实现，至少在编译时刻应该可以很方便地改变。我们可以将算法独立出来，并把它封装到对象中使其便于替代。更进一步，可以定义一个封装格式化算法的对象的类层次结构。类层次结构的根结点将定义支持许多格式化算法的接口，每个子类实现这个接口以执行特定的算法。那时就能让Glyph子类对象自动使用给定算法对象来排列其子图元

### 2.3.2 Compositor和Composition

为能封装格式化算法的对象定义一个Compositor类。它的接口可让compositor获知何时去格式化哪些图元。它所格式化的图元是一个被称为Composition的特定图元的各个子图元。一个Composition在创建时得到一个Compositor子类实例，并在必要的时候(如用户改变文档的时候)让Compositor对它的图元做Compose操作

一个未格式化的Composition对象只包含组成文档基本内容的可见图元。它并不包含像行和列这样的决定文档物理结构的图元。Composition对象只在刚被创建并以待格式化的图元进行初始化后，才处于这种状态。当Composition需要格式化时，调用它的Compositor的Compose操作。Compositor依次遍历Composition的各个子图元，根据分行算法插入新的行和列图元

Compositor-Composition类的分离确保了支持文档物理结构的代码和支持不同格式化算法的代码之间的分离。我们能增加新的Compositor子类而不触及Glyph类，反之亦然。事实上，我们通过给Composition的基本图元接口增加一个SetCompositor操作，即可在运行时刻改变分行算法

### 2.3.3 策略模式

在对象中封装算法是[5.9 Strategy(策略)](5.行为模式.md#59-strategy策略---对象行为型模式)模式的目的。模式的主要参与者是Strategy对象(这些对象中封装了不同的算法)和它们的操作环境。其实Compositor就是Strategy。它们封装了不同的格式算法。Composition就是Compositor策略的环境

Strategy模式应用的关键点在于为Strategy和它的环境设计足够通用的接口，以支持一系列的算法。你不必为了支持一个新的算法而改变Strategy或它的环境。在我们的例子中，支持子图元访问、插入和删除操作的基本Glyph接口就足以满足一般的用户需求，不管Compositor子类使用何种算法，都足以支持其对文档的物理结构的修改。同样地，Compositor接口也足以支持Composition启动格式化操作

## 2.4 修饰用户界面

我们针对Lexi用户界面考虑两种修饰，第一种是在文本编辑区域周围加边界以界定文本页；第二种是加滚动条让用户能看到同一页的不同部分。为了便于增加和去除这些修饰(特别是在运行时刻)，我们不应该通过继承方式将它们加到用户界面。如果其他用户界面对象不知道存在这些修饰，那么我们就获得了最大的灵活性。这使我们无需改变其他的类就能增加和移去这些修饰

### 2.4.1 透明围栏

**透明围栏**结合了两个概念：1.单子女(单组件)组合；2.兼容的接口。客户通常分辨不出它们是在处理组件还是组件的围栏(即，这个组件的父组件)，特别是当围栏只是代理组件的所有操作时更是如此。但是围栏也能通过在代理操作之前或之后添加一些自己的操作来修改组件的行为。围栏也能有效地为组件添加状态

### 2.4.3 Decorator模式

[4.4 Decorator(装饰)](4.结构型模式.md#44-decorator装饰---对象结构型)模式描述了以透明围栏来支持修饰的类和对象的关系。事实上术语"修饰"的含义比我们这里讨论的更广泛。在Decorator模式中，修饰指给一个对象增加职责的事物。我们可以想到用语义动作修饰抽象语法树、用新的转换修饰有穷状态自动机或者以属性标签修饰持久对象网等例子。Decorator一般化了我们在Lexi中使用的方法，而使它具有更广泛的实用性

## 2.5 支持多种视感标准

获得跨越硬件和软件平台的可移植性是系统设计的主要问题之一。将Lexi重新定位于一个新的平台不应当要求对Lexi进行重大的修改，否则的话就失去了重新定位Lexi的价值。我们应当使移植尽可能地方便

移植的一大障碍是不同视感标准之间的差异性。视感标准本是用来加强某一窗口平台上各个应用之间用户界面的一致性的。这些标准定义了应用应孩怎样显示和对用户请求作出反映。虽然已有的标准彼此差别不大，但用户还是可以清楚地区分它们---一个应用程序在Motif平台上的视感决不会与其他某个平台上的完全一样，反之亦然。一个运行于多个平台的应用程序必须符合各个平台的用户界面风格

我们的设计目标就是使Lexi符合多个已存在的视感标准，并且在新标准出现时要能很容易地增加对新标准的支持。我们也希望我们的设计能支持最大限度的灵活性：运行时刻可以改变Lexi的外观和感觉

### 2.5.3 Abstract Factory模式

工厂(Factory)和产品(Product)是[3.1 Abstract Factory(抽象工厂)](3.创建型模式.md#31-abstract-factory抽象工厂---对象创建型模式)模式的主要参与者。该模式描述了怎样在不直接实例化类的情况下创建一系列相关的产品对象。它最适用于产品对象的数目和种类不变，而具体产品系列之间存在不同的情况。我们通过实例化一个特定的具体工厂对象来选择产品系列，并且以后一直使用该工厂生产产品对象。我们也能够通过用一个不同的具体工厂实例来替换原来的工厂对象以改变整个产品系列。抽象工厂模式对产品系列的强调使它区别于其他只与一种产品对象有关的创建性模式

## 2.6 支持多种窗口系统

视感只是众多移植问题之一。另一个移植性问题就是Lexi所运行的窗口环境。一个平台将多个互相重叠的窗口展示在一个点阵显示器上。它管理屏幕空间和键盘、鼠标到窗口的输入通道。目前存在一些互不兼容的重要的窗口系统。我们希望Lexi可以在尽可能多的窗口系统上运行，这和Lexi要支持多个视感标准是同样的道理

### 2.6.1 我们是否可以使用Abstract Factory模式

乍一看，这似乎又是一个使用Abstract Factory模式的情况。但是对窗口系统移植的限制条件与视感的独立性条件是有极大不同的

在使用Abstract Factory模式时，我们假设我们能为每一个视感标准定义具体的窗口组件类。这意味着我们能从一个抽象产品类(如ScrollBar)，针对一个特定标准来导出每一个具体产品(如MotifScrollBar、MacScrollBar等)。现在假设我们已经有一些不同厂家的类层次结构，每一个类层次对应一个视感标准。当然，这些类层次不太可能有太多兼容之处。因而我们无法给每个窗口组件(滚动条、按钮、菜单等)都创建一个公共抽象产品类。而没有这些类Abstract Factory模式无法工作。所以我们不得不根据抽象产品接口的共同集合来调整不同的窗口组件类层次结构。只有这样我们才能在我们的抽象工厂接口中定义合适的Create...操作

对窗口组件，我们通过开发我们自己的抽象和具体的产品类来解决这个问题。现在当我们试图使Lexi工作在已有窗口的系统时，我们面对的是类似的问题。即不同的窗口系统有不兼容的程序设计接口。但这次的麻烦更大些，因为我们不能实现我们自己的非标准窗口系统

但是事情还是有挽回的余地。像视感标准一样，窗口系统的接口也并非截然不同。因为所有的窗口系统总的来说是做同一件事的。我们可对不同的窗口系统作一个统一的抽象，在对各窗口系统的实现作一些调整，使之符合公共的接口

### 2.6.2 封装实现依赖关系

与在格式化和修饰时做过的相同：对变化的概念进行封装。现在所变化的是窗口系统实现。如果我们能在一个对象中封装窗口系统的功能，那么我们就能根据对象接口实现Window类及其子类。更进一步讲，如果那个接口能够提供我们所感兴趣的所有窗口系统的服务，那么我们无需改变Window类或其子类，也能支持不同的窗口系统。我们可以通过简单传递合适的窗口系统封装对象，来给我们想要的窗口系统设定窗口对象。我们甚至能在运行时刻设定窗口

### 2.6.4 Bridge模式

WindowImp类定义了一个公共窗口系统设施的接口，但它的设计是受不同于Window接口的限制条件驱动的。应用程序员不直接处理WindowImp的接口；它们只处理Window对象。所以WindowImp的接口不必与应用程序员的客观世界视图一致，就像我们只关心Window类层次和接口的设计。WindowImp的接口更能如实反映事实上提供的是什么窗口系统。它可以偏向于功能方法的交集，也可以偏向于功能方法的合集，只要是最适合各目标窗口系统即可

要注意的是Window类接口是针对应用程序员的，而WindowImp接口是针对窗口系统的。将窗口功能分离到Window和WindowImp类层次中，这样我们可以独立实现这些接口。这些类层次的对象合作来实现Lexi无需修改就能运行在多窗口系统的目标

Window和WindowImp的关系是[4.2 Bridge(桥接)](4.结构型模式.md#42-bridge桥接---对象结构型)模式的一个例子。Bridge模式的目的就是允许分离的类层次一起工作，即使它们是独立演化的。我们的设计准则使得我们创建了两个分离的类层次，一个支持窗口的逻辑概念，另一个描述了窗口的不同实现。Bridge模式允许我们保持和加强我们对窗口的逻辑抽象，而不触及窗口系统相关的代码。反之也一样

## 2.7 用户操作

### 2.7.5 Command模式

Lexi的命令是[5.2 Command(命令)](5.行为模式.md#52-command命令---对象行为型模式)模式的应用。该模式描述了怎样封装请求，也描述了一致性的发送请求的接口，允许你配置客户端以处理不同请求。该接口保护了客户请求的实现。一个命令可以将所有或部分的请求实现委托给其他对象，也可不进行委托。这对于像Lexi这样必须为分散功能提供集中访问的应用来说，是相当完美的。该模式还讨论了基于基本的Command接口的撤销和重做机制

## 2.8 拼写检查和断字处理

需要处理的问题：1.访问需要分析的信息，而它们是被分散在文档结构的图元中的；2.分析这些信息

### 2.8.4 Iterator模式

[5.4 Iterator(迭代器)](5.行为模式.md#54-iterator迭代器---对象行为型模式)模式描述了那些支持访问和遍历对象结构的技术，它不仅可用于组合结构也可用于集合。该模式抽象了遍历算法，对客户隐藏了它所遍历对象的内部结构。Iterator模式再一次说明了怎样封装变化的概念，有助于我们获得灵活性和复用性。尽管如此，Iteration问题的复杂性还是令人吃惊的，Iterator模式包含了比我们这里考虑的更多的细微差别和权衡

### 2.8.8 Visitor模式

[5.11 Visitor(访问者)](5.行为模式.md#511-visitor访问者---对象行为型模式)模式允许对图元结构所作分析的数目不受限制地增加而不必改变图元类本身。访问者类的另一个优点是它不局限使用于像图元结构这样的组合者，也适用于其他任何对象结构。包括集合、列表，甚至无环有向图。再者，访问者所能访问的类之间无需通过一个公共父类关联起来。也就是说，访问者能跨越类层次结构

在使用Visitor模式之前你要问自己的一个重要问题是：哪一个类层次变化得最厉害？该模式最适合于当你想对一个稳定类结构的对象做许多不同的事情的情况。增加一种新的访问者而不需要改变类结构，这对于很大的类结构是尤其重要的。但是，只要你给类结构增加了一个子类，你就不得不更新你所有访问者类的接口以包含针对那个子类的Visit...操作
