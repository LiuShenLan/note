- [1. 引论](#1-引论)
	- [1.1 什么是操作系统](#11-什么是操作系统)
		- [1.1.1 作为扩展机器的操作系统](#111-作为扩展机器的操作系统)
		- [1.1.2 作为资源管理者的操作系统](#112-作为资源管理者的操作系统)
	- [1.3 计算机硬件介绍](#13-计算机硬件介绍)
		- [1.3.1 CPU](#131-cpu)
		- [1.3.2 存储器](#132-存储器)
		- [1.3.3 磁盘](#133-磁盘)
		- [1.3.4 I/O设备](#134-io设备)
		- [1.3.5 总线](#135-总线)
		- [1.3.6 启动计算机](#136-启动计算机)
	- [1.5 操作系统概念](#15-操作系统概念)
		- [1.5.1 进程](#151-进程)
		- [1.5.2 地址空间](#152-地址空间)
		- [1.5.3 文件](#153-文件)
	- [1.6 系统调用](#16-系统调用)
		- [1.6.2 用于文件管理的系统调用](#162-用于文件管理的系统调用)
	- [1.7 操作系统结构](#17-操作系统结构)
		- [1.7.1 单体系统](#171-单体系统)
		- [1.7.2 层次式系统](#172-层次式系统)
		- [1.7.3 微内核](#173-微内核)
		- [1.7.4 客户端-服务器模式](#174-客户端-服务器模式)
	- [1.12 小结](#112-小结)

# 1. 引论

用户与操作系统交互的程序,基于文本的通常称为shell,而基于图标的则称为图形用户界面(GUI),它们实际上并不是操作系统的一部分,尽管这些程序使用操作系统来完成工作

多数计算机有两种运行模式:内核态和用户态。软件中最基础的部分是操作系统,它运行在内核态(也称为管态、核心态)。在这个模式中,操作系统具有对所有硬件的完全访问权,可以执行机器能够运行的任何指令。软件的其余部分运行在用户态下。在用户态下,只使用了机器指令中的一个子集。特别地,那些会影响机器的控制或可进行I/O(输入/输出)操作的指令,在用户态中的程序里是禁止的。

用户接口程序(shell或者GUI)处于用户态程序中的最低层次,允许许用户运行其他程序,诸如Web浏览器、电子邮件阅读器或音乐播放器等。这些程序也大量使用操作系统。

操作系统运行在裸机之上,为所有其他软件提供基础的运行环境。

操作系统和普通软件(用户态)之间的主要区别是,如果用户不喜欢某个特定的电子邮件阅读器,他可以自由选择另一个,或者自已写一个,但是不能自行写一个属于操作系统一部分的时钟中断处理程序。这个程序由硬件保护,防止用户试图对其进行修改。

## 1.1 什么是操作系统

### 1.1.1 作为扩展机器的操作系统

抽象是管理复杂性的一个关键。好的抽象可以把一个几乎不可能管理的任务划分为两个可管理的部分。其第一部分是有关抽象的定义和实现,第二部分是随时用这些抽象解决问题。

操作系统的任务是创建好的抽象并实现和管理它所创建的抽象对象

### 1.1.2 作为资源管理者的操作系统

把操作系统看作向应用程序提供基本抽象的概念,是一种自顶向下的观点。按照另一种自底向上的观点,操作系统则用来管理一个复杂系统的各个部分。操作系统的任务是在相互竞争的程序之间有序地控制对处理器、存储器以及其他I/O接口设备的分配。

操作系统的主要任务是记录哪个程序在使用什么资源，对资源请求进行分配，评估使用代价，并且为不同的程序和用户调解互相冲突的资源请求。

资源管理包括用以下两种不同方式实现多路复用(共享)资源:在时间上复用和在空间上复用。

当一种资源在**时间上复用**时,不同的程序或用户轮流使用它。先是第一个获得资源的使用,然后下一个,以此类推。例如,若在系统中只有一个CPU,而多个程序需要在该CPU上运行,操作系统则首先把该CPU分配给某个程序,在它运行了足够长的时间之后,另一个程序得到CPU,然后是下一个,如此进行下去,最终,轮到第一个程序再次运行。至于资源是如何实现时间复用的(谁应该是下一个以及运行多长时间等)则是操作系统的任务。

另一类复用是**空间复用**。每个客户都得到资源的一部分,从而取代了客户排队。例如,通常在若干运行程序之间分割内存,这样每一个运行程序都可同时入驻内存(例如,为了轮流使用CPU)。假设有足够的内存可以存放多个程序,那么在内存中同时存放若干个程序的效率，比把所有内存都分给一个程序的效率要高得多,特别是,如果一个程序只需要整个内存的一小部分,结果更是这样。当然,如此的做法会引起公平、保护等问题,这有赖于操作系统解决它们。

## 1.3 计算机硬件介绍

一台简单的个人计算机可以抽象为CPU、内存以及I/O设备都由一条系统总线连接起来并通过总线与其他设备通信

### 1.3.1 CPU

CPU从内存中取出指令并执行之。在每个CPU基本周期中,首先从内存中取出指令,解码以确定其类型和操作数,接着执行之,然后取指、解码并执行下一条指令。按照这一方式，程序被执行完成。

由于用来访问内存以得到指令或数据的时间要比执行指令花费的时间长得多,因此,所有的CPU内都有一些用来保存关键变量和临时数据的寄存器。这样,通常在指令集中提供一些指令,用以将一个字从内存调入寄存器,以及将一个字从寄存器存入内存。其他的指令可以把来自寄存器、内存的操作数组合,或者用两者产生一个结果,如将两个字相加并把结果存在寄存器或内存中。

除了用来保存变量和临时结果的通用寄存器之外,多数计算机还有一些对程序员可见的专用寄存器。其中之一是**程序计数器**,它保存了将要取出的下一条指令的内存地址。在指令取出之后,程序计数器就被更新以便指向后继的指令。

另一个寄存器是**堆栈指针**,它指向内存中当前栈的顶端。该栈包含了每个执行过程的栈帧。一个过程的栈帧中保存了有关的输入参数、局部变量以及那些没有保存在寄存器中的临时变量。

当然还有**程序状态字(PSW)寄存器**。这个寄存器包含了条件码位(由比较指令设置)、CPU优先级、模式(用户态或内核态),以及各种其他控制位。用户程序通常读入整个PSW,但是,只对其中的少量字段写入。在系统调用和I/O中,PSW的作用很重要。

**流水线**：许多现代CPU具有同时取出多条指令的机制。例如,一个CPU可以有单独的取指单元、解码单元和执行单元,于是当它执行指令n时,还可以对指令n+1解码,并且读取指令n+2

**超标量CPU**：比流水线更先进的设计是超标量CPU。在这种设计中,有多个执行单元,例如,一个CPU用于整数算术运算,一个CPU用于浮点算术运算,一个CPU用于布尔运算。两个或更多的指令被同时取出、解码并装入暂存缓冲区中,直至它们执行完毕。只要有一个执行单元空闲,就检查保持缓冲区中是否还有可处理的指令,如果有,就把指令从缓冲区中移出并执行之。这种设计存在一种隐含的作用,即程序的指令经常不按顺序执行。在多数情况下,硬件负责保证这种运算的结果与顺序执行指令时的结果相同,但是,仍然有部分令人烦恼的复杂情形被强加给操作系统处理

**内核态、用户态**：通常,在PSW中有一个二进制位控制这两种模式。当在内核态运行时,CPU可以执行指令集中的每一条指令,并且使用硬件的每种功能。相反,用户程序在用户态下运行,仅允许执行整个指令集的一个子集和访问所有功能的一个子集。一般而言,在用户态中有关I/O和内存保护的所有指令是禁止的。当然,将PSW中的模式位设置成内核态也是禁止的。为了从操作系统中获得服务,用户程序必须使用系统调用(systemcall)以陷入内核并调用操作系统。TRAP指令把用户态切换成内核态,并启用操作系统。当有关工作完成之后,在系统调用后面的指令把控制权返回给用户程序。

**多线程/超线程**：多线程允许CPU保持两个不同的线程状态，然后在纳秒级的时间尺度内来回切换。

**GPU**：由成千上万个微核组成的处理器，擅长处理大量并行的简单计算，比如在图像应用中渲染多边形，不太能胜任串行任务，并且很难编程。

### 1.3.2 存储器

存储器系统的顶层是CPU中的**寄存器**。它们用与CPU相同的材料制成,所以和CPU一样快。显然,访问它们是没有时延的。

下一层是**高速缓存**,它多数由硬件控制。主存被分割成高速缓存行,其典型大小为64字节,地址0至63对应高速缓存行0,地址64至127对应高速缓存行1,以此类推。最常用的高速缓存行放置在CPU内部或者非常接近CPU的高速缓存中。当某个程序需要读一个存储字时,高速缓存硬件检查所需要的高速缓存行是否在高速缓存中。如果是,称为**高速缓存命中**,缓存满足了请求,就不需要通过总线把访问请求送往主存。高速缓存命中通常需要两个时钟周期。高速缓存未命中就必须访问内存,这要付出大量的时间代价。由于高速缓存的价格昂贵,所以其大小有限。

**缓存**在计算机科学的许多领域中起着重要的作用,并不仅仅是RAM的缓存行。只要存在大量的资源可以划分为小的部分,那么,这些资源中的某些部分就会比其他部分更频繁地得到使用,通常缓存的使用会带来性能上的改善。操作系统一直在使用缓存。

再往下一层是**主存**。这是存储器系统的主力。主存通常称为**随机访问存储器**(RandomAccessMemory,**RAM**)。过去有时称之为磁芯存储器,

除了主存之外,许多计算机已经在使用少量的**非易失性随机访问存储器**。它们与RAM不同,在电源切断之后,非易失性随机访问存储器并不丢失其内容。**只读存储器**(ReadOnlyMemory,**ROM**)在工厂中就被编程完毕,然后再也不能被修改。ROM速度快且便宜。在有些计算机中,用于启动计算机的引导加载模块就存放在ROM中。另外,一些I/O卡也采用ROM处理底层设备控制。

**EEPROM**(Electrically Erasable PROM,电可擦除可编程ROM)和**闪存**(flash memory)也是非易失性的,但是与ROM相反,它们可以擦除和重写。不过重写它们需要比写入RAM更高数量级的时间,所以它们的使用方式与ROM相同,而其与众不同的特点使它们有可能通过字段重写的方式纠正所保存程序中的错误。

还有一类存储器是**CMOS**,它是易失性的。许多计算机利用CMOS存储器保持当前时间和日期。CMOS存储器和递增时间的时钟电路由一块小电池驱动,所以,即使计算机没有上电,时间也仍然可以正确地更新。CMOS存储器还可以保存配置参数,如哪一个是启动磁盘等。

### 1.3.3 磁盘

信息写在磁盘的一系列同心圆上。在任意一个给定臂的位置,每个磁头可以读取一段环形区域,称为**磁道**。把一个给定臂的位置上的所有磁道合并起来,组成了一个**柱面**

**固态硬盘**(Solid State Disk, **SSD**)：数据是存储在存储器(闪存)中的。与磁盘唯一的相似之处就是它也存储了大量即使在电源关闭时也不会丢失的数据

**虚拟内存**：将程序放在磁盘上,而将主存作为一种缓存,用来保存最频繁使用的部分程序。这种机制需要快速地映像内存地址,以便把程序生成的地址转换为有关字节在RAM中的物理地址。这种映像由CPU中的一个称为存储器管理单元(Memory Management Unit,MMU)的部件来完成

**上下文切换**：在多道程序系统中，从一个程序切换到另一个程序。这时有必要对来自缓存的所有修改过的块进行写回磁盘操作，并修改MMU中的寄存器。但是这两种操作的代价很昂贵，多以应避免使用这些操作

### 1.3.4 I/O设备

I/O设备一般包括两个部分:设备控制器和设备本身。控制器是插在电路板上的一块芯片或一组芯片,这块电路板物理地控制设备。它从操作系统接收命令,例如,从设备读数据,并且完成数据的处理。控制器的任务是为操作系统提供一个简单的接口。

每类设备控制器都是不同的,所以,需要不同的软件进行控制。专门与控制器对话,发出命令并接收响应的软件,称为**设备驱动程序**。绝大多数设备驱动程序需要在内核态运行

要将设备驱动程序装入操作系统,有三个途径。第一个途径是将内核与设备驱动程序重新链接,然后重启动系统。许多UNIX系统以这种方式工作。第二个途径是在一个操作系统文件中设置一个入口,并通知该文件需要一个设备驱动程序,然后重启动系统。在系统启动时,操作系统去找寻所需的设备驱动程序并装载之。Windows就是以这种方式工作。第三种途径是,操作系统能够在运行时接受新的设备驱动程序并且立即将其安装好,无须重启动系统。这种方式采用得较少,但是正在变得普及起来。热插拔设备,诸如USB和IEEE1394设备都需要动态可装载设备驱动程序

I/O端口空间：每个设备控制器都有少量用于通信的寄存器，所有设备寄存器的集合构成了I/O端口空间

实现输入和输出的方式有三种。

* 在最简单的方式中,用户程序发出一个系统调用,内核将其翻译成一个对应设备驱动程序的过程调用。然后设备驱动程序启动I/O并在一个连续不断的循环中检查该设备,看该设备是否完成了工作(一般有一些二进制位用来指示设备仍在忙碌中)。当I/O结束后,设备驱动程序把数据送到指定的地方(若有此需要),并返回。然后操作系统将控制返回给调用者。这种方式称为**忙等待**,其缺点是要占据CPU,CPU一直轮询设备直到对应的I/O操作完成。

* 第二种方式是设备驱动程序启动设备并且让该设备在操作完成时发出一个中断。设备驱动程序在这个时刻返回。操作系统接着在需要时阻塞调用者并安排其他工作进行。当设备驱动程序检测到该设备的操作完毕时,它发出一个**中断**通知操作完成。

* 第三种方式是,为I/O使用一种特殊的**直接存储器访问**(Direct Memory Access,**DMA**)芯片,它可以控制在内存和某些控制器之间的位流,而无须持续的CPU干预。CPU对DMA芯片进行设置,说明需要传送的字节数、有关的设备和内存地址以及操作方向,接着启动DMA。当DMA芯片完成时,它引发一个中断,其处理方式如前所述。有关DMA和I/O硬件会在第5章中具体讨论。

### 1.3.5 总线

**共享总线架构**：多个设备使用一些相同的导线传输数据。因此当多个设备同时需要发送数据时，需要仲裁器决定哪个设备可以使用总线。

**并行总线架构**：通过多条导线发送数据的每一个字。

**串行总线架构**：通过一条被称为数据通路的链路传递集合了所有位的一条消息

**USB**用来将所有慢速I/O设备与计算机连接。USB是一种集中式总线，其根设备每1ms轮询一次I/O设备，看是否有信息收发

**即插即用**I/O系统：系统自动地收集有关I/O设备的信息,集中赋予中断级别和I/O地址,然后通知每块卡所使用的数值，这项工作与计算机的启动密切相关

### 1.3.6 启动计算机

在每台计算机上有一块双亲板(在政治因素影响到计算机产业之前,它们曾称为"母板")。在双亲板上有一个称为**基本输入输出系统**(Basic Input Output System,**BIOS**)的程序。在BIOS内有底层I/O软件,包括读键盘、写屏幕、进行磁盘I/O以及其他过程。现在这个程序存放在一块闪速RAM中,它是非易失性的,但是在发现BIOS中有错时可以通过操作系统对它进行更新。

在计算机启动时,BIOS开始运行。它首先检查所安装的RAM数量,键盘和其他基本设备是否已安装并正常响应。接着,它开始扫描PCIe和PCI总线并找出连在上面的所有设备。即插即用设备也被记录下来。如果现有的设备和系统上一次启动时的设备不同,则新的设备将被配置。

然后,BIOS通过尝试存储在CMOS存储器中的设备清单决定启动设备。用户可以在系统刚启动之后进入一个BIOS配置程序,对设备清单进行修改。典型地,如果存在CD-ROM(有时是USB),则系统试图从中启动;如果失败,系统将从硬盘启动。启动设备上的第一个扇区被读入内存并执行。这个扇区中包含一个对保存在启动扇区未尾的分区表检查的程序,以确定哪个分区是活动的。然后,从该分区读入第二个启动装载模块。来自活动分区的这个装载模块被读入操作系统,并启动之。

然后,操作系统询问BIOS,以获得配置信息。对于每种设备,系统检查对应的设备驱动程序是否存在。如果没有,系统要求用户插入含有该设备驱动程序的CD-ROM(由设备供应商提供)或者从网络上下载驱动程序。一旦有了全部的设备驱动程序,操作系统就将它们调入内核。然后初始化有关表格,创建需要的任何背景进程,并在每个终端上自动登录程序或GUI

## 1.5 操作系统概念

### 1.5.1 进程

**进程**本质上是正在执行的一个程序，与每个进程相关的是地址空间，这是从某个最小值的存储位置(通常是零)到某个最大值的存储位置的列表。在这个地址空间中,进程可以进行读写。该地址空间中存放有可执行程序、程序的数据以及程序的堆栈。与每个进程相关的还有资源集,通常包括寄存器(含有程序计数器和堆栈指针)、打开文件的清单、突出的报警、有关进程清单,以及运行该程序所需要的所有其他信息。进程基本上是容纳运行一个程序所需要所有信息的容器。

**进程表**：在许多操作系统中，与一个进程有关的所有信息，除了该进程自身地址空间的内容之外，均存放在操作系统的一张表中，称为进程表，进程表是数组(或链表)结构，当前存在的每个进程都要占用其中一项。

一个(挂起的)进程包括：进程的地址空间(又称磁芯映像)以及对应的进程表项(其中包括寄存器以及稍后重启该进程所需要的许多其他信息)

系统管理器授权每个进程使用一个给定的**UID**。每个被启动的进程都有一个启动该进程的用户UID。子进程拥有与父进程一样的UID。用户可以是某个组的成员,每个组也有一个**GID**

### 1.5.2 地址空间

**地址空间**：通常,每个进程有一些可以使用的地址集合,典型值从0开始直到某个最大值。在最简单的情形下,一个进程可拥有的最大地址空间小于主存。在这种方式下,进程可以用满其地址空间,而且内存中也有足够的空间容纳该进程。

**虚拟内存**：操作系统可以把部分地址空间装入主存,部分留在磁盘上,并且在需要时来回交换它们。在本质上,操作系统创建了一个地址空间的抽象,作为进程可以引用地址的集合。该地址空间与机器的物理内存解耦,可能大于也可能小于该物理空间。对地址空间和物理空间的管理组成了操作系统功能的一个重要部分

### 1.5.3 文件

进程和文件层次都可以组织成树状结构,但这两种树状结构有不少不同之处。一般进程的树状结构层次不深(很少超过三层),而文件树状结构的层次常常多达四层、五层或更多层。进程树层次结构是暂时的,通常最多存在几分钟,而目录层次则可能存在数年之久。进程和文件在所有权及保护方面也是有区别的。典型地,只有父进程能控制和访问子进程,而在文件和目录中通常存在一种机制,使文件所有者之外的其他用户也可以访问该文件

在读写文件之前，首先要打开文件，检查其访问权限。若权限许可,系统将返回一个小整数,称作**文件描述符**,供后续操作使用。若禁止访问,系统则返回一个错误码

**特殊文件**：提供特殊文件是为了使I/O设备看起来像文件一般。这样,就像使用系统调用读写文件一样,I/O设备也可通过同样的系统调用进行读写。

**块特殊文件**:指那些由可随机存取的块组成的设备,如磁盘等。比如打开一个块特殊文件,然后读第4块,程序可以直接访问设备的第4块而不必考虑存放该文件的文件系统结构。

**字符特殊文件**:用于打印机、调制解调器和其他接收或输出字符流的设备。按照惯例,特殊文件保存在/dev目录中。例如,/dev/lp是打印机(曾经称为行式打印机)。

**管道**：管道(pipe)是一种虚拟文件、它可连接两个进程。如果进程A和B希望通过管道对话,它们必须提前设置该管道。当进程A想对进程B发送数据时,它把数据写到管道上,仿佛管道就是输出文件一样。进程B可以通过读该管道而得到数据,仿佛该管道就是一个输入文件一样。这样,在UNIX中两个进程之间的通信就非常类似于普通文件的读写了。更为强大的是,若进程想发现它所写入的输出文件不是真正的文件而是管道,则需要使用特殊的系统调用。

## 1.6 系统调用

### 1.6.2 用于文件管理的系统调用

在UNIX中,每个文件都有唯一的编号,即i-编号,用以标识文件。该i-编号是对i-节点表格的一个引用,它们一一对应,说明该文件的拥有者、磁盘块的位置等。目录就是一个包含了(i-编号,ASCII名称)对集合的文件。

## 1.7 操作系统结构

### 1.7.1 单体系统

整个操作系统在内核态以单一程序的方式运行。整个操作系统以过程集合的方式编写,链接成一个大型可执行二进制程序。使用这种技术,系统中每个过程可以自由调用其他过程,只要后者提供了前者所需要的一些有用的计算工作。调用任何一个你所需要的过程或许会非常高效,但上千个可以不受限制地彼此调用的过程常常导致系统笨拙且难于理解。并且,任何一个过程的崩溃都会连累整个系统

### 1.7.2 层次式系统

层次式结构的操作系统，它的上层软件都是在下一层软件的基础上构建的

### 1.7.3 微内核

在微内核设计背后的思想是,为了实现高可靠性,将操作系统划分成小的、良好定义的模块,只有其中一个模块(微内核)运行在内核态,其余的模块由于功能相对弱些,则作为普通用户进程运行。特别地,由于把每个设备驱动和文件系统分别作为普通用户进程,这些模块中的错误虽然会使这些模块崩溃,但是不会使得整个系统死机

一个与微内核相关联的思想是内核中的**机制与策略**分离的原则。为了更清晰地说明这一点,我们考虑进程调度。一个比较简单的调度算法是,对每个进程赋予一个优先级,并让内核执行具有最高优先级的进程。这里,机制(在内核中)就是寻找最高优先级的进程并运行之。而策略(赋予进程优先级)可以由用户态中的进程完成。在这种方式中,机制和策略是分离的,从而使系统内核变得更小。

### 1.7.4 客户端-服务器模式

服务器：每个服务器提供某种服务；客户端：使用这些服务。通常在系统最底层是微内核，但这并不是必须的，客户端-服务器模式的本质是存在客户端进程和服务器进程

一般来说，客户端和服务器之间的通信是消息传递。为了获得一个服务,客户端进程构造一段消息,说明所需要的服务,并将其发给合适的服务器。该服务器完成工作,发送回应。如果客户端和服务器恰巧运行在同一个机器上,则有可能进行某种优化,但是从概念上看,这里讨论的是消息传递。

## 1.12 小结

考察操作系统有两种观点:资源管理观点和扩展的机器观点。在资源管理观点中,操作系统的任务是有效地管理系统的各个部分。在扩展的机器观点中,系统的任务是为用户提供比实际机器更便于运用的抽象。这些抽象包括进程、地址空间以及文件。

操作系统的历史很长,从操作系统开始替代操作人员的那天开始到现代多道程序系统,主要包括早期批处理系统、多道程序系统以及个人计算机系统。

由于操作系统同硬件的交互密切,掌握一些硬件知识对于理解它们是有益的。计算机由处理器、存储器以及I/O设备组成。这些部件通过总线连接。

所有操作系统构建所依赖的基本概念是进程、存储管理、I/O管理、文件管理和安全。这些内容都将在后续用一章来讲述。

任何操作系统的核心是它可处理的系统调用集。这些系统调用真实地说明了操作系统所做的工作。对于UNIX,我们已经考察了四组系统调用。第一组系统调用同进程的创建和终止有关;第二组用于读写文件;第三组用于目录管理;第四组包括各种杂项调用。

操作系统构建方式有多种。最常见的有单体系统、层次化系统、微内核系统、客户端-服务器系统、虚拟机系统和外核系统。
