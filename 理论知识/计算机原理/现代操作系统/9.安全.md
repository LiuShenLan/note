- [9. 安全](#9-安全)
	- [9.1 环境安全](#91-环境安全)
		- [9.1.1 威胁](#911-威胁)
	- [9.2 操作系统安全](#92-操作系统安全)
		- [9.2.1 可信系统](#921-可信系统)
		- [9.2.2 可信计算基](#922-可信计算基)
	- [9.3 保护机制](#93-保护机制)
		- [9.3.1 保护域](#931-保护域)
		- [9.3.2 访问控制列表](#932-访问控制列表)
		- [9.3.3 权能字](#933-权能字)
	- [9.4 安全系统的形式化模型](#94-安全系统的形式化模型)
		- [9.4.1 多级安全](#941-多级安全)
		- [9.4.2 隐蔽信道](#942-隐蔽信道)
	- [9.5 密码学原理](#95-密码学原理)
		- [9.5.1 私钥加密技术](#951-私钥加密技术)
		- [9.5.2 公钥加密技术](#952-公钥加密技术)
		- [9.5.3 单向函数](#953-单向函数)
		- [9.5.4 数字签名](#954-数字签名)
		- [9.5.5 可信平台模块](#955-可信平台模块)
	- [9.6 认证](#96-认证)
		- [9.6.1 使用物理识别的认证方式](#961-使用物理识别的认证方式)
		- [9.6.2 使用生物识别的认证方式](#962-使用生物识别的认证方式)
	- [9.7 软件漏洞](#97-软件漏洞)
		- [9.7.1 缓冲区溢出攻击](#971-缓冲区溢出攻击)
		- [9.7.2 格式化字符串攻击](#972-格式化字符串攻击)
		- [9.7.3 悬垂指针](#973-悬垂指针)
		- [9.7.4 空指针间接引用攻击](#974-空指针间接引用攻击)
		- [9.7.5 整数溢出攻击](#975-整数溢出攻击)
		- [9.7.6 命令注入攻击](#976-命令注入攻击)
		- [9.7.7 检查时间/使用时间攻击](#977-检查时间使用时间攻击)
	- [9.8 内部攻击](#98-内部攻击)
		- [9.8.1 逻辑炸弹](#981-逻辑炸弹)
		- [9.8.2 后门陷阱](#982-后门陷阱)
		- [9.8.3 登陆欺骗](#983-登陆欺骗)
	- [9.9 恶意软件](#99-恶意软件)
		- [9.9.1 特洛伊木马](#991-特洛伊木马)
		- [9.9.2 病毒](#992-病毒)
		- [9.9.3 蠕虫](#993-蠕虫)
		- [9.9.4 间谍软件](#994-间谍软件)
		- [9.9.5 rootkit](#995-rootkit)
	- [9.10 防御](#910-防御)
		- [9.10.1 防火墙](#9101-防火墙)
		- [9.10.2 反病毒和抑制反病毒技术](#9102-反病毒和抑制反病毒技术)
		- [9.10.3 代码签名](#9103-代码签名)
		- [9.10.4 囚禁](#9104-囚禁)
		- [9.10.5 基于模型的入侵检测](#9105-基于模型的入侵检测)
		- [9.10.6 封装移动代码](#9106-封装移动代码)
		- [9.10.7 Java安全性](#9107-java安全性)
	- [9.12 小结](#912-小结)

# 9. 安全

**漏洞**：操作系统和应用导致系统中出现的涉及到安全类别的错误

**漏洞攻击/漏洞利用**：发现软件中存在漏洞时，通过向软件输入特定的字节来触发错误，像这种触发错误的输入通常叫做漏洞攻击或漏洞利用

## 9.1 环境安全

**安全**：表示所有的基本问题，如技术、管理、法律和政治方面的问题，也包括使用特定的操作系统机制来提供安全保障的问题

**防护机制**：表示用特定的操作系统机制确保计算机信息安全

安全与防护机制之间的界限没有严格定义

### 9.1.1 威胁

* 信息系统的安全分解为三个部分：机密性、完整性和可用性

	* **机密性**：将机密的数据置于保密状态。更确切地说，如果数据所有者决定这些数据仅用于特定的人，那么系统就应该保证数据绝对不会发布给未经授权的人。数据所有者至少应该有能力指定谁可以阅读哪些信息，而系统则对用户的选择进行强制执行,这种执行的粒度应该精确到文件。威胁为数据暴露

	* **完整性**：未经授权的用户没有得到许可就擅自改动数据。这里所说的改动不仅是指改变数据的值，而且还包括删除数据以及添加错误的数据等情况。如果系统在数据所有者决定改动数据之前不能保证其原封未动，那么这样的安全系统就毫无价值可言。维系额为数据篡改

	* **可用性**没有人可以扰乱系统使之瘫痪。导致系统拒绝服务的攻击十分普遍，许多合理的系统模型和技术能够保证数据的机密性和完整性,但是避免拒绝服务却相当困难。威胁为拒绝服务

**双重用途**：工具对攻击者和防御者都是有用的

大部分网络上的犯罪活动都是基于**僵尸网络**建立的，它包含成千上万(有时候是上百万)受到危害的电脑。当电脑完全被攻击者所控制的时候，它就会被称为机器人或者僵尸。特别是，这些对用户来说都是不可见的

安全问题的另一个与保密性相关的重要方面是**隐私**，即保证私人的信息不被滥用

## 9.2 操作系统安全

本书只关注涉及操作系统的攻击。换句话说，将不会涉及网络攻击或针对SQL数据库的攻击。相反关注的是以操作系统为攻击目标，或是在安全策略执行中操作系统起到重要作用(或更常见的是未能起到作用)的攻击行为

一般将攻击分为被动攻击与主动攻击。**被动攻击**视图窃取信息，而**主动攻击**会使计算机程序行为异常

**加密**是将一个消息或者文件进行转码，除非获得秘钥，否则很难恢复出原信息；**程序加固**是指在程序中加入保护机制从而使得攻击者很难破坏程序

### 9.2.1 可信系统

难以建立安全的系统的原因：1.现代系统虽然不安全但是用户不愿抛弃他们；2.现在已知的建立安全系统仅有的办法是保持系统的简单性

### 9.2.2 可信计算基

在安全领域中，人们通常讨论**可信系统**而不是安全系统。这些系统在形式上申明了安全要求并满足了这些安全要求。每一个可信系统的核心是最小的**可信计算基(TCB)**，其中包含了实施所有安全规则所必需的硬件和软件。如果这些可信计算基根据系统规约工作，那么，无论发生了什么错误,系统安全性都不会受到威胁

典型的TCB包括了大多数的硬件(除了不影响安全性的I/O设备)、操作系统核心中的一部分、大多数或所有掌握超级用户权限的用户程序等。必须包含在TCB中的操作系统功能有：进程创建、进程切换、内存面管理以及部分的文件和I/O管理。在安全设计中，为了减少空间以及纠正错误，TCB通常完全独立于操作系统的其他部分

TCB中的一个重要组成部分是**访问监视器**。访问监视器接受所有与安全有关的系统请求，然后决定是否允许运行，即所有系统调用都要通过访问监视器进行安全检查。访问监视器要求所有的安全问题决策都必须在同一处考虑，而不能跳过

## 9.3 保护机制

### 9.3.1 保护域

**域**是(对象，权限)对的集合。每一对组合指定一个对象和一些可在其上运行的操作子集。这里权限是指对某个操作的执行许可。通常域相当于单个用户，告诉用户可以做什么不可以做什么，当然有时域的范围比用户要更广

对象如何分配给域由需求来确定，一个最基本的原则就是**最低权限原则(POLA)**，一般而言，当每个域都拥有最少数量的对象和满足其完成工作所需的最低权限时，安全性将达到最好

任何时间，每个进程会在某个保护域中运行。换句话说，进程可以访问某些对象的集合，每个对象都有一个权限集。进程运行时也可以在不同的域之间切换。域切换的规则很大程度上与系统有关

在UNIX中，进程的域是由UID和GID定义的。给定某个(UID,GID)的组合，就能够得到可以访问的所有对象列表(文件，包括由特殊文件代表的IO设备等)，以及它们是否可以读、写或执行。使用相同(UID,GID)组合的两个进程访问的是完全一致的对象集合。使用不同(UID,GID)值的进程访问的是不同的文件集合,虽然这些文件有大量的重叠。而且每个UNIX的进程有两个部分:用户部分和核心部分。当执行系统调用时，进程从用户部分切换到核心部分。核心部分可以访问与用户部分不同的对象集。例如核心部分可以访问所有物理内存的页面、整个磁盘和其他所有被保护的资源。这样，系统调用就引发了域切换

### 9.3.2 访问控制列表

一个问题就是系统如何跟踪并确定哪个对象属于哪个域。从概念来说可以使用一个保护矩阵，矩阵的行代表域，列代表对象。每个矩阵元素列出对象的域中包含的或可能有的权限。因为矩阵过大、过于稀疏，大多数的域都不能访问大多数的对象，所以存储一个维度极大却很稀疏的矩阵浪费空间。但是也有两种方法是可行的，分别是按行或按列存放，并且仅仅存放非空的元素。这两种方法有着很大的不同。本节介绍按列存放的方法，下一节介绍按行存储的方法

**访问控制列表(ACL)**：一个关联于每个对象的(有序)列表，列表里包含了所有可访问对象的域以及这些域如何访问访问这些对象的方法

许多系统也支持**组**的概念。组可以有自己的名字并包含在ACL中。在某些系统中，每个进程除了有用户ID(UID)之外，还有组ID(GID)。使用组的方法就引入了**角色**的概念。只有当用户与组都符合ACL要求时才可以访问改文件

在有些情况下，用户可以访问特定的文件而与当前登录的组无关。这样的情况将引入**通配符**的概念，即"任何组"的意思。如,表项`tana, *: RW`会给Tana访问的权限而不管她的当前组是什么

但是另一种可能是如果用户属于任何一个享有特定权限的组，访问就被允许。这种方法的优点是,属于多个组的用户不必在登录时指定组的名称，所有的组都被计算在内。同时它的缺点是几乎没有提供封装性

组和通配符的使用使得系统有可能有选择地阻止用户访问某个文件。如表项`virgil, *: (none); *，*: RW`给Virgil之外的所有用户以读写文件的权限。上述方法是可行的，因为表项是按顺序扫描的，只要第一个被采用，后续的表项就不需要再检查。在第一个表项为Virgil找到了匹配，然后找到并应用这个存取权限,在本例中为(none)。整个查找在这时就中断了。实际上再也不去检查剩下的访问权限了

### 9.3.3 权能字

**权能字列表(C-list)**：与每个进程关联的是可访问的对象列表，以及每个对象上可执行操作的指示。而且每个单独的项目叫做**权能字**

每一个权能字赋予所有者针对特定对象的权限。一个权能字通常包含了文件(或者更一般的情况下是对象)的标识符和用于不同权限的位图。在类似UNIX的系统中，文件标识符可能是i节点号。权能字列表本身也是对象，也可以从其他权能字列表处指定,这样就有助于共享子域。

很明显权能字列表必须防止用户篡改。已知的保护方法有三种。1.建立带标记的体系结构，在这种硬件设计中，每个内存字必须拥有额外的(或标记)位来判断该字是否包含了权限字。标记位不能被算术、比较或相似的指令使用，它仅可以被在核心态下运行(即操作系统)的程序修改；2.在操作系统里保存权能字列表。随后根据权能字在列表中的位置引用权能字。这种寻址方法有些类似UNIX里的文件描述符；3.把权能字列表放在用户空间里，并用加密方法进行管理，这样用户就不能篡改它们。这种方法特别适合分布式操作系统

除了特定的与对象相关的权限(如读和执行操作)外，权能字中(包括在核心态和密码保护模式下)通常包含一些可用于所有对象的普通权限。这些普通权限有：1.复制权能字:为同一个对象创建新的权能字；2.复制对象:用新的权能字创建对象的副本；3.移除权能字:从权能字列表中删去表项;不影响对象；4.销毁对象:永久性地移除对象和权能字

权能字存在的问题：1.在核心管理的权能字系统中，撤回对对象的访问是十分困难的。系统很难为任意对象找到它所有显著的权能字并撤回，因为它们存储在磁盘各处的权能字列表中。一种办法是把每个权能字指向间接对象而不是对象本身，再把间接对象指向真正的对象，这样系统就能打断连接关系使权能字无效(当指向间接对象的权能字后来出现在系统中时，用户将发现间接对象指向的是一个空的对象)。另一种方法是改变存放在对象里的校验字段。只要改变一次就可以使所有的失效。但是没有一种机制可以有选择性地撤回权能字。这一缺陷也被认为是权能字系统的一个主要问题。2.确保合法权能字的拥有者不会给其他用户副本。采用核心管理权能字的模式这个问题得到解决。但在如Amoeba这样的分布式系统中却无法解决这个问题

ACL和权能字具有一些彼此互补的特性：1.权能字相对来说效率较高，因为进程在要求"打开由权能字3所指向的文件"时无须任何检查;而采用ACL时需要进行搜索操作(时间可能很长)，如果系统不支持用户组的话，赋予每个用户读文件的权限就需要在ACL中列举所有的用户；2.权能字还可以十分容易地封装进程;而ACL却不能；3.ACL支持有选择地撤回权限;而权能字不行；4.使用权能字时如果对象被删除时权能字未被删除，或者权能字被删除时对象未被删除，问题就会发生;而ACL不会产生这样的问题

## 9.4 安全系统的形式化模型

**保护命令**：在保护矩阵上确定的六种最基本的操作，这些操作可用作任何安全模型的基准。最基本的操作是create object、delete object、create domain、delete domain、insert right和remove right。最后的两种插入和删除权限操作来自于特定的矩阵单元，如赋予域1读文件3的许可权

所有可能的矩阵被划分为两个独立的集合:所有处于授权状态的集合和所有未授权的集合。大量理论研究提出这样一个问题:给定一个初始的授权状态和命令集，是否能证明系统永远不能达到未授权的状态?即可行的安全机制(保护命令)是否足以强制某些安全策略。给定了这些安全策略、最初的矩阵状态和改变这些矩阵的命令集，我们希望可以找到建立安全系统的方法

### 9.4.1 多级安全

**可自由支配的访问控制**：操作系统允许个人用户来决定谁可以读写他们的文件和其他对象

**强制性的访问控制**：安全策略被系统强制执行，而不是可自由支配的访问控制。这些强制性的访问控制管理整个信息流，确保不会泄漏那些不应该泄漏的信息

1. **Bell-LaPadula模型**：

最广泛使用的多级安全模型。代表用户运行的进程具有该用户的安全等级。由于该系统拥有多个安全等级，所以被称为**多级安全系统**

规定：1.**简易安全规则**:在密级k上面运行的进程只能读取同一密级或更低密级的对象；2.**规则**:在密级k上面运行的进程只能写同一密级或更高密级的对象。简而言之，进程既可下读也可上写，但不能颠倒。如果系统严格地执行上述两条规则，那么就不会有信息从高一级的安全层泄露到低一级的安全层。在这一模型中，进程可以读写对象，但不能直接相互通信

缺点：可以用来保守秘密，但不能保证数据的完整性。要保证数据的完整性，需要更精确的逆向特性

2. **Biba模型**：

规则：1.**简单完整性规则**：在安全等级k上运行的进程只能写同一等级或更低等级的对象(没有往上写)；2.**完整性规则**：在安全等级k上运行的进程只能读同一等级或更高等级的对象(不能向下读)

该模型的规则联合在一起确保了中间安全等级的进程可以根据高安全等级的进程的要求更新低安全等级的进程的信息，但反过来不可以。Bell-LaPadula模型与Biba模型是矛盾的，很难同时满足

### 9.4.2 隐蔽信道

**Lampson模型**：该模型包含了三个运行在保护机器上的进程。第一个进程是客户机进程，它让某些工作通过第二个进程也就是服务器进程来完成。客户机进程和服务器进程不完全相互信任。例如客户机会担心服务器秘密地记录下客户机的数据，服务器会担心客户机试图窃取有价值的软件。第三个进程是协作程序，该协作程序正在同服务器合作来窃取客户机的机密数据。协作程序和服务器显然是由同一个人掌握的。这一例子的目标是设计出一种系统，在该系统内服务器进程不能把从客户机进程合法获得的信息泄露给协作进程，这一问题叫作**界限问题**

**隐蔽信道**：一种允许进程以违背系统安全策略的形式传送信息的通信通道

隐蔽信道的例子如：调节CPU的使用率(进程在固定的时间段内竭尽所能执行计算操作表示1，进程在同样长的时间段内睡眠表示0，协作程序通过仔细地监控相应时间来检测位流，一般而言当服务器送出0时的相应比送出1时的相应要好一些)；调制页率(多个页面错误表示1，没有页面错误表示0)；在一个计时方式里，几乎任何可以降低系统性能的途径都可能是隐蔽信道的候选；使用锁定文件的方式(锁定文件表示1，解锁文件表示0)；获取和释放特定的资源(磁带机、绘图仪等)(服务器进程获取资源时发送1，释放资源时发送0)；在UNIX里，服务器进程创建文件表示为1，删除文件表示为0；

隐蔽信道同时也是嘈杂的信道，包含了大量的外来信息。但是通过纠错码(如汉明码或者更复杂的代码)可以在这样嘈杂的信道中可靠地传递信息。纠错码的使用使得带宽已经很低的隐蔽信道变得更窄，但仍有可能泄露真实的信息。很明显，没有一种基于对象矩阵和域的保护模式可以防止这种泄露

**隐写术**：稍微不同的能够在进程间传递机密信息的隐蔽信道。在RGB图片中插入信息：原来的彩色图片每个像素包括三个8位数字，分别代表红、绿、蓝三原色的亮度。像素的颜色是通过三原色的线性重叠形成的。编码程序使用每个RGB色度的低位作为隐蔽信道。这样每个像素就有三位的秘密空间存放信息，一个在红色色值里，一个在绿色色值里,一个在蓝色色值里。这种情况下，图片大小将增加w×h×3位字节的空间来存放信息；另一个使用是把隐藏的水印插入网页上的图片中以防止窃取者用在其他的网页上

## 9.5 密码学原理

**加密目的**：将**明文**(原始信息或文件)通过某种手段变为**密文**，通过这种手段，只有经过授权的人才知道如何将密文恢复为明文。对无关的人来说，密文是一段无法理解的编码。加密和解密算法(函数）往往是公开的。要想确保加密算法不被泄露是徒劳的，否则就会使一些想要保密数据的人对系统的安全性产生错误理解。在专业上，这种策略叫作**模糊安全**，而且只有安全领域的爱好者们才使用该策略

**加密定义**：在算法中使用的加密参数叫做**密钥**。$C=E(P,K_E)$。P代表明文，$K_E$代表加密密钥，C代表密文，E代表加密算法(即函数)，其含义是把明文P和加密密钥$K_C$作为参数，通过加密算法E就可以把明文变为密文

**Kerckhoffs原则**：加密算法本身应该完全公开，而加密的安全性由独立于加密算法之外的密钥决定

**解密定义**：$P=D(C,K_D)$。P代表明文，$K_D$代表解密密钥，C代表密文，D代表解密算法(即函数)，其含义是把密文C和解密密钥$K_D$作为参数，通过解密算法D就可以把密文变为明文

### 9.5.1 私钥加密技术

**单字母替换**：加密算法里每一个字母都由另一个不同的字母替代，26个字母与整个字母表相匹配

许多类似的密钥系统都有这样一个特点，那就是给定了加密密钥就能够较为容易地找到解密密钥,反之亦然。这样的系统采用了**私钥加密技术**或**对称密钥加密技术**。虽然单字母替换方式没有使用价值,但是如果密钥有足够的长度，对称密钥机制还是相对比较安全的。对严格的安全系统来说，最少需要使用256位密钥，因为它的破译空间为$2^{256}\approx1.2\times10^{77}$

优点：对信息进行加密和解密的运算量是可控制的

缺点：发送者与接受者必须同时拥有密钥

### 9.5.2 公钥加密技术

**公钥加密技术**：

特点：加密密钥和解密密钥是不同的，并且当给出了一个筛选过的加密密钥后不可能推出对应的解密密钥。在这种特性下，加密密钥可被公开而只有解密密钥处于秘密状态

虽然平方和求平方根互为逆运算，但是它们在计算的复杂性上却有很大差异。这种不对称性构成了公钥密码体系的基础。在公钥密码体系中，加密运算比较简单，而没有密钥的解密运算却十分繁琐

**RSA**公钥机制表明:对计算机来说，大数乘法比对大数进行因式分解要容易得多，特别是在使用取模算法进行运算且每个数字都有上百位时。这种机制广泛应用于密码领域，其他广泛使用的还有离散对数。公钥机制的主要问题在于运算速度要比对称密钥机制慢数千倍

当我们使用公钥密码体系时，每个人都拥有一对密钥(公钥和私钥)并把其中的公钥公开。公钥是加密密钥,私钥是解密密钥。通常密钥的运算是自动进行的，有时候用户可以自选密码作为算法的种子。在发送机密信息时，用接收方的公钥将明文加密。由于只有接收方拥有私钥，所以也只有接收方可以解密信息

### 9.5.3 单向函数

**加密散列函数**：函数f其特性是给定f和参数x，很容易计算出y=f(x)。但是给定y=f(x)，要找到相应的x却不可行。这种函数采用了十分复杂的方法把数字打乱。具体做法可以首先将y初始化为x。然后可以有一个循环，进行多次迭代，只要在x中有1位就继续迭代，随着每次迭代,y中的各位的排列以与迭代相关的方式进行，每次迭代时添加不同的常数，最终生成了彻底打乱位的数字排列

### 9.5.4 数字签名

1. 对文档运行一种**单向散列运算(hashing)**，这种运算几乎是不可逆的。散列函数通常独立于原始文档长度产生一个固定长度的结果值。最常用的散列函数有MD5(一种可以产生16个字节结果的算法)以及SHA-1(一种可以产生20个字节结果的算法),比SHA-1更新版本有SHA-256(产生32字节结果的算法)和SHA-512(产生64字节的散列结果的算法)，但是迄今为止,这两种加密算法依然没有得到广泛使用

2. 使用上面讲过的公钥密码。文件所有者利用他的私钥对散列值进行运算得到D(散列值)。该值称为**签名块**，它被附加在文档之后传送给接收方。对散列值应用D有些像散列解密，但这并不是真正意义上的解密，因为散列值并没有被加密。这不过是对散列值进行的数学变换

3. 接收方收到文档和散列值后，首先使用事先取得一致的MD5或SHA算法计算文档的散列值，然后接收方使用发送方的公钥对签名块进行运算以得到E(D(hash))。这实际上是对解密后的散列进行"加密",操作抵消，以恢复原有的散列。如果计算后的散列值与签名块中的散列值不一致，则表明文档和签名块中的一个或两者同时被篡改过。这种方法仅仅对一小部分数据(散列)运用了(慢速的)公钥密码体制。请注意这种方法仅仅对所有满足下面条件的x起作用:`E(D(X))=X`。我们并不能保证所有的加密函数都拥有这种属性,因为我们原来所要求的就是:`D(E(X))=X`。在这里，E是加密函数,D是解密函数。而为了满足签名的要求,函数运算的次序是不受影响的。也就是说，D和E一定是可交换的函数。而RSA算法就有这种属性

要使用这种签名机制，接收方必须知道发送方的公钥。消息发送方为了安全的发送公钥，一种常用方法是在消息后附加**数字证书**，证书中包含了用户姓名、公钥和可信任的第三方数字签名。一旦用户获得了可信的第三方认证的公钥，那么对于所有使用这种可信第三方确认来生成自己证书的发送方，该用户都可以使用他们的证书

**认证机构(CA**)作为可信的第三方，提供签名证书。然而如果用户要验证有CA签名的证书，就必须得到CA的公钥，从哪里得到这个公钥?即使得到了用户又如何确定这的确是CA的公钥呢?为了解决上述两个问题，需要一套完整的机制来管理公钥，这套机制叫作**PKI(公钥基础设施)**。网络浏览器已经通过一种特别的方式解决了这个问题:所有的浏览器都预加载了大约40个著名CA的公钥

上面叙述了可用于数字证书的公钥密码体制。同时也有必要指出不包含公钥体制的密码体系同样存在

### 9.5.5 可信平台模块

加密算法都需要密钥。如果密钥泄露了，所有基于该密钥的信息也等同于泄露了，可见选择一种安全的方法存储密钥是必要的。接下来的问题是:如何在不安全的系统中安全地保存密钥呢?

有一种方法在工业上已经被采用，该方法需要用到一种叫作**可信平台模块(TPM**)的芯片。TPM是一种加密处理器，使用内部的非易失性存储介质来保存密钥。该芯片用硬件实现数据的加密/解密操作，其效果与在内存中对明文块进行加密或对密文块进行解密的效果相同，TPM同时还可以验证数字签名。由于其所有的操作都是通过硬件实现，因此速度比用软件实现快许多，也更可能被广泛地应用

一种有趣的TPM使用方式是**远程认证**。远程认证允许外部第三方使用TPM进行计算机认证，并执行其应该执行的软件，整个过程全部可信。这个想法是证明方使用TPM创建名为measurements的保护配置信息的哈希表

## 9.6 认证

当人们试图登录系统时，大多数用户登录的方法基于下列三个方面考虑：1.用户已知的信息；2.用户已有的信息；3.用户是谁。有些时候为了达到更高的安全性，需要同时满足上面的两个方面。这些方面导致了不同的认证方案,它们具有不同的复杂性和安全性

最广泛使用的认证方式是要求用户输入登录名和密码。密码保护很容易理解，也很容易实施。最简单的实现方法是保存一张包含登录名和密码的列表。登录时通过查找登录名，得到相应的密码并与输入的密码进行比较。如果匹配，则允许登录，如果不匹配，登录被拒绝

1. UNIX密码安全性

有些(老式的)操作系统将密码文件以未加密的形式存放在磁盘里，由一般的系统保护机制进行保护。在早期版本的UNIX系统里有一个较好的做法。当用户登录时，登录程序首先询问登录名和密码。输入的密码被即刻"加密"，这是通过将其作为密钥对某段数据加密完成的:运行一个有效的单向函数，运行时将密码作为输入，运行结果作为输出。这一过程并不是真的加密，但人们很容易把它叫作加密。然后登录程序读入加密文件，也就是一系列ASCII代码行,每个登录用户一行,直到找出包含登录名的那一行。如果这行内(被加密后的)的密码与刚刚计算出来的输入密码匹配，就允许登录，否则就拒绝。这种方法的最大好处是任何人(甚至是超级用户）都无法查看任何用户的密码，因为密码文件并不是以未加密方式在系统中任意存放的。从阐述的角度上来看，操作系统的密码被保存在密码文件中。UNIX的现代版本已经不再使用这种方式

对计算机进行攻击时可以提前使用公开的算法对常见的密码进行加密，然后与系统中存放的加密后的密码文件进行对比。为了应对这种攻击，将每一个密码同一个叫做**盐(salt**)的n位随机数相关联。无论何时只要密码改变，随机数就改变。随机数以未加密的方式存放在密码文件中,这样每个人都可以读。不再只保存加密过的密码,而是先将密码和随机数连接起来然后一同加密。加密后的结果存放进密码文件。一个密码文件里有多个用户，每一个用户在文件里分别占一行,用逗号分解为3个条目:登录名、盐和(密码+盐)的加密结果。这样进行攻击时如果要提前对常见密码进行加密计算后对比，则增加了$2^n$倍的工作量。在UNIX系统中该方法里n=12

对附加的安全功能来说，有些UNIX的现代版通常将加密密码存储在单独的"shadow"文件中，与密码文件不同，它只能由root读取。对密码文件采用"加盐"的方法以及使之不可读(除非间接和缓慢地读)，可以抵挡大多数的外部攻击

2. 一次性密码

**一次性密码**：每次登陆换一次密码

**单项散列链**：该算法算法基于单向函数，即y=f(x)。给定x我们很容易计算出y,但是给定y却很难计算出x。输入和输入必须是相同的长度,如256位。用户选取一个他可以记住的保密密码。该用户还要选择一个整数n，该整数确定了算法所能够生成的一次性密码的数量。如果，考虑n=4，当然实际上所使用的n值要大得多。如果保密密码为s，那么通过单向函数计算n次得到的密码为：$P_1=f(f(f(f(s))))$；第2个密码用单向函数运算n-1次：$P_2=f(f(f(s)))$；第3个密码对f运算2次,第4个运算1次。总之$P_{i-1}=f(P_i)$。要注意的地方是，给定任何序列里的密码,我们很容易计算出密码序列里的前一个值,但却不可能计算出后一个值。如给定$P_2$很容易计算出$P_1$，但不可能计算出$P_3$

3. 挑战-相应认证

用户事先选择密钥k,并手工放置到服务器中。密钥的备份也被安全地存放在用户的计算机里。在登录时，服务器把随机产生的数r发送到用户端，由用户端计算出f(r,k)的值。其中，f是一个公开已知的函数。然后服务器也做同样的运算看看结果是否一致。这种方法的优点是即使窃听者看到并记录下双方通信的信息，也对他毫无用处。当然，函数f需要足够复杂，以保证k不能被逆推。加密散列函数是不错的选择，r与k的异或值(XOR)作为该函数的一个参数。迄今为止，这样的函数仍然被认为是难以逆推的

### 9.6.1 使用物理识别的认证方式

用户认证的第二种方式是验证一些用户所拥有的实际物体而不是用户所知道的信息,载有信息的磁卡有两种:磁条卡和芯片卡

* **磁条卡**：后面粘附的磁条上可以写入存放140个字节的信息。这些信息可以被终端读出并发送到主机。一般这些信息包括用户密码(如PIN代码）这样终端即便在与银行主机通信断开的情况下也可以校验。通常用只有银行已知的密钥对密码进行加密。在鉴别用户方面，磁条卡有一定的风险。因为读写卡的设备比较便宜并被大量使用着。

* **芯片卡**：在卡片上包含了小型集成电路。这种卡又可以被进一步分为两类:储值卡和智能卡

	* **储值卡**：包含了一定数量的存贮单元(通常小于1KB)，它使用ROM技术保证数据在断电和离开读写设备后也能够保持记忆。不过在卡片上没有CPU，所以被存储的信息只有外部的CPU(读卡器中)才能改变

	* **智能卡**：通常使用4MHz 8位CPU,,16KB ROM, 4KB ROM,512B可擦写RAM以及9600b/s与读卡器之间的通信速率。这类卡制作越来越小巧，但各种参数却不尽相同。智能卡可以使用不同的验证机制。一个简单的挑战-响应的例子是这样的：首先服务器向智能卡发出512位随机数，智能卡接着将随机数加上存储在卡上EEPROM中的512位用户密码。然后对所得的和进行平方运算，并且把中间的512位数字发送回服务器，这样服务器就知道了用户的密码并且可以计算出该结果值正确与否。如果窃听者看到了双方的信息，他也无从采用,即便记录下来今后也没有用处，因为下一次登录时，服务器会发出另一个512位的随机数。当然，我们可以使用更加新的算法而不是简单的平方运算。任何固定的密码通信协议的缺点是容易在传输过程中损坏，从而使智能卡丧失功能。避免这种情况的一个办法是在卡片里使用ROM而不是密码通信协议，如Java解释程序。然后将用Java二进制语言写成的通信协议下载到卡片中，并解释运行。通过这种方法，即使协议被损坏，也能够在全球范围内方便地下载一个新的协议，使得下一次使用智能卡时，该协议处于完好的状态。这种方法的缺点是让本来就速度慢的智能卡更慢了，但是随着技术的发展这种方法将被广泛使用。智能卡的另一个缺点是丢失或被盗的卡片可以让不法分子实施**旁道攻击**，例如功率分析攻击。他们中的专家通过观察智能卡在执行加密操作时的电源功率损耗，可以运用适当的设备推算出密钥。也可以让智能卡对特定的密钥进行加密操作，从加密的时间来推算出卡片密钥的有关信息

### 9.6.2 使用生物识别的认证方式

**生物识别**：对用户的某些物理特征进行验证，并且这些特征很难伪造

一个典型的生物识别系统由两部分组成:注册部分和识别部分

在注册部分中，用户的特征被数字化储存，并把最重要的识别信息抽取后存放在用户记录中。存放方式可以是中心数据库(如用于远程计算机登录的数据库)或用户随身携带的智能卡并在识别时插入远程读卡器(如ATM机)

另一个部分是识别部分。在使用时，首先由用户输入登录名，然后系统进行识别。如果识别到的信息与注册时的样本信息相同，则允许登录，否则就拒绝登录。这时仍然需要使用登录名，因为仅仅根据检测到的识别信息来判断是不严格的，只有识别部分的信息会增加对识别信息的排序和检索难度。也许某两个人会具有相同的生物特征，所以要求生物特征还要匹配特定用户身份的安全性比只要求匹配一般用户的生物特征要强得多

被选用的识别特征必须有足够的可变性，这样系统可以准确无误地区分大量的用户。而且被选用的特征不应该经常发生变化。并且样本信息永远也不会与以后识别到的信息完全符合，那么系统设计人员就要决定识别的精度有多大

## 9.7 软件漏洞

入侵用户计算机的主要方法之一是利用系统中所运行的软件的漏洞，使其做一些违背程序员本意的事情

### 9.7.1 缓冲区溢出攻击

C和C++的编译器都没有数组边界检查

攻击者可以提供一个准备好的输入，使读取的数据从缓冲区溢出之后覆盖函数的返回地址，这样程序就会跳转到攻击者的用机器指令填充好的缓冲区，并在原始程序的上下文执行攻击代码。通常情况下，攻击者代码用于启动壳(例如通过exec系统调用)，使入侵者可以方便地访问机器。因此这样的代码就是俗称的**shellcode**,即使它不产生壳

如果攻击者不知道准确的返回地址,通常攻击者能够大约猜到shel1code的位置，但是并不准确。在这样的条件下，一种典型的方法是用预先设置好的**空指令滑行区**来增加漏洞被成功利用的可能性："一系列一字节的无操作的指令"移动到"预先设置好的空指令滑行区"后边。只要代码执行到这个空指令滑行区的某处，shellcode最终都会运行。空指令滑行区在栈中运行，也在堆中运行。在堆中，攻击者通常通过在堆中放置空指令滑行区和shellcode来提高成功率。举个例子，在浏览器中恶意的JavaScript代码会分配尽可能多的内存，并且用很长的空指令滑行区和少量的shellcode来填充它。然后如果攻击者设法转移控制流到一个随机的堆地址，他就有可能命中空指令滑行区的地址。这种技术被称为**堆喷射**。只要攻击者能够改变函数指针的值或返回地址到包含攻击者代码的缓存区，他就能改变程序的控制流

1. **栈金丝雀保护**

一种常用的防御上述攻击的方法，现代计算机系统仍然使用(数字)金丝雀作为早期的报警系统。在程序调用函数的地方，编译器在栈中插入代码来保存一个随机的金丝雀值，就在返回地址之下。从调用返回时，编译器插入代码来检测这个金丝雀值，如果这个值变了，就是出错了。在这样的情况下，最好是停止运行并处理故障而不是继续运行程序。栈金丝雀可以通过多次复制数据或者修改复制数据起始位置等被跳过而不被修改

2. **数据执行保护(DEP)**

如果攻击者提供的字节不能作为合法代码来执行，**代码注入攻击**就会失效。现代CPU有一个被称为**NX位**的功能，NX代表不执行。它对区分数据段(堆、栈、变量和全局变量)和文本段(包含代码)是非常有用的。具体来说，许多现代操作系统试图确保数据段是可写的,但不可执行，并且文本段是可执行的，但不可写。这个策略在OpenBSD上被称为**W^X**。它表示内存是可写的或可执行的，但不是两者都可以。Mac OS X,Linux和Windows有类似的保护方案。该安全措施的通用名称是DEP。有些硬件不支持NX位，在这种情况下，DEP仍然工作，但执行发生在软件中。DEP可以防止迄今为止讨论的所有攻击。攻击者可以在进程中嵌入尽可能多的shellcode。然而除非他能够使内存可执行,否则就没有办法运行它们

3. **代码重用攻击**

**返回lib攻击**：几乎所有的C程序都链接libc库，这个库包含大部分C程序所需的关键函数。system函数是常用的关键函数之一，会接收字符串作为输入，并将其传入shell程序中执行。通过使用system函数，攻击者能执行任何它想执行的程序。所以攻击者仅仅需要在栈上放置一个包含命令的字符串代替执行shellcode,并通过返回地址来转移控制至system函数。system并不是攻击者唯一感兴趣的函数。此外除了显示跳转到libc函数，也存在一些隐式攻击的方式，在Linux中攻击者可以返回PLT(过程链接表)。PLT是一个使动态链接更容易的结构，并且包含执行时一次调用冬天链接函数的代码段，返回此代码然后间接执行库函数

**返回导向编程(ROP)**：ROP是将程序代码重用到极致的想法。利用返回导向编程，攻击者可以返回到文本段中的任何指令而不仅仅是返回库函数的入口地址。返回导向编程的诀窍是寻找一系列可以满足以下两个条件的片段代码:1.有用；20以返回指令结束。攻击者可以通过堆栈上的返回地址将这些序列串在一起单独的代码片段被称为**小工具(gadget)**。通常它们具有非常有限的功能，如添加两个寄存器、将值从内存加载到寄存器或将值推到堆栈上。换句话说，小工具的集合可以被看作一个非常奇怪的指令集，攻击者可以利用栈的建立随意巧妙地操纵功能。同时堆栈指针也可以被看作稍显奇怪的程序计数器，并且在提供着相应的服务

5. **地址空间布局随机化(ASLR)**

**地址空间布局随机化(ASLR)**：随机化程序每次运行时多用的函数和数据的地址，尤其经常将初始堆栈和库的位置进行随机化

弱点：ASLR的随机性不够强。ASLR的许多实现中仍然有一些在固定地址的代码，并且即使一个片段被随机化了，该随机化也可能很薄弱，攻击者可以强行破解它

一种更重要的对抗ASLR的攻击是通过内存泄漏形成的。在这种情况下，攻击者利用漏洞不是为了直接控制程序，而是泄露关于内存布局的信息，他可以利用这些信息作为第二个攻击漏洞。函数地址对于攻击而言是十分重要的。原因是即使库装载的位置是随机的，但是每个函数位置的相对偏移是固定的。如果你知道一个函数，你就能找到所有函数。即使不是这样的情况，只要有一段代码地址，也是非常容易获取其他函数的位置的

### 9.7.2 格式化字符串攻击

修改代码的程序员意外地允许程序的用户(无意中)输入一个格式化字符串。因为输入格式化字符串可以覆盖内存，所以现在便得到了进行攻击所需要的工具，它可以修改栈中printf函数的返回地址并可以跳转到其他地方，例如一个新进入的格式化字符串。这种方法称为**格式化字符串攻击**。一旦用户有能力重写内存并强制跳转到新注入的代码，代码就拥有了被攻击程序的能力和权限

### 9.7.3 悬垂指针

C和C++允许程序使用malloc调用来分配堆中的内存，它返回指向新分配的内存块的指针。之后程序不再需要它时，便调用free来释放内存。当程序在释放内存后仍然意外地使用该块内存时，悬垂指针错误就会发生。当给已经被释放了的指针赋值时，会更新已经被释放的指针之前所用的内存，并且可能修改了现在该内存中的数据结构。一般来说这样的内存错误不是什么好事，但如果是攻击者用这样的方法操纵程序就会更糟，因为他可以在内存中放置一个特定的堆对象，而该对象的第一个整数将包含用户权限。这不容易实现，但是存在这样的技术(**堆风水**)来帮助攻击者努力实现它。使用堆风水来测算堆中的内存。如果数字风水大师成功，他就能将权限等级设置成任意值

### 9.7.4 空指针间接引用攻击

内存管理中现代操作系统虚拟化内核和用户进程的地址空间。在一个程序访问内存地址之前，MMU将虚拟地址通过页表的方式转换为物理地址。没有被映射的页将不能被访问。假设内核地址空间和一个用户进程的地址空间完全不同看起来是符合逻辑的，但是实际上不总是这样的。例如在Linux中，内核简单地映射到每个进程的地址空间并且当内核开始执行系统调用时，它将在进程地址空间运行。在32位系统中，用户空间占3GB的低位地址空间，内核占1G的高位地址空间。这样组合的原因在于地址空间中相互转换的代价较高

通常这样安排不会造成任何问题。但是当攻击者使用内核调用用户空间的函数时，情况就有所不同。一个错误的内核可能在罕见和不幸的条件下意外地应用一个空指针。引用空指针会导致程序和系统的崩溃，所以非常危险。在用户进程中导致程序崩溃就已经足够严重，但在内核中会更糟糕，因为它会拿下整个系统

有时当攻击者触发用户进程的空指针引用时，攻击者可以调用留给你shell

内核与用户空间的交互可能在意想不到的地方出现

### 9.7.5 整数溢出攻击

计算机在固定长度的数字上做整数运算，通常是8、16,32或64位。如果相加或相乘的两个数字的总和超过可以表示的最大整数，则会发生溢出。C程序不会捕捉该错误，它们只是存储和使用错误的值。特别的是，如果变量是有符号整数，则相加或相乘两个正整数的存储结果可能是个负整数。如果整数是无符号的，则结果是正的但可能绕回。

这种没有被发现的数字溢出可能被利用并成为一种攻击方法。具体而言，给程序提供两个有效(但大)的参数，它们相加或相乘的结果会导致溢出。例如一些图形程序带有命令行参数，给出了图像文件的高度和宽度，可用于转换输入图像的大小等目的。如果目标宽度和高度造成了强行溢出，程序将会错误计算它存储图像所需要的内存大小并调用malloc来分配一个很小的缓冲区。此时的环境对于缓冲区溢出攻击来说已经相当成熟。当有符号正整数求和或乘积并得到负数的结果时，也有可能产生类似的漏洞

### 9.7.6 命令注入攻击

**命令注入**：让目标程序执行命令而没有意识到它在执行命令。如程序读取输入并作为shell命令参数时，输入攻击代码

### 9.7.7 检查时间/使用时间攻击

**检查时间/使用时间**：文件的访问权限的时间和使用特权的时间是不一样的。假设在文件访问检查后的一秒钟内，攻击者设法创建一个与文件名相同的符号链接到密码文件。在这种情况下将打开错误的文件，并最终在密码文件写入攻击者的数据。为了摆脱它，攻击者必须与程序竞争，让程序在正确的时间创建符号链接

另一种针对这种特殊攻击方式的分析是发现access系统调用并不安全。先打开文件，然后检查使用文件描述符的权限而不是使用fstat函数将会更好。文件描述符的权限而不是使用fstat函数将会更好。文件描述符是安全的，因为他们不会被攻击者的fstat和write调用修改。所以为操作系统设计一个良好的API是非常重要而且相当困难的

## 9.8 内部攻击

**内部攻击**：一些公司的编程人员或使用这些受保护的计算机、编制核心软件的员工实施。来自内部攻击与外部攻击的区别在于，内部攻击者拥有外部人员所不具备的专业知识和访问权限

### 9.8.1 逻辑炸弹

**逻辑炸弹**：程序代码被秘密的放入产品中，只要不触发一定条件就相安无事，但一旦触发条件就会发作，可能会擦去磁盘、随机删除文件、对核心程序做难以发现的改动、对原始文件进行加密等

在很多有记录的案例中,病毒向被其感染的计算机中植入逻辑炸弹。一般情况下，这些逻辑炸弹被设计为在未来的某个时间"爆炸"。然而由于程序员无法预知那一台计算机将会被攻击，因此逻辑炸弹无法用于保护自己不失业，也无法用户勒索。这些逻辑炸弹通常会被设定为在政治上有重要意义的日子爆炸，因此它们也称作**时间炸弹**

### 9.8.2 后门陷阱

**后门陷阱**：这一问题是由系统程序员跳过一些常见的检测并插入一段代码造成的。后门陷阱程序的实质是它跳过了正常的认证过程

对公司来说，防止后门的一个方法是把**代码审查**作为标准惯例来执行。通过这一技术，一旦程序员完成对某个模块的编写和测试后，该模块被放入代码数据库中进行检验。开发小组里的所有程序员周期性地聚会，每个人在小组面前向大家解释每行代码的含义。这样做不仅增加了找出后门代码的机会，而且增加了大家的责任感，被抓出来的程序员也知道这样做会损害自己的职业生涯。如果该建议遭到了太多的反对,那么让两个程序员相互检查代码也是一个可行的方法

### 9.8.3 登陆欺骗

**登陆欺骗**：实施者是系统的合法用户，然而这些合法用户却试图通过登录欺骗的手段获取他人的密码。这种攻击通常发生在一个具有大量多用户公用计算机的局域网内

防止登录欺骗的唯一实用的办法是将登录序列与用户程序不能捕捉的键组合起来。Windows为此目的采用了Ctrl-Alt-Del。如果用户坐在终端前开始按Ctrl-Alt-Del，当前用户就会被注销并启动新的登录程序。没有任何办法可以跳过这一步

## 9.9 恶意软件

1. **恶意软件的应用**：

绝大多数这样的恶意软件的设计目标都是"传播越快越好,范围越广越好"。当一台机器被感染，恶意软件被安装，并且向在世界某地的控制者机器报告该机器的地址。用于控制的机器通常都被设置在一些欠发达的或法制宽松的国家。在被感染的机器中通常都会安装一个**后门程序**，以便犯罪者可以随时向该机器发出指令，以方便地控制该机器。以这种方式被控制的机器叫作**僵尸机器**，而所有被控制的机器合起来称作**僵尸网络**

恶意软件的另一个应用是在被感染机器中安装一个记录用户所有敲击键盘动作的软件---**键盘记录器**，该软件每隔一段时间将记录的结果发送给其他某台机器或一组机器(包括僵尸机器)，最终发送到罪犯手中

1. 恶意软件容易传播的原因：

产生这种情况的原因有很多。其中之一是世界上90%的计算机运行的是单一版本的操作系统(Windows)，使得它成为一个非常容易被攻击的目标。假设每台计算机都有10个操作系统，其中每个操作系统占有市场的10%，那么传播恶意代码就会变得加倍的困难。这就好比在生物世界中，物种多样化可以有效防止生物灭绝

第二个原因是，微软在很早以前就强调其Windows操作系统对于没有计算机专业知识的人而言是简单易用的。操作系统易用性是微软一贯坚持的市场策略，因此他们在安全性与易用性之间不断进行着权衡

### 9.9.1 特洛伊木马

**木马攻击**：编写一些有用的程序，并将恶意代码嵌入到其中。木马指人们自愿下载的软件中所隐藏的恶意软件

当用户下载的程序运行时，它调用函数将恶意代码写入磁盘成为可执行程序并启动该程序。恶意代码接下来便可以进行任何预先设计好的破坏活动，如删除、修改或加密文件。通常情况下，恶意代码还包括一些指令，使得它在计算机每次重新启动的时候自动启动，这一点所有的操作系统都可以做到

木马的拥有者不必自己费尽心机侵入到受害者的计算机中，因为木马是由受害者自己安装的。

### 9.9.2 病毒

**病毒**是一种特殊的程序，它可以通过把自己植入到其他程序中来进行"繁殖",就像生物界中真正的病毒那样。除了繁殖自身以外，病毒还可以做许多其他的事情。蠕虫很像病毒，但其不同点是通过自己复制自己来繁殖。不过这不是我们关注的重点，因此下面将用"病毒"来统称上面两种恶意程序。有关蠕虫的内容会在9.7.3节中讲解

1. 病毒工作原理

病毒的制造者可能用汇编语言(或者C语言)写了一段很小但是有效的病毒。在他完成这个病毒之后，他利用一个叫作dropper的工具把病毒插入到自己计算机的程序里，然后让被感染的程序迅速传播

一旦病毒程序被安装到受害者的计算机里，病毒就处于休眠状态直到被感染的程序被执行。发作时它感染其他程序并执行自己的操作。通常，在某个特定日期之前病毒是不执行任何操作的，直到某一天它认为自己在被关注前已被广泛传播时才发作

2. **共事者病毒**

**共事者病毒**并不真正感染程序，但当程序执行的时候它也执行。例如替换快捷方式等

3. **可执行程序病毒**

**可执行程序病毒**是感染可执行程序的病毒，当可执行程序执行时病毒会感染其他文件

**寄生病毒**把自己附在正常的程序里，在病毒发作时可以让原来的程序正常工作

**空腔病毒**：复杂的可执行程序格式，如Windows里的.exe文件和UNIX系统中几乎所有的二进制格式文件都拥有多个文本和数据段，可以用装载程序在内存中迅速把这些段组装和分配。在有些系统中(如Windows),所有的段都包含多个512字节单元。如果某个段不满，链接程序会用0填充。知道这一点的病毒会试图隐藏在这些空洞里。如果正好填满多余的空间，整个文件大小将和未感染的文件一样保持不变，不过却有了一个附加物。这类病毒叫作空腔病毒。当然如果装载程序不把多余部分装入内存，病毒也会另觅途径

4. **内存驻留病毒**

到目前为止，我们假设当被感染的程序运行时,病毒也同时运行,然后将控制权交给真正的程序,最后退出。**内存驻留病毒**与此相反，它们总是驻留在内存中(RAM)，要么藏在内存上端，要么藏在下端的中断变量中。聪明的病毒甚至可以改变操作系统的RAM分布位图，让系统以为病毒所在的区域已经占用,从而避免了被其他程序覆盖

典型的内存驻留病毒通过把陷阱或中断向量中的内容复制到任意变量中之后，将自身的地址放置其中，俘获陷阱或中断向量，从而将该陷阱或中断指向病毒。最好的选择是系统调用陷阱，这样病毒就可以在每一次系统调用时运行(在核心态下)。病毒运行完之后，通过跳转到所保存的陷阱地址重新激活真正的系统调用

为什么病毒在每次系统调用时都要运行呢?这是因为病毒想感染程序。病毒可以等待直到发现一个exec系统调用，从而判断这是一个可执行二进制(而且也许是一个有价值的)代码文件，于是决定感染它。这一过程并不需要大量的磁盘活动，所以难以被发现。捕捉所有的系统调用也给了病毒潜在的能力，可以监视所有的数据并造成种种危害

5. **引导扇区病毒**

当大多数计算机开机时，,BIOS读引导磁盘的主引导记录放入RAM中并运行。引导程序判断出哪一个是活动分区，从该分区读取第一个扇区(引导扇区)并运行。随后系统要么装入操作系统要么通过装载程序导入操作系统。所以可以制作一种病毒覆盖主引导记录或引导扇区，并能造成灾难性的后果。这种叫作**引导扇区病毒**

通常引导扇区病毒(包括MBR(主引导记录)病毒)，首先把真正的引导记录扇区复制到磁盘的安全区域，这样就能在完成操作后正常引导操作系统

6. **设备驱动病毒**

**设备驱动病毒**感染设备驱动程序。在Windows和有些UNIX系统中，设备驱动程序是位于磁盘里或在启动时被加载的可执行程序。如果有一个驱动程序被寄生病毒感染，病毒就能够在每次启动时被正大光明地载入。而且，当驱动程序运行在核心态下，一旦被加载就会调用病毒,从而给病毒获取系统调用的陷阱向量的机会。这样的情况促使我们限制驱动程序运行在用户态，这样的话即使驱动程序被病毒感染，它们也不能像在内核态的驱动程序一样，造成很大的危害

7. **宏病毒**

个**宏病毒**代码位于应用程序的宏文件中。既然宏可以包含任意程序，它就可以做任何事情，如感染其他的Word文档，删除文件等。对Microsoft来说，Word在打开含有宏的文件时确实能给出警告，但大多数用户并不理解警告的含义并继续执行打开操作。而，合法文件也会包含宏。还有很多程序甚至不给出警告，这样就更难以发现病毒了

8. **源代码病毒**

寄生病毒和引导区病毒对操作系统平台有很高的依赖性;文件病毒的依赖性就小得多。最具移植性的病毒是**源代码病毒**，该病毒不是寻找可执行二进制文件，而是寻找C语言程序并加以改变，并在源文件中合适的地方插入调用语句。当程序运行时，病毒也被调用。病毒可以做任何操作，如查找并感染其他的C语言程序。一旦找到一个C语言程序，病毒就插入代码，但这样做仅对本地计算机有效，并且头文件必须安放妥当。要使病毒对远程计算机也奏效，程序中必须包括所有的病毒源代码。这可以通过把源代码作为初始化后字符串来实现，特别是使用一串32位的十六进制整数来防止他人识破企图。字符串也许会很长，但是对于今天的大型代码而言，这是可以轻易实现的

### 9.9.3 蠕虫

**蠕虫**：能够自我复制的程序。从技术上来说，蠕虫包含了两部分程序，引导程序和蠕虫本身。引导程序在被攻击的计算机上编译并运行。一旦发作，它就在源计算机与宿主机之间建立连接，上传蠕虫主体并运行。在花费了一番周折隐藏自身后，蠕虫会查看新宿主机的路由表看它是否连接到其他的机器上，通过这种方式蠕虫把引导程序传播到所有相连的机器

**计算机应急响应机构(CERT)**：这是一个发布病毒入侵报告的中心机构，有多名专家分析安全问题并设计补丁程序

### 9.9.4 间谍软件

**间谍软件**是一种迅速扩散的恶意软件

特征：1.它隐藏自身，所以用户不能轻易地找到；2.它收集用户数据(如访问过的网址、密码或信用卡号)；3.它将收集到的资料传给远程的监控者；4.在卸载它时，间谍软件会试图进行防御。此外，一些间谍软件改变设置或者进行其他的恶意行为

分类：1.是为了营销，该类软件只是简单地收集信息并发送给控制者，以更好地将广告投放到特定的计算机；2.是为了监视，某些公司故意在职员的电脑上安装间谍软件，监视他们在做什么，在浏览什么网站；3.接近于典型的恶意软件，被感染的电脑成为僵尸网络中的一部分,等待控制者的指令

1. 间谍软件如何扩散

	1. 一种可能途径和所有的恶意软件是一样的:通过木马。不少的免费软件是包含有间谍软件的，软件的开发者可能就是通过间谍软件而获利的

	2. 另一种主要的感染途径叫作**下载驱动**，仅仅访问网页就可能感染间谍软件(实际上是恶意软件)。执行感染的技术有三种。		1. 首先网页可能将浏览器导向一个可执行文件(.exe)。当浏览器访问此文件时，会弹出一个对话框提示用户运行、或保存该文件。因为合法文件的下载也是一样的机制，所以大部分用户直接点击执行，导致浏览器下载并运行该软件。然后电脑就被感染了，间谍软件可以做它想做的任何事

		2. 第二种常见的途径是被感染的工具条。IE和Firefox这两种浏览器都支持第三方工具条。一些间谍软件的作者创建很好看的功能也不错的工具条，然后广泛地宣传。用户一旦安装了这样的工具条也就被感染了。从本质上讲，这种感染机制很像木马，只是包装不同

		3. 第三种感染的途径更狡猾。很多网页都使用一种微软的技术，叫作ActiveX控件。这些控件是在浏览器中运行并扩展其功能的二进制代码。例如，显示某种特定的图片、音频或视频网页。从原则上讲,这些技术非常合法。实际上它非常的危险，并可能是间谍软件感染的主要途径。这项技术主要针对IE,很少针对Firefox或其他类型的浏览器

2. 间谍软件的行为	1. 劫持浏览器(更改浏览器主页、修改浏览器收藏页、在浏览器中增加新的工具条)	2. 修改Windows注册表的设置(更改用户默认的媒体播放器、更改用户默认的搜索引擎)	3. 在Windows桌面上增加新的图标	4. 将网页上的广告条替换成间谍软件期望的样子	5. 在标准的Windows对话框汇总增加广告	6. 不停地产生广告	7. 关闭防火墙、卸载其他的间谍软件，并可能导致其他的恶意行为

间谍软件不应该和**广告软件**混淆起来，合法的软件生产商提供了两种软件版本：一个含有广告的免费版本和一个不含广告的付费版本。软件生产商的这种办法非常聪明，用户为了不受广告的烦扰,而不得不升级到付费版本

### 9.9.5 rootkit

**rootkit**是一个程序或一些程序和文件的集合，它试图隐藏其自身的存在，即使被感染主机的拥有者已经决定对其进行定位和删除。在通常情况下，rootkit包含一些同样具有隐藏性的恶意软件。rootkit可以用我们目前讨论过的任一方法进行安装，包括病毒、蠕虫和间谍软件,也可以通过其他方法进行安装

* rootkit的类型：根据rootkit在哪里隐藏自己，自底向上将rootkit分为如下几类	1. **固件rootkit**：至少从理论上讲，一个rootkit可以通过更新BIOS来隐藏自己在BIOS中。只要主机被引导启动或者一个BIOS函数被调用，这种rootkit就可以获得控制。如果rootkit在每次使用后对自己加密而在每次使用前对自己解密，它就很难被发现。这种rootkit在现实环境下还没有发现	2. **管理程序rootkit**：这是一种尤其卑鄙的rootkit，它可以在一个由自己控制的虚拟机中运行整个操作系统和所有应用程序。这种rootkit通常更改引导顺序以便它能在主机启动时在裸机下执行管理程序,这个管理程序会在一个虚拟机中启动操作系统和所有应用程序。与前一种方法类似，这种方法的优点在于没有任何东西隐藏在操作系统、库或者程序中，因此检查这些地方的rootkit检测程序就显得不足	3. **内核rootkit**：目前最常见的rootkit感染操作系统并作为驱动程序或可引导内核模块隐藏于其中。这种rootkit可以轻松地将一个大而复杂且频繁变化的驱动程序替换为一个新的驱动程序，这个新的驱动程序既包含原驱动程序又包含rootkit	4. **库rootkit**：另一个rootkit可以隐藏的地方是系统库，如Linux中的libc。这种位置给恶意软件提供了机会去检查系统调用的参数和返回值，并根据自身隐藏的需要更改这些参数和返回值	5. **应用程序rootkit**：另一个隐藏rootkit的地方是在大的应用程序中，尤其是那些在运行时会创建很多新文件的应用程序中(如用户分布图、图像预览等)。这些新文件是隐藏ootkit的好地方，没有人会怀疑其存在

## 9.10 防御

**全面防御**：基本地讲，这个概念是指必须有多层的安全性，以便于当其中的一层被破坏，仍然还有其它层要去防御

### 9.10.1 防火墙

防火墙有两种基本的类型:硬件防火墙和软件防火墙。有局域网需要保护的公司通常选择硬件防火墙;而家庭的个人用户通常会选择软件防火墙。

使用硬件防火墙时，来自网络提供者的连接(电缆或光纤)会被插到防火墙上，防火墙也连接到局域网上。不经过防火墙的允许任何包都不能进入或者离开局域网。实际的情况下，防护墙通常会和路由器、网络地址转换盒、指令检查系统和其他设备联合起来工作，但是在这里我们只关注于防火墙自身的功能。防火墙根据一些规则来配置,这些规则描述什么是允许的，什么是不允许的。防护墙的管理者可以修改这些规则,通常修改是通过一个Web界面进行的(大多数防火墙都内置一个小型Web服务器来实现它)。

最简单的一种防护墙是**无状态防护墙**，只会检查通过的包的头部，然后根据包头部的信息和防火墙的规则作出传送还是丢弃这个包的决定。包头部的信息包括源和目的的IP地址、源和目的的端口、服务的类型和协议。包头部的其他属性也是可以得到的，但是很少会被防火墙的规则涉及

除了无状态防火墙以外，还有一种跟踪连接以及连接状况的**状态防火墙**。这些防火墙能够更好地防止某些类型的攻击，特别是那些和建立连接有关的攻击。

一些其他类型的防火墙实现了**入侵检测系统(IDS)**，利用IDS防火墙不仅可以检测包的头部还可以用检测包的内容来查找可疑的内容

软件防火墙，有时也叫作个人防火墙，和硬件防火墙具有同样的功能，只不过是通过软件方式实现的。它们是附加在操作系统内核的网络代码上的过滤器，是和硬件防火墙工作机制一样的过滤数据包

### 9.10.2 反病毒和抑制反病毒技术

防火墙会尽量地阻止入侵者进入电脑，但是在很多情况下防火墙会失败。在这种情况下，下一道防线是由**反恶意软件**的程序组成的。尽管这种反恶意软件的程序同样可以对抗蠕虫和间谍软件，但是它们通常称作**反病毒程序**。病毒尽量地隐藏自己，而用户则是努力地发现它们，这就像是一个猫捉老鼠的游戏。在这方面，病毒很像rootkit,不同的地方是病毒的制造者更强调的是病毒的传播速度而不是像rookit一样注重于捉迷藏

1. 病毒扫描器

反病毒软件的工作原理：反病毒软件公司拥有一流的实验室，在那里许多专家长时间地跟踪并研究不断涌现出的新病毒。第一步是让病毒感染不执行任何操作的程序，这类程序叫作**诱饵文件**，然后获取病毒的完整内容。下一步是列出病毒的完全代码表把它输入已知病毒的数据库

一旦反病毒软件安装在用户的计算机里，第一件事就是在硬盘里扫描所有可执行文件，看看是否能发现病毒库里已知的病毒。大多数反病毒公司都建有网站，从那里客户可以下载新发现病毒的特征码到自己的病毒库里

由于有些已知病毒总是在不断发生细微变化，所以人们需要一种模糊查询软件。但是模糊查询不仅比正常查询慢，而且容易导致错误报警(误测)

多形态病毒：每次复制时都发生变异的病毒

变异引擎：能够交换机器码指令而不影响程序功能的代码。较复杂的病毒在复制病毒体时，可以通过变异引擎产生不同的解密代码。变异的手段包括插入一些没用而且没有危害的代码，改变代码的顺序，交换寄存器，把某条指令用它的等价指令替换。变异引擎本身与病毒体一起也可以通过加密的方法隐藏起来

2. 完整性检查

另一种完全不同的病毒检测方法是实施**完整性检查**。采用这种方法的反病毒程序首先扫描硬盘上的病毒，一旦确信硬盘是干净的，它就开始为每个可执行文件计算一个校验和。计算校验和的算法应该是很简单的，就像把程序段中的所有字作为32位或者64位整数加起来求和一样简单，但是这种算法也要像加密的散列算法一样，是不可能逆向求解的。然后，要把一个目录中的所有相关文件的校验和写到一个文件中去。下一次运行的时候，程序重新计算校验值，看是否与校验和文件里的值相匹配。这样被感染的文件会立刻被查出

3. 行为检查程序

第三种反病毒程序使用的方法是实施**行为检查**。通过这种方法，反病毒程序在系统运行时驻留在内存里，并自己捕捉所有的系统调用。这一方法能够监视所有的系统活动，并试图捕捉任何可能被怀疑的行为。例如通常没有程序会覆盖引导扇区，所以有这种企图的程序几乎可以肯定是病毒。同理改变闪速ROM的内容也值得怀疑

4. 病毒避免

* 用户病毒感染方法：	1. 选择能提供高度安全保障的操作系统，这样的系统应该拥有强大的核心---用户态边界，分离提供每个用户和系统管理员的登录密码。在这些条件下，溜进来的病毒无法感染系统代码	2. 仅安装从可靠的供应商处购买的最小配置的软件。有时即使这样也不能保证有些软件公司雇员会在商业软件产品里放置病毒，但这样做会有较大的帮助。从Web站点和公告板下载软件是十分冒险的行为	3. 购买性能良好的反病毒软件并按指定要求使用。确保能够经常从厂商站点下载更新版本	4. 不要点击电子邮件里的附件，告诉他人不要发送附件给自己。使用简明ASCII文本的邮件比较安全，而附件在打开时可能会启动病毒程序	5. 定期将重要文件备份到外部存储介质。在一系列的备份介质中应该保存不同的版本。这样当发现病毒时就有机会还原被感染前的文件。例如假设还原昨天已被感染的备份版本不成功的话,还原上一周的版本也许会有用	6. 抵抗住诱惑，不要从一个不了解的地方下载并运行那些吸引人的新免费软件。或许这些软件免费的原因是:它的制造者想让你的机器加入他的僵尸机器的大军中来。然而，如果你有虚拟机软件的话，在虚拟机中运行这些不了解的软件是安全的

* 业界应该改变的危险的做法：	1. 制造简单的操作系统。铃声和口哨声越多，安全漏洞也越多，这就是现实	2. 不要使用动态文本。从安全角度来说，动态文本是可怕的。浏览别人提供的文档时最好不要运行别人提供的程序。例如,JPEG文件就不包含程序，所以也就不会含有病毒。所有的文档都应该以这样的方式工作	3. 应该采取措施将重要的磁盘柱面有选择性地写保护，防止病毒感染程序。这种方法必须在控制器内部放置位图说明，位图里含有受保护磁盘柱面的分布图。只有当用户拨动了计算机面板上的机械拨动开关后,位图才能够被改动	4. 使用闪存是个好主意，但只有用户拨动了外部开关后才能被改动，如当用户有意识地安装BIOS升级程序的时候

### 9.10.3 代码签名

代码签名法是基于公钥密码体系。如某个软件厂商产生了一对密钥（公钥和私钥)，将公钥公开,私钥妥善保存。为了完成对一个软件签名，供应商首先将代码进行散列函数运算，得到128位(采用MD5算法)、160位(采用SHA-1算法)或256位(采用SHA-256算法）的值。然后通过私钥加密计算得到的哈希值取得散列值的数字签名。这个数字签名则始终伴随着这个软件

当用户得到这个软件后，计算出散列函数并保存结果，然后将附带的数字签名用公钥进行解密。接着核对解密后的散列函数值同自己运算出的值是否相等。如果相等，这个软件就被接受，否则就作为伪造版本被拒绝。这里所用到的数学方法使得任何想要篡改软件的人十分难以得手,因为这个散列函数要同从真正的数字签名中解密出来的散列函数匹配。在没有私钥的情况下通过产生匹配的假数字签名是十分困难的

### 9.10.4 囚禁

**囚禁**：一个新被接受的程序会作为一个标有"囚犯"的标签的进程来运行。而"狱卒"是一个可信任的(系统的)进程，可以监管囚犯进程的行为。当一个被监禁的进程作出一个系统调用的时候，系统调用不会执行，而是把控制移交给狱卒进程(通过一个内核陷入)并把系统调用号和参数传递给它。这个狱卒进程会判断是否这个系统调用被允许。例如如果被监禁的进程试图和一个狱卒进程不知道的远程主机建立一个网络连接，这个系统调用会被拒绝然后该囚犯进程被结束。如果这个系统调用是可以接受的，那么狱卒进程会通知内核，由内核来执行该系统调用。通过使用这种方法，不正确的行为会在它引起麻烦之前被捕捉到

### 9.10.5 基于模型的入侵检测

还有一种方法可以保护我们的机器，那就是安装一个IDS(入侵检测系统)。IDS有网种基本的类型，一种关注于监测进入电脑的网络包，另一种关注寻找CPU上的异常情况

**基于静态模型的入侵检测**：当使用这种基于静态模型的入侵检测的时候，狱卒必须知道这个模型(比如系统调用图)。最直接的方式就是让编译器产生它并让程序的作者签名同时附上它的证书。这样的话，任何预先修改可执行程序的企图都会被在程序运行的时候检测到，因为实际的行为和被签过名的预期行为不一致。

很不幸的是，一个聪明的攻击者可能发动一种叫作**模仿攻击**的攻击，在这种攻击中插入的代码会有和该程序同样的系统调用序列，所以我们需要更复杂的模型，不能仅仅依靠跟踪系统调用。然而，作为深层防御的一部分，IDS还是扮演着重要的角色

无论如何，基于模型的IDS不仅仅是一种。许多IDS利用了一个叫作**蜜罐**的概念，这是一个吸引和捕捉攻击者和恶意软件的陷阱。通常蜜罐会是一个孤立的机器，几乎没有防御，表面看起来令人感兴趣并且有些有价值的内容，像一个成熟等待采摘的果实一样。设置蜜罐的人会小心翼翼地监视它上面的任何攻击并尽量去了解攻击的特征。一些IDS会把蜜罐放在虚拟机上防止对下层实际系统的破坏。所以很自然地，恶意软件也会像之前提到的那样努力检查自己是否运行在虚拟机上

### 9.10.6 封装移动代码

* 沙盒法

**沙盒法**将每个运行的Applet(在本地运行的一种远程代码)限制在一定范围的有效地址中。它的工作原理是把虚拟地址空间划分为相同大小的区域,每个区域叫作沙盒。每个沙盒必须保证所有的地址共享高位字节。对32位的地址来说,我们可以把它划分为256个沙盒，每个沙盒有16MB空间并共享相同的高8位。同样我们也可以划分为512个8MB空间的沙盒，每个沙盒共享9位地址前缀。沙盒的尺寸可以选取到足够容纳最大的Applet而不浪费太多的地址空间。如果页面调用满足的话,物理内存不会成为问题。每个Applet拥有两个沙盒,一个放置代码,另一个放置数据,

沙盒的用意在于保证每个Applet不能跳转到或引用其他的代码沙盒或数据沙盒。提供两个沙盒的目的是为了避免Applet在运行时超越限制修改代码。通过抑制把所有的Applet放入代码沙盒，我们减少了自我修改代码的危险。只要Applet通过这种方法受到限制,它就不能损害浏览器或其他的Applet，也不能在内存里培植病毒或者对内存造成损失

另一个要解决的问题是当Applet试图进行系统调用时会发生什么?解决方法是很直接的。系统调用的指令被一个叫作**基准监视器**的特殊模块所替代。基准监视器检查每一个调用企图，并决定该调用是否可以安全执行。如果认为该调用是可接受的，如在指定的暂存目录中写临时文件，这种调用就可以执行。如果调用被认为是危险的或者基准监视器无法判断,Applet就被终止。若基准监视器可以判断是哪一个Applet执行的调用，内存里的一个基准监视器就能处理所有这样Applet的请求。基准监视器通常从配置文件中获知是否允许执行

* 解释

第二种运行不安全Applet的方法是解释运行并阻止它们获得对硬件的控制。Web浏览器使用的就是这种方法。网页上的Applet通常是用Java写的，Java可以是一种普通的编程语言，也可以是高级脚本语言，如安全TCL语言或Javascript。Java Applet首先被编译成一种叫作**JVM(Java虚拟机**)的面向栈的机器语言。正是这些JVM Applet被放在网页上，当它们被下载时就插入到浏览器内置的JVM解释器中

使用解释运行的代码比编译运行的代码好处在于,每一条指令在执行前都由解释器进行检查。这就给了解释器识别校验地址是否有效的机会。另外系统调用也可以被捕捉并解释。这些调用的处理方式与安全策略有关。例如,如果Applet是可信任的(如来自本地磁盘的Applet)，它的系统调用就可以毫无疑问会被执行。但是如果Applet不受信任(如来自Internet的Applet)，它就会被放入沙盒来限制自身的行为

高级脚本语言也能够被解释执行。这里，解释执行不需要机器地址，所以也就不存在脚本以不允许的方式访问内存所带来的危险。解释运行的缺点是:它与编译运行的代码相比十分缓慢

### 9.10.7 Java安全性

Java是一种类型安全的编程语言，即编译器拒绝任何值与类型不符的变量的使用。而C语言正好相反。而且Java没有指针变量、类型转换、用户控制的存储单元分配(如malloc和free)，并且所有的数组引用都要在运行时进行校验

Java程序被编译成一种叫作JVM字节码的中间形态二进制代码。JVM有大约100个指令，大多数指令是把不同类型的对象压入栈、弹出栈或是用算术合并栈里的对象。这些JVM程序通常是解释执行程序，虽然在某些情况下它们可以被编译成机器语言以便执行得更快

## 9.12 小结

计算机中经常会包含有价值的机密数据，包括纳税申请单、信用卡账号、商业计划、交易秘密等。这些计算机的主人通常非常渴望保证这些数据是私人所有，不会被窜改，这就迅速地导致了我们要求操作系统一定要有好的安全性。一种保证信息机密的方法是把它加密并妥善地保管密钥。有时侯提供数字信息的验证是很重要的，在这种情况下，可以使用加密散列表、数字签名以及被一个可信的证书验证机构所签名的证书

操作系统安全的基础构件是对系统资源的访问控制。访问权限可以被看作一个大型矩阵，其中行代表主体，列代表客体。每一个单元格描述了主体对客体的访问权限。由于矩阵非常稀疏，因此可以按行存储，形成权限列表来描述某一主体能够对哪些客体进行何种操作;也可以按列存储,形成访问控制列表来描述某一客体能够被哪些主体所操作。利用形式化建模技术，系统内的信息流可以被建模并限制。但是在某些情况下，信息仍然可能通过隐蔽信道外泄，例如调节CPU的使用率等

一种保持信息私密性的手段是对信息进行加密并小心管理密钥。加密机制可以分为私钥加密和公钥加密。私钥加密方法要求通信参与者利用带外机制提前交换私钥。公钥加密则无须如此，但是在实际的使用中效率较低。某些情况下需要对数字信息的真实性进行验证，由于加密机制会使得验证过程繁琐复杂,因此可以使用可信的第三方所提供的数字签名和许可证明

在任何一个安全的系统一定要认证用户。这可以通过用户知道的、用户拥有的，或者用户的身份(生物测定)来完成。使用双因素的身份认证，比如虹膜扫描和密码，可以加强安全性

代码中有很多bug可以被利用来控制程序和系统。这些包括缓冲区溢出、格式串攻击、返回libc攻击,整数溢出攻击、代码注入攻击和特权扩大攻击

Internet上遍布恶意软件，有特洛伊木马、病毒、蠕虫、间谍软件和rookit。每一个都对数据机密性和一致性产生着威胁。更糟糕的是，恶意软件攻击可能会控制一台机器，并把这台机器变成一台僵尸机器用来发送垃圾邮件或者发起其他的攻击。许多互联网上的攻击都是通过一台僵尸主控机控制一个僵尸军队来完成的

幸运的是，系统有很多种方法来保护自己。最好的策略就是全面防御，使用多种技术一起防御。这些技术有防火墙、病毒扫描、代码签名、囚禁、入侵检测,以及封装移动代码