- [5. 输入/输出](#5-输入输出)
	- [5.1 I/O硬件原理](#51-io硬件原理)
		- [5.1.1 I/O设备](#511-io设备)
		- [5.1.2 设备控制器](#512-设备控制器)
		- [5.1.3 内存映射I/O](#513-内存映射io)
		- [5.1.4 直接存储器存取](#514-直接存储器存取)
		- [5.1.5 重温中断](#515-重温中断)
	- [5.2 I/O软件原理](#52-io软件原理)
		- [5.2.1 I/O软件的目标](#521-io软件的目标)
		- [5.2.2 程序控制I/O](#522-程序控制io)
		- [5.2.3 中断驱动I/O](#523-中断驱动io)
		- [5.2.4 使用DMA的I/O](#524-使用dma的io)
	- [5.3 I/O软件层次](#53-io软件层次)
		- [5.3.1 中断处理程序](#531-中断处理程序)
		- [5.3.2 设备驱动程序](#532-设备驱动程序)
		- [5.3.3 与设备无关的I/O软件](#533-与设备无关的io软件)
		- [5.3.4 用户空间的I/O软件](#534-用户空间的io软件)
	- [5.4 盘](#54-盘)
		- [5.4.1 盘的硬件](#541-盘的硬件)
		- [5.4.2 磁盘格式化](#542-磁盘格式化)
		- [5.4.3 磁盘臂调度算法](#543-磁盘臂调度算法)
		- [5.4.4 错误处理](#544-错误处理)
		- [5.4.5 稳定存储器](#545-稳定存储器)
	- [5.5 时钟](#55-时钟)
		- [5.5.1 时钟硬件](#551-时钟硬件)
		- [5.5.2 时钟软件](#552-时钟软件)
		- [5.5.3 软定时器](#553-软定时器)
	- [5.6 用户界面：键盘、鼠标和监视器](#56-用户界面键盘鼠标和监视器)
		- [5.6.1 输入软件](#561-输入软件)
		- [5.6.2 输出软件](#562-输出软件)
	- [5.8 电源管理](#58-电源管理)
		- [5.8.1 硬件问题](#581-硬件问题)
		- [5.8.2 操作系统问题](#582-操作系统问题)
		- [5.8.3 应用程序问题](#583-应用程序问题)
	- [5.10 小结](#510-小结)

# 5. 输入/输出

除了提供抽象(如进程、地址空间和文件)意外，操作系统还要控制计算机的所有I/O设备。操作系统西不想设备发送指令，捕捉中断，并处理设备的各种错误。它还应该在设备和系统的其他部分之间提供简单且易于使用的接口

设备无关性：计算机在I/O设备和系统的其他部分之间提供的接口对于所有设备都是相同的

## 5.1 I/O硬件原理

### 5.1.1 I/O设备

I/O设备大致可以分为两类：**块设备**和**字符设备**

**块设备**：把信息存储在固定大小的块中，每个块有自己的地址。所有传输以一个或多个完整的(连续的)块为单位。块设备的基本特征是每个块都能独立于其他块而读写。硬盘、蓝光光盘和USB盘是最常见的块设备。块可寻址的设备与其他设备之间并没有严格的界限

**字符设备**：以字符为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。打印机、网络接口、鼠标以及大多数与磁盘不同的设备都可看做字符设备。

这种分类方法并不完美,有些设备就没有包括进去。例如,时钟既不是块可寻址的,也不产生或接收字符流。它所做的工作就是按照预先规定好的时间间隔产生中断。内存映射的显示器也不适用于此模型。但是,块设备和宇符设备的模型具有足够的一般性,可以用作使处理I/O设备的某些操作系统软件具有设备无关性的基础。例如,文件系统只处理抽象的块设备,而把与设备相关的部分留给较低层的软件

### 5.1.2 设备控制器

I/O设备一般由机械部件和电子部件两部分组成。通常可以将这两部分分开处理,以提供更加模块化和更加通用的设计。电子部件称作**设备控制器**或**适配器**。在个人计算机上,它经常以主板上的芯片的形式出现,或者以插入(PCI)扩展槽中的印刷电路板的形式出现。机械部件则是设备本身

磁盘控制器与设备之间的接口通常是一个很低层次的接口，任务是把串行的位流转换为字节块，并进行必要的错误校正工作。字节块通常首先在控制器内部的一个缓冲区中按位进行组装，然后再对校验和进行校验并证明字节块没有错误后，再将它复制到主存中。在同样低的层次上,LCD显示器的控制器也是一个位串行设备。它从内存中读入包含待显示字符的字节,产生信号以便使相应的像素改变背光的极化方式,从而将其写到屏幕上。如果没有显示器控制器,那么操作系统程序员只能对所有像素的电场显式地进行编程。有了控制器,操作系统就可以用几个参数对控制器进行初始化,这些参数包括每行的字符数或像素数以及每屏的行数等,并让控制器实际驱动电场

### 5.1.3 内存映射I/O

每个控制器有几个寄存器用来与CPU进行通信，通过写入寄存器，操作系统可以命令设备执行操作，通过读寄存器，操作系统可以了解设备的状态。除了控制寄存器以外，许多设备还有一个操作系统可以读写的数据缓冲区。有两种方法使CPU与设备的控制寄存器和数据缓冲区进行通信

在第一个方法中,每个控制寄存器被分配一个**I/O端口号**,这是一个8位或16位的整数。所有I/O端口形成**I/O端口空间**,并且受到保护使得普通的用户程序不能对其进行访问(只有操作系统可以访问)。在这一方案中，内存地址空间和I/O地址空间是不同的

第二个方法是PDP-11引入的,它将所有控制寄存器映射到内存空间中。每个控制寄存器被分配唯一的一个内存地址,并且不会有内存被分配这一地址。这样的系统称为**内存映射I/O**。在大多数系统中,分配给控制寄存器的地址位于或者靠近地址空间的顶端。还有一种混合的方案,这一方案具有内存映射I/O的数据缓冲区,而控制寄存器则具有单独的I/O端口。优点：1.对于内存映射I/O，I/O设备驱动程序可以完全使用C语言编写，否则就要用到某些汇编代码；2.不需要特殊的保护机制来阻止用户进程执行I/O操作，可以使不同的设备驱动程序放置在不同的地址空间中，不但可以减小内核的大小，而且可以防止驱动程序之间相互干扰；3.对于内存映射I/O，可以引用内存的每一条指令也可以引用控制寄存器。缺点：1.现今大多数计算机都有某种形式的内存字高速缓存，对一个设备控制器进行高速缓存可能是灾难性的，为了避免这一情形，硬件必须能够针对每个页面有选择性的禁用高速缓存；2.如果存在一个地址空间，那么所有的内存模块和所有的I/O设备都必须检查所有的内存引用，以便了解由谁做出响应，必须采取特殊的措施使内存映射I/O工作在具有多总线的系统上

### 5.1.4 直接存储器存取

**直接存储器存取(DMA, Direct Memory Access)**

只有硬件具有DMA控制器时操作系统才能使用DMA,而大多数系统都有DMA控制器。有时DMA控制器集成到磁盘控制器和其他控制器之中,但是这样的设计要求每个设备有一个单独的DMA控制器。更加普遍的是,只有一个DMA控制器可利用(例如,在主板上),由它调控到多个设备的数据传送,而这些数据传送经常是同时发生的

无论DMA控制器在物理上处于什么地方,它都能够独立于CPU而访问系统总线。它包含若干个可以被CPU读写的寄存器,其中包括一个内存地址寄存器、一个字节计数寄存器和一个或多个控制寄存器。控制寄存器指定要使用的I/O端口、传送方向(从I/O设备读或写到I/O设备)、传送单位(每次一个字节或每次一个字)以及在一次突发传送中要传送的宇节数

DMA的**工作原理**大体如下,磁盘控制器首先从磁盘驱动器中将整块数据读到控制器的内部缓冲区中。不用DMA时控制器产生中断，CPU把控制器缓冲区中的数据读到内存中。用DMA时磁盘控制器直接把数据写到内存中，全部数据传输完毕之后产生中断。具体如下：为了解释DMA的工作原理,让我们首先看一下**没有使用DMA时**磁盘如何读。首先,控制器从磁盘驱动器串行地、一位一位地读一个块(一个或多个扇区),直到将整块信息放入控制器的内部缓冲区中。接着,它计算校验和,以保证没有读错误发生。然后控制器产生一个中断。当操作系统开始运行时,它重复地从控制器的缓冲区中一次一个字节或一个字地读取该块的信息,并将其存入内存中。**使用DMA时**,过程是不同的。首先,CPU通过设置DMA控制器的寄存器对它进行编程,所以DMA控制器知道将什么数据传送到什么地方。DMA控制器还要向磁盘控制器发出一个命令,通知它从磁盘读数据到其内部的缓冲区中,并且对校验和进行检验。如果磁盘控制器的缓冲区中的数据是有效的,那么DMA就可以开始了。DMA控制器通过在总线上发出一个读请求到磁盘控制器而发起DMA传送。这一读请求看起来与任何其他读请求是一样的,并且磁盘控制器并不知道或者并不关心它是来自CPU还是来自DMA控制器。一般情况下,要写的内存地址在总线的地址线上,所以当磁盘控制器从其内部缓冲区中读取下一个字的时候,它知道将该字写到什么地方。写到内存是另一个标准总线周期。当写操作完成时,磁盘控制器在总线上发出一个应答信号到DMA控制器。于是,DMA控制器步增要使用的内存地址,并且步减字节计数。如果字节计数仍然大于0,则重复第2步到第4步,目到字节计数到达0。此时,DMA控制器将中断CPU以便让CPU知道传送现在巳经完成了。当操作系统开始工作时,用不着将磁盘块复制到内存中,因为它已经在内存中了

**周期窃取**：DMA控制器每次一字的模式，DMA控制器请求传送一个字并且得到这个字，如果CPU也想使用总心啊，它必须等待。因为设备控制器偶尔偷偷溜入并且从CPU偷走一个临时的总线周期，从而轻微地延迟CPU。**突发模式**：DMA控制器为块模式，DMA通知设备获得总线，发起一连串的传送，然后释放总线。它比周期窃取效率更高，因为获得总线占用了时间，并且以一次总线获得的代价能够传送多个字。缺点是如果正在进行的是长时间突发传送，有可能将CPU和其他设备阻塞相当长的时间。**飞跃模式**：DMA控制器通知设备控制器直接将数据传送到主存。某些DMA控制器使用的其他模式是让设备控制器将字发送给DMA控制器,DMA控制器然后发起第2个总线请求将该字写到它应该去的任何地方。采用这种方案,每传送一个字需要一个额外的总线周期,但是更加灵活,因为它可以执行设备到设备的复制甚至是内存到内存的复制(通过首先发起一个到内存的读,然后发起一个到不同内存地址的写)

在DMA可以开始之前，磁盘首先要将数据读入到其内部的缓冲区，第一个原因是通过进行内部缓冲，磁盘控制器可以在开始传送之前检验校验和。第二个原因是,一旦磁盘传送开始工作,从磁盘读出的数据就是以固定速率到达的,而不论控制器是否准备好接收数据。如果控制器要将数据直接写到内存,则它必须为要传送的每个字取得系统总线的控制权。此时,若由于其他设备使用总线而导致总线忙(例如在突发模式中),则控制器只能等待。如果在前一个磁盘字还未被存储之前下一个磁盘字到达,控制器只能将它存放在某个地方。如果总线非常忙,控制器可能需要存储很多字,而且还要完成大量的管理工作。如果块被放入内部缓冲区,则在DMA启动前不需要使用总线,这样,控制器的设计就可以简化,因为对DMA到内存的传送没有严格的时间要求。(事实上,有些老式的控制器是直接存取内存的,其内部缓冲区设计得很小,但是当总线很忙时,一些传送有可能由于超载运行错误而被终止)

并不是所有的计算机都使用DMA。反对的论据是主CPU通常要比DMA控制器快得多,做同样的工作可以更快(当限制因素不是I/O设备的速度时)。如果CPU没有其他工作要做,让(快速的)CPU等待(慢速的)DMA控制器完成工作是无意义的。此外,去除DMA控制器而让CPU用软件做所有的工作还可以节约金钱,这一点在低端(嵌入式)计算机上十分重要

### 5.1.5 重温中断

在硬件层面，中断的工作如下所述。当一个I/O设备完成交给它的工作时，它就产生一个中断（假设操作系统已经开放中断)，它是通过在分配给它的一条总线信号线上置起信号而产生中断的。该信号被主板上的中断控制器芯片检测到，由中断控制器芯片决定做什么

如果没有其他中断悬而未决，中断控制器将立刻对中断进行处理。如果有另一个中断正在处理中，或者另一个设备在总线上具有更高优先级的一条中断请求线上同时发出中断请求，该设备将暂时不被理睬。在这种情况下，该设备将继续在总线上置起中断信号，直到得到CPU的服务。为了处理中断，中断控制器在地址线上放置一个数字表明哪个设备需要关注，并且置起一个中断cPU的信号

中断信号导致CPU停止当前正在做的工作并且开始做其他的事情。地址线上的数字被用做指向一个称为**中断向量**的表格的索引，以便读取一个新的程序计数器。这一程序计数器指向相应的中断服务过程的开始。一般情况下，陷阱和中断从这一点上看使用相同的机制，并且常常共享相同的中断向量。中断向量的位置可以硬布线到机器中，也可以在内存中的任何地方通过一个CPU寄存器(由操作系统装载)指向其起点

中断服务过程开始运行后，它立刻通过将一个确定的值写到中断控制器的某个I/O端口来对中断做出应答。这一应答告诉中断控制器可以自由地发出另一个中断。通过让CPU延迟这一应答直到它准备好处理下一个中断，就可以避免与多个几乎同时发生的中断相牵涉的竞争状态

在开始服务程序之前，硬件总是要保存一定的信息。哪些信息要保存以及将其保存到什么地方，不同的CPU之间存在巨大的差别。作为最低限度，必须保存程序计数器，这样被中断的进程才能够重新开始。在另一个极端，所有可见的寄存器和很多内部寄存器或许也要保存

将这些信息保存到什么地方是一个问题。一种选择是将其放入内部寄存器中，在需要时操作系统可以读出这些内部寄存器。这一方法的问题是，中断控制器之后无法得到应答，直到所有可能的相关信息被读出，以免第二个中断重写内部寄存器保存状态。这一策略在中断被禁止时将导致长时间的死机，并且可能丢失中断和丢失数据。因此，大多数CPU在堆栈中保存信息。然而，这种方法也有问题。首先是使用谁的堆栈。如果使用当前堆栈，则它很可能是用户进程的堆栈。堆栈指针甚至可能不是合法的，这样当硬件试图在它所指的地址处写某些字时，将导致致命错误。此外，它可能指向一个页面的末端。若干次内存写之后，页面边界可能被超出并且产生一个页面故障。在硬件中断处理期间如果发生页面故障将引起更大的问题:在何处保存状态以处理页面故障

如果使用内核堆栈，堆栈指针是合法的并且指向一个固定的页面，这样的机会将会更大一些。然而，切换到核心态可能要求改变MMU上下文，并且可能使高速缓存和TLB的大部分或全部失效。静态地或动态地重新装载所有这些东西将增加处理一个中断的时间，因而浪费CPU的时间

现代CPU大量地采用流水线并且有时还采用超标量(内部并行)。

在流水线满的时候(通常的情形)，如果出现一个中断，许多指令正处于各种不同的执行阶段，当中断出现时，程序计数器的值可能无法正确地反映已经执行过的指令和尚未执行的指令之间的边界。许多指令可能部分地执行，不同的指令完成的程度或多或少。在这种情况下，程序计数器更有可能反映的是将要被取出并压入流水线的下一条指令的地址,而不是刚刚被执行单元处理过的指令的地址

在超标量计算机上，指令可能分解成微操作，而微操作有可能乱序执行，这取决于内部资源(如功能单元和寄存器)的可用性。当中断发生时，某些很久以前启动的指令可能还没开始执行，而其他最近启动的指令可能几乎要完成了。当中断信号出现时，可能存在许多指令处于不同的完成状态，它们与程序计数器之间没有什么关系

**精确中断**：将机器留在一个明确状态的中断。特征：1.PC(程序计数器)保存在一个已知的地方；2.PC所指向的指令之前的所有指令已经完全执行；3.PC所指向的指令之后的所有指令都没有执行；4.PC所指向的指令的执行状态是已知的。注意，对于PC所指向的指令之后的那些指令来说，此处并没有禁止它们开始执行，而只是要求在中断发生之前必须撤销它们对寄存器或内存所做的任何修改。PC所指向的指令有可能已经执行了,也有可能还没有执行,然而,必须清楚适用的是哪种情况。通常，如果中断是一个I/O中断,那么指令就会还没有开始执行。然而,如果中断实际上是一个陷阱或者页面故障,那么PC一般指向导致错误的指令,所以它以后可以重新开始执行

**不精确中断**：不满足上述要求的中断。邻近程序计数器的不同指令处于不同的完成状态，老的指令不一定比新的指令完成得更多。具有不精确中断的机器通常将大量的内部状态"吐出"到堆栈中，从而使操作系统有可能判断出正在发生什么事情。重新启动机器所必需的代码通常极其复杂。此外，在每次中断发生时将大量的信息保存在内存中使得中断响应十分缓慢，而恢复则更加糟糕。这就导致具有讽刺意味的情形:由于缓慢的中断使得非常快速的超标量CPU有时并不适合实时工作

有些计算机设计成某些种类的中断和陷阱是精确的，而其他的不是。例如，可以让I/O中断是精确的，而归因于致命编程错误的陷阱是不精确的，由于在被0除之后不需要尝试重新开始运行的进程，所以这样做也不错。有些计算机具有一个位，可以设置它强迫所有的中断都是精确的。设置这一位的不利之处是，它强迫CPU仔细地将正在做的一切事情记入日志并且维护寄存器的影子副本，这样才能够在任意时刻生成精确中断。所有这些开销都对性能具有较大的影响

某些超标量计算机(例如x86系列)具有精确中断，从而使老的软件正确工作。为与精确中断保持后向兼容付出的代价是CPU内部极其复杂的中断逻辑，以便确保当中断控制器发出信号想要导致一个中断时,允许直到某一点之前的所有指令完成而不允许这一点之后的指令对机器状态产生任何重要的影响。此处付出的代价不是在时间上，而是在芯片面积和设计复杂性上。如果不是因为向后兼容的目的而要求精确中断的话，这一芯片面积就可以用于更大的片上高速缓存，从而使CPU的速度更快。另一方面，不精确中断使得操作系统更为复杂而且运行得更加缓慢,所以断定哪一种方法更好是十分困难的

## 5.2 I/O软件原理

### 5.2.1 I/O软件的目标

**设备独立性**：可以访问任意I/O设备而无需事先指定设备。是设计I/0软件时一个关键的概念。例如，读取一个文件作为输入的程序应该能够在硬盘、DVD或者USB盘上读取文件，无需为每一种不同的设备修改程序

与设备独立性密切相关的是**统一命名**这一目标。一个文件或一个设备的名字应该是一个简单的字符串或一个整数，它不应依赖于设备，所有文件和设备都采用相同的方式---路径名进行寻址。

I/O软件的另一个重要问题是**错误处理**。一般来说错误应该尽可能地在接近硬件的层面得到处理。当控制器发现了一个读错误时，如果它能够处理那么就应该自己设法纠正这一错误。如果控制器处理不了，那么设备驱动程序应当予以处理,可能只需重读一次这块数据就正确了。很多错误是偶然性的，只有在低层软件处理不了的情况下，才将错误上交高层处理。在许多情况下，错误恢复可以在低层透明地得到解决，而高层软件甚至不知道存在这一错误

另一个关键问题是**同步(阻塞)和异步(中断驱动)传输**。大多数物理I/O是异步的---CPU启动传输后便转去做其他工作，直到中断发生。如果I/O操作是阻塞的，那么用户程序就更加容易编写---在read系统调用之后，程序将自动被挂起，直到缓冲区中的数据准备好。正是操作系统使实际上是中断驱动的操作变为在用户程序看来是阻塞式的操作。然而，某些性能极高的应用程序需要控制I/O的所有细节，所以某些操作系统使异步I/O对这样的应用程序是可用的

I/O软件的另一个问题是**缓冲**。数据离开一个设备之后通常并不能直接存放到其最终的目的地。缓冲涉及大量的复制工作，并且经常对I/O性能有重大影响。

此处我们将提到的最后一个概念是**共享设备和独占设备**的问题。有些I/O设备(如磁盘)能够同时让多个用户使用。多个用户同时在同一磁盘上打开文件不会引起什么问题。独占(非共享)设备的引入也带来了各种各样的问题，如死锁。同样，操作系统必须能够处理共享设备和独占设备以避免问题发生

I/O可以采用三种根本上不同的方式来实现，分别是**程序控制I/O**、**中断驱动I/O**和**使用DMA放入I/O**

### 5.2.2 程序控制I/O

**程序控制I/O**：CPU做全部的工作，是I/O最简单的形式。十分简单但是有缺点，即直到全部I/O完成之前要占用CPU的全部时间

**轮询/忙等待**：在输出一个字符之后，CPU要不断地查询设备以了解它是否就绪准备接收另一个字符

### 5.2.3 中断驱动I/O

这种允许CPU在等待打印机变为就绪的同时做某些其他事情的方式就是使用中断。当打印字符串的系统调用被发出时,字符串缓冲区被复制到内核空间,并且一旦打印机准备好接收一个字符时就将第一个字符复制到打印机中。这时,CPU要调用调度程序,并且某个其他进程将运行。请求打印字符串的进程将被阻塞,直到整个字符串打印完

当打印机将字符打印完并且准备好接收下一个字符时,它将产生一个中断。这一中断将停止当前运行的其他进程并且保存其状态。然后,打印机中断服务过程将运行。如果没有更多的字符要打印,中断处理程序将采取某个操作将用户进程解除阻塞。否则,它将输出下一个字符，应答中断，并且返回到中断之前正在运行的进程，该进程将从其停止的地方继续运行

### 5.2.4 使用DMA的I/O

中断驱动I/O的一个明显缺点是中断发生在每个字符上。中断要花费时间,所以这一方法将浪费一定数量的CPU时间。这一问题的一种解决方法是使用DMA。此处的思路是让DMA控制器一次给打印机提供一个字符,而不必打扰CPU。本质上DMA是程序控制I/O,只是由DMA控制器而不是主CPU做全部工作。这一策略需要特殊的硬件(DMA控制器),但是使CPU获得自由从而可以在I/O期间做其他工作

DMA重大的成功是将中断的次数从打印每个字符一次减少到打印每个缓冲区一次。如果有许多字符并且中断十分缓慢,那么采用DMA可能是重要的改进。另一方面,DMA控制器通常比主CPU要慢很多。如果DMA控制器不能以全速驱动设备,或者CPU在等待DMA中断的同时没有其他事情要做,那么采用中断驱动I/O甚至采用程序控制I/O也许更好

## 5.3 I/O软件层次

I/O软件通常组织成四个层次，每一层具有一个要执行的定义明确的功能和一个定义明确的与临近层次的借口。功能与接口随系统的不同而不同，四个层次如下：

硬件-->中断处理程序-->设备驱动程序-->与设备无关的操作系统软件-->用户级I/O软件

### 5.3.1 中断处理程序

硬件中断完成之后必须在软件中执行的步骤，细节依赖于系统，因此下列某些步骤在一个特定的机器上可能是不必要的，而没有列出的步骤可能是必须的，确实发生的步骤在某些机器上可能有不同的顺序

1. 保存没有被中断硬件保存的所有寄存器(包括PSW)2. 为中断服务过程设置上下文,可能包括设置TLB、MMU和页表3. 为中断服务过程设置堆栈4. 应答中断控制器,如果不存在集中的中断控制器,则再次开放中断5. 将寄存器从它们被保存的地方(可能是某个堆栈)复制到进程表中6. 运行中断服务过程,从发出中断的设备控制器的寄存器中提取信息7. 选择下一次运行哪个进程,如果中断导致某个被阻塞的高优先级进程变为就绪,则可能选择它现在就运行8. 为下一次要运行的进程设置MMU上下文,也许还需要设置某个TLB9. 装入新进程的寄存器,包括其PSW10. 开始运行新进程。

### 5.3.2 设备驱动程序

每个设备控制器都设有某些设备寄存器用来向设备发出命令，或者设有某些设备寄存器用来读出设备的状态，或者设有这两种设备寄存器。设备寄存器的数量和命令的性质在不同设备之间有着根本性的不同，因此每个连接到计算机上的I/O设备都需要某些设备特定的代码来对其进行控制，这样的代码称为**设备驱动程序**，它一般由设备的制造商编写并随同设备一起交付。因为每一个操作系统都需要自己的驱动程序，所以设备制造商通常要为若干流行的操作系统提供驱动程序

为了访问设备的硬件(意味着访问设备控制器的寄存器),设备驱动程序通常必须是操作系统内核的一部分,至少对目前的体系结构是如此。实际上,有可能构造运行在用户空间的驱动程序,使用系统调用来读写设备寄存器。这一设计使内核与驱动程序相隔离,并且使驱动程序之间相互隔离,这样做可以消除系统崩溃的一个主要源头---有问题的驱动程序以这样或那样的方式干扰内核。对于建立高度可靠的系统而言,这绝对是正确的方向

操作系统通常将驱动程序归类于少数的类别之一。最为通用的类别是**块设备**和**字符设备**。块设备(例如磁盘)包含多个可以独立寻址的数据块,字符设备(例如键盘和打印机)则生成或接收字符流

驱动程序必须是**重入的**，这意味着一个正在运行的驱动程序必须预料到在第一次调用完成前第二次被调用

### 5.3.3 与设备无关的I/O软件

虽然I/O软件中有一些是设备特定的，但是其他部分I/O软件食欲设备无关的。设备驱动程序和与设备无关的软件之间的确切界限依赖于具体系统(和设备),因为对于一些本来应按照与设备无关方式实现的功能,出于效率和其他原因,实际上是由驱动程序来实现的。与设备无关的软件的基本功能是执行对所有设备公共的I/O功能,并且向用户层软件提供一个统一的接口

1. 设备驱动程序的统一接口

操作系统的一个主要问题是如何使所有的I/O设备和驱动程序看起来或多或少是相同的。

设备驱动程序与操作系统其余部分之间的接口这一问题的一个方面。对每一种设备类型，操作系统定义一组驱动程序必须支持的函数。驱动程序通常包含一张表格,这张表格具有针对这些函数指向驱动程序自身的指针。当驱动程序装载时,操作系统记录下这张函数指针表的地址,所以当操作系统需要调用一个函数时,它可以通过这张表格发出间接调用。这张函数指针表定义了驱动程序与操作系统其余部分之闭的接口。给定类型(磁盘、打印机等)的所有设备都必须服从这一要求

如何给I/O设备命名是统一接口问题的另一个方面。与设备无关的软件要负责把符号化的设备名映射到适当的驱动程序上。例如,在UNIX系统中,像/dev/disk0这样的设备名唯一确定了一个特殊文件的i节点,这个i节点包含了**主设备号**,主设备号用于定位相应的驱动程序。i节点还包含**次设备号**,次设备号作为参数传递给驱动程序,用来确定要读或写的具体单元。所有设备都具有主设备号和次设备号,并且所有驱动程序都是通过使用主设备号来选择驱动程序而得到访问。与设备命名密切相关的是设备保护。系统如何防止无权访问设备的用户访问设备呢?在UNIX和Windows中,设备是作为命名对象出现在文件系统中的,这意味着针对文件的常规的保护规则也适用于I/O设备。系统管理员可以为每一个设备设置适当的访问权限

2. 缓冲

在用户空间中创建缓冲区：比直接读效率高，但是当一个字符到来时，缓冲区有可能被分页而调出了内存。解决方法是将缓冲区锁定在内存中，但如果许多进程都在内存中锁定页面，那么可用页面池就会收缩并且系统性能将下降

在内核空间中创建一个缓冲区并且让中断处理程序将字符放到这个缓冲区中，当该缓冲区被填满时，将包含用户缓冲区的页面调入内存(如果需要的话)，并且在一次操作中将内核缓冲区的内容复制到用户缓冲区中。这一方法的效率要高很多。问题在于正当包含用户缓冲区的页面从磁盘调入内存的时候有新的字符到来，因为缓冲区已满，所以没有地方放置这些新来的字符。一种解决问题的方法是使用第二个内核缓冲区，第一个缓冲区填满之后，在它被清空之前，使员工第二个缓冲区。当第二个缓冲区被填满时，就可以将它复制给用户(假设用户已经请求它)。当第二个缓冲区正在复制到用户空间的时候，第一个缓冲区可以用来接收新的字符。以这样的方法，两个缓冲区轮流使用：当一个缓冲区正在被复制到用户空间的时候，另一个缓冲区正在收集新的输入，像这样的缓冲模式称为**双缓冲**

缓冲的另一种常用形式是**循环缓冲区**。它由一个内存区域和两个指针组成。一个指针指向下一个空闲的字,新的数据可以放置到此处。另一个指针指向缓冲区中数据的第一个字,该字尚未被取走。在许多情况下,当添加新的数据时(例如刚刚从网络到来),硬件将推进第一个指针,而操作系统在取走并处理数据时推进第二个指针。两个指针都是环绕的,当它们到达顶部时将回到底部

缓冲的缺点：如果数据被缓冲太多次，性能就会降低。所有的复制操作都会在很大程度上降低传输速率，因为所有这些步骤必须有序地发生

3. 错误报告

错误在I/O上下文中比在其他上下文中要常见得多。当错误发生时,操作系统必须尽最大努力对它们进行处理。许多错误是设备特定的并且必须由适当的驱动程序来处理,但是错误处理的框架是设备无关的。

一种类型的I/O错误是编程错误,这些错误发生在一个进程请求某些不可能的事情时,例如写一个输入设备(键盘、扫描仪、鼠标等)或者读一个输出设备(打印机、绘图仪等)。其他的错误包括提供了一个无效的缓视区地址或者其他参数,以及指定了一个无效的设备(例如,当系统只有两块磁盘时指定了磁盘3),如此等等。在这些错误上采取的行动是直截了当的:只是将一个错误代码报告返回给调用者。

另一种类型的错误是实际的I/O错误,例如,试图写一个已经被破坏的磁盘块,或者试图读一个已经关机的便携式摄像机。在这些情形中,应该由驱动程序决定做什么。如果驱动程序不知道做什么,它应该将问题向上传递,返回给与设备无关的软件。

软件要做的事情取决于环境和错误的本质。如果是一个简单的读错误并且存在一个交互式的用户可利用,那么它就可以显示一个对话框来询问用户做什么。选项可能包括重试一定的次数,忽略错误,或者杀死调用进程。如果没有用户可利用,唯一的实际选择或许就是以一个错误代码让系统调用失败。然而,某些错误不能以这样的方式来处理。例如,关键的数据结构(如根目录或空阮块列表)可能已经被破坏,在这种情况下,系统也许只好显示一条错误消息并且终止,并不存在多少其他事情可以做

4. 分配与释放专用设备

某些设备,例如打印机,在任意给定的时刻只能由一个进程使用。这就要求操作系统对设备使用的请求进行检查,并且根据被请求的设备是否可用来接受或者拒绝这些请求。

处理这些请求的一种简单方法是要求进程在代表设备的特殊文件上直接执行open操作。如果设备是不可用的,那么open就会失败。于是就关闭这样的一个专用设备,然后将其释放。

一种代替的方法是对于请求和释放专用设备要有特殊的机制。试图得到不可用的设备可以将调用者阻塞,而不是让其失败。阻塞的进程被放入一个队列。迟早被请求的设备会变得可用,这时就可以让队列中的第一个进程得到该设备并且继续执行

5. 提供与设备无关的块大小

不同的磁盘可能具有不同的扇区大小。应该由与设备无关的软件来隐藏这一事实并且向高层提供一个统一的块大小,例如,将若干个扇区当作一个逻辑块。这样,高层软件就只需处理抽象的设备,这些抽象设备全部都使用相同的逻辑块大小,与物理扇区的大小无关。类似地,某些字符设备(如鼠标)一次一个字节地交付它们的数据,而其他的设备(如网络接口)则以较大的单位交付它们的数据，这些差异也可以被隐藏起来

### 5.3.4 用户空间的I/O软件

尽管大部分I/O软件都在操作系统内部，但是仍然有一小部分在用户空间，包括与用户程序连接在一起的库，甚至完全运行于内核之外的程序。系统调用(包括I/O系统调用)通常由库过程实现。

并非所有的用户层I/O软件都是由库过程组成的。另一个重要的类别是**假脱机系统**。假脱机是多道程序设计系统中处理独占I/O设备的一种方法。考虑一种典型的假脱机设备:打印机。尽管在技术上可以十分容易地让任何用户进程打开表示该打印机的字符特殊文件,但是假如一个进程打开它,然后很长时间不使用,则其他进程都无法打印。假脱机方法是创建一个特殊进程,称为**守护进程**,以及一个特殊目录,称为**假脱机目录**。一个进程要打印一个文件时,首先生成要打印的整个文件,并且将其放在假脱机目录下。由守护进程打印该目录下的文件、该进程是允许使用打印机特殊文件的唯一进程。通过保护特殊文件来防止用户直接使用,可以解决某些进程不必要地长期空占打印机的问题

I/O系统的层次即主要功能如下：

|层次|I/O功能|
|:-:|:-:|
|用户进程|产生I/O请求；对I/O进行格式化；假脱机|
|与设备无关的软件|命名、保护、分块、缓冲、分配|
|设备驱动程序|设置设备寄存器；检查状态|
|中断处理程序|当I/O完成时唤醒驱动程序|
|硬件|执行I/O操作|

## 5.4 盘

### 5.4.1 盘的硬件

盘具有多种多样的类型。最为常用的是磁盘,它们具有读写速度同样快的特点,这使得它们适合作为辅助存储器(用于分页、文件系统等)。这些盘的阵列有时用来提供高可靠性的存储器。对于程序、数据和电影的发行而言,光盘(DVD和蓝光光盘)也非常重要。最后,固态盘越来越流行,它们速度快些且不包含运动的部件。在下面几节中,我们将讨论磁盘,以此作为硬件的例子,然后对磁盘设备的软件进行一般性的描述

1. 磁盘

磁盘被组织成柱面,每一个柱面包含若干磁道,磁道数与垂直堆叠的磁头个数相同。磁道又被分成若干扇区,软盘上大约每条磁道有8~32个扇区,硬盘上每条磁道上扇区的数目可以多几百个。磁头数大约是1~16个

老式的磁盘只有少量的电子设备,它们只是传送简单的串行位流。在这些磁盘上,控制器做了大部分的工作。在其他磁盘上,特别是在**IDE(集成驱动电子设备)和SATA(串行ATA**)盘上,磁盘驱动器本身包含一个微控制器,该微控制器承担了大量的工作并且允许实际的控制器发出一组高级命令。控制器经常做磁道高速缓存、坏块重映射以及更多的工作。对磁盘驱动程序有重要意义的一个设备特性是:控制器是否可以同时控制两个或多个驱动器进行寻道,这就是**重叠寻道**。当控制器和软件等待一个驱动器完成寻道时,控制器可以同时启动另一个驱动器进行寻道。许多控制器也可以在一个驱动器上进行读写操作,与此同时再对另一个或多个其他驱动器进行寻道,但是软盘控制器不能在两个驱动器上同时进行读写操作。(读写数据要求控制器在微秒级时间尺度传输数据,所以一次传输就用完了控制器大部分的计算能力。)对于具有集成控制器的硬盘而言情况就不同了,在具有一个以上这种硬盘驱动器的系统上,它们能够同时操作,至少在磁盘与控制器的缓冲存储器之间进行数据传输的限度之内是这样。然而,在控制器与主存之间可能同时只有一次传输。同时执行两个或多个操作的能力极大地降低了平均存取时间

现代磁盘被划分成环带，外层的环带比内层的环带拥有更多的扇区。为了隐藏每个磁道有多少扇区的细节,大多数现代磁盘都有一个虚拟几何规格呈现给操作系统。软件在工作时仿佛存在着x个柱面、y个磁头、每磁道z个扇区,而控制器则将对(x,y,z)的请求重映射到实际的柱面、磁头和扇区。对于PC而言,上述三个参数的最大值常常是(65535,16,63),这是因为需要与最初IBM PC的限制向后养容。在IBM PC器上,使用16位、4位和6位的字段来设定这些参数,其中柱面和扇区从1开始编号,磁头从0开始编号。根据这些参数以及每个扇区3512字节可知,磁盘最大可能的容量是31.5GB。为突破这一限制,所有现代磁盘现在都支持一种称为**逻辑块寻址(LBA**)的系统,在这样的系统中,磁盘扇区从0开始连续编号,而不管磁盘的几何规格如何

2. RAID(廉价磁盘冗余阵列)

RAID：廉价磁盘冗余阵列，使用并行I/O改进磁盘性能；与之相对应的是SLED(单个大容量昂贵磁盘)

RAID的**基本思想**是将一个装满了磁盘的盒子安装到计算机(通常是一个大型服务器)上,用RAID控制器替换磁盘控制器卡,将数据复制到整个RAID上,然后继续常规的操作。换言之,对操作系统而言一个RAID应该看起来就像是一个SLED,但是具有更好的性能和更好的可靠性。由于SCSI盘具有良好的性能、较低的价格并且在单个控制器上能够容纳多达7个驱动器(对宽型SCSI而言是15个),很自然地大多数RAID由一个RAID SCSI控制器加上一个装满了SCSI盘的盒子组成而对操作系统而言这似乎就是一个大容量磁盘。以这样的方法,不需要软件做任何修改就可以使用RAID,对于许多系统管理员来说这可是一大卖点。除了对软件而言看起来就像是一个磁盘以外,所有的RAID都具有同样的**特性**,那就是将数据分布在全部驱动器上,这样就可以并行操作。Patterson等人为这样的操作定义了几种不同的模式。如今,大多数制造商将七种标准配置称为0级RAID到6级RAID。此外,还有少许其他的辅助层级,我们就不讨论了。"层级"这一术语多少有一些用词不当,因为此处不存在分层结构,它们只是可能的七种不同组织形式而已

### 5.4.2 磁盘格式化

硬盘由一叠铝的、合金的或玻璃的盘片组成,典型的直径为3.5英寸,在每个盘片上沉积着薄薄的可磁化的金属氧化物。在制造出来之后,磁盘上不存在任何信息。在磁盘能够使用之前,每个盘片必须经受由软件完成的**低级格式化**。该格式包含一系列同心的磁道,每个磁道包含若干数目的扇区,扇区间存在短的间隙。一个扇区的格式为前导码+数据+ECC。

前导码以一定的位模式开始,位模式使硬件得以识别扇区的开始。前导码还包含柱面与扇区号以及某些其他信息。数据部分的大小是由低级格式化程序决定的,大多数磁盘使用512字节的扇区。ECC域包含冗余信息,可以用来恢复读错误。该域的大小和内容随生产商的不同而不同,它取决于设计者为了更高的可靠性愿意放弃多少磁盘空间以及控制器能够处理的ECC编码有多复杂。16字节的ECC域并不是罕见的。此外,所有硬盘都分配有桅些数目的备用扇区,用来取代具有制造瑕疵的扇区

在设置低级格式时,每个磁道上第0扇区的位置与前一个磁道存在偏移。这一偏移称为**柱面斜进**,这样做是为了改进性能,想法是让磁盘在一次连续的操作中读取多个磁道而不丢失数据。像柱面斜进一样也存在着**磁头斜进**，但是磁头斜进并不是很大，通常远小于一个扇区的时间

低级格式化的结果是磁盘容量减少,减少的量取决于前导码、扇区间间隙和ECC的大小以及保留的备用扇区的数目。通常格式化的容量比未格式化的容量低20%。备用扇区不记计入格式化的容量,所以一种给定类型的所有磁盘在出厂时具有完全相同的容量,与它们实际具有多少坏扇区无关(如果坏屋区的数目超出了备用扇区的数目,则该驱动器是不合格的,不会出厂)

关于磁盘容量存在着相当大的混淆,这是因为某些制造商广告宣传的是未格式化的容量,从而使他们的驱动器看起来比实际的容量要大。例如,考虑一个未格式化容量为$200*10^9$字节的驱动器，它或许是作为200GB的磁盘销售的。然而,格式化之后,也许只有$170*10^9$字节可用于存放数据。使这一混淆进一步加剧的是操作系统可能将这一容量报告为158GB,而不是170GB,因为软件把1GB看作$2^{30}$(1 073 741 824)字节,而不是$10^9$(1 000 000 000)字节。如果将其报告为158GiB或许更好一些d

格式化还对性能产生影响。如果一个10 000RPM的磁盘每个磁道有300个扇区,每个扇区512字节,那么用6ms可以读出一个磁道上的153 600字节,使数据率为25 600 000字节/秒或24.4MB/s。不论引入什么种类的接口,都不可能比这个速度更快,即便是80MB/s或160MB/s的SCSI接口也不行。实际上,以这一速率连续地读磁盘要求控制器中有一个大容量的缓冲区。例如,考虑一个控制器,它具有一个扇区的缓冲区,该控制器接到一条命令要读两个连续的扇区。当从磁盘上读出第一个扇区并做了ECC计算之后,数据必须传送到主存中。就在传送正在进行时,下一个扇区将从磁头下通过。当完成了向主存的复制时,控制器将不得不等待几乎一整周的旋转时间才能等到第二个扇区再次回来。通过在格式化磁盘时以交错方式对扇区进行编号可以消除这一问题。**单交错**：编号连续的扇区位置间隔一个别的扇区,它可以在连续的扇区之间给控制器以喘息的空间以便将缓冲区复制到主存。**双交错**：如果复制过程非常慢，可能需要双交错，编号连续的扇区位置间隔两个别的扇区。如果控制器拥有的缓冲区只有一个扇区,那么从缓冲区到主存的复制无论是由控制器完成还是由主CPU或者DMA心片完成都无关紧要,都要花费某些时间。为了避免需要交错,控制器应该能够对整个磁道进行缓存。大多数现代控制器都能够对多个整磁道进行缓冲

在低级格式化完成之后,要对磁盘进行分区。在逻辑上,每个分区就像是一个独立的磁盘。分区对于实现多个操作系统共存是必需的。此外,在某些情况下,分区可以用来进行交换。在x86和大多数其他计算机上,0扇区包含**主引导记录(MBR)**,它包含某些引导代码以及处在扇区未尾的分区表。因为在大多数系统中MBR分区表项限于32位,所以对于512B扇区的磁盘而言,能够支持的最大磁盘大小是2TB。由于这一原因,大多数操作系统现在支持新的**GPT(GUID分区表)**,它可以支持的磁盘大小高达9.4ZB。在x86上,MBR分区表具有四个分区的空间。如果这四个分区都用于Windows,那么它们将被称为C:、D:、E:和F:,并且作为单独的驱动器对待。如果它们中有三个用于Windows一个用于UNIX,那么Windows会将它的分区称为C:、D:和E:。如果添加一个USB驱动器,它将是F:。为了能够从硬盘引导，在分区表中必须有一个分区被标记为活动的

在准备一块磁盘以便于使用的最后一步是对每一个分区分别执行一次**高级格式化**。这一操作要设置一个引导块、空闲存储管理(空闲列表或位图)、根目录和一个空文件系统。这一操作还要将一个代码设置在分区表项中,以表明在分区中使用的是哪个文件系统,因为许多操作系统支持多个兼容的文件系统(由于历史原因)。这时,系统就可以引导了

当电源打开时,BIOS最先运行,它读入主引导记录并跳转到主引导记录。然后这一引导程序进行检查以了解哪个分区是活动的。引导扇区包含一个小的程序,它一般会装入一个较大的引导程序装载器,该引导程序装载器将搜索文件系统以找到操作系统内核。该程序被装入内存并执行

### 5.4.3 磁盘臂调度算法

考虑读或者写一个磁盘块需要多长时间，这个时间由以下三个因素决定：1.寻道时间(将磁盘臂移动到适当的柱面上所需的时间)；2.旋转延迟(等待适当扇区旋转到磁头下所需的时间)；3.实际数据传输时间。对大多数磁盘而言，寻道时间与另外两个时间相比占主导地位，所以减少平均寻道时间可以充分地改善系统性能

**先来先服务(FCFS)**：磁盘驱动程序每次接收一个请求并按照接受顺序完成请求。很难优化寻道时间。许多磁盘驱动程序都维护着一张表,该表按柱面号索引,每一柱面的未完成的请求组成一个链表,链表头存放在表的相应表目中。给定这种数据结构,我们可以改进先来先服务调度算法

**最短寻道优先(SSF)**：下一次总是处理与磁头距离最近的请求以使寻道时间最小化。存在一个问题，如果磁盘负载很重，那么大部分时间磁盘臂将停留在磁盘的中部区域，而两端极端区域的请求将不得不等待，直到负载中的统计波动使得中部区域没有请求为止。远离中部区域的请求得到的服务很差，因此获得最小响应时间的目标和公平性之间存在着冲突

**电梯算法**：磁盘臂保持按一个方向移动，直到在该方向上没有请求为止，然后改变方向。需要软件维护一个二进制位，即当前方向位:UP或是DOWN。当一个请求处理完之后,磁盘的驱动程序检查该位,如果是UP,磁盘臂移至下一个更高的未完成的请求。如果更高的位置没有未完成的请求,则方向位取反。当方向位设置为DOWN时,同时存在一个低位置的请求,则移向该位置。如果不存在未决的请求,那么它只是停止并等待。通常电梯算法不如SSF算法，一个优良特性是对任意的一组给定请求，磁盘臂移动总次数的上界是固定的：正好是柱面数的两倍。对这个算法稍加改进可以在响应时间上具有更小的变异,方法是总是按相同的方向进行扫描。当处理完最高编号柱面上未完成的请求之后,磁盘臂移动到具有未完成的请求的最低编号的柱面,然后继续沿向上的方向移动。实际上,这相当于将最低编号的柱面看作最高编号的柱面之上的相邻柱面

某些磁盘控制器提供了一种方法供软件检查磁头下方的当前扇区号。对于这种磁盘控制器,还可以进行另一种优化。如果针对同一柱面有两个或多个请求正等待处理,驱动程序可以发出请求读写下一次要通过磁头的扇区。注意,当一个柱面有多条磁道时,相继的请求可能针对不同的磁道,故没有任何代价。因为选择磁头既不需要移动磁盘臂也没有旋转延迟,所以控制器几乎可以立即选择任意磁头。

如果磁盘具有寻道时间比旋转延迟快很多的特性,那么应该使用不同的优化策略。未完成的请求应该按扇区号排序,并且当下一个扇区就要通过磁头的时候,磁盘臂应该飞快地移动到正确的磁道上对其进行读或者写。

对于现代硬盘,寻道和旋转延迟是如此影响性能,所以一次只读取一个或两个扇区的效率是非常低下的。由于这个原因,许多磁盘控制器总是读出多个扇区并对其进行**高速缓存**,即使只请求一个扇区时也是如此。典型地,读一个扇区的任何请求将导致该扇区和当前磁道的多个或者所有剩余的扇区被读出,读出的扇区数取决于控制器的高速缓存中有多少可用的空间。高速缓存的使用是由控制器动态地决定的。在最简单的模式下,高速缓存被分成两个区段,一个用于读,一个用于写。如果后来的读操作可以用控制器的高速缓存来满足,那么就可以立即返回被请求的数据。值得注意的是,磁盘控制器的高速缓存完全独立于操作系统的高速缓存。控制器的高速缓存通常保存还没有实际被请求的块,但是这对于读操作是很便利的,因为它们只是作为某些其他读操作的附带效应而恰巧要在磁头下通过。与之相反;操作系统所维护的任何高速缓存由显式地读出的块组成,并且操作系统认为它们在较近的将来可能再次需要(例如,保存目录块的一个磁盘块)

当同一个控制器上有多个驱动器时,操作系统应该为每个驱动器都单独地维护一个未完成的请求表。一旦任何一个驱动器空闲下来,就应该发出一个寻道请求将磁盘臂移到下一个将被请求的柱面处(假设控制器允许重叠寻道)。当前传输结束时,将检查是否有驱动器的磁盘臂位于正确的柱面上。如果存在一个或多个这样的驱动器,则在磁盘臂已经位于正确柱面处的驱动器上开始下一次传输。如果没有驱动器的磁盘臂处于正确的位置,则驱动程序在刚刚完成传输的驱动器上发出一个新的寻道命令并且等待,直到下一次中断到来时检查哪一个磁盘臂首先到达了目标位置。

上面所有的磁盘调度算法都是默认地假设实际磁盘的几何规格与虚拟几何规格相同,认识到这一点十分重要。如果不是这样,那么调度磁盘请求就毫无意义,因为操作系统实际上不能断定柱面40与柱面200哪一个与柱面39更接近。另一方面,如果磁盘控制器能够接收多个未完成的请求,它就可以在内部使用这些调度算法。在这样的情况下,算法仍然是有效的,但是低一个层次,局限在控制器内部

### 5.4.4 错误处理

磁盘制造时的瑕疵会引入坏扇区,也就是说,扇区不能正确地读回刚刚写到其上的值。如果瑕疲非常小,比如说只有几位,那么使用坏扇区并且每次只是让ECC校正错误是可能的。如果瑕疵较大,那么错误就不可能被掩盖。对于坏块存在两种一般的处理方法:在控制器中对它们进行处理或者在操作系统中对它们进行处理

1. 在控制器中对坏块进行处理

磁盘在从工厂出厂之前要进行测试,并且将一个坏扇区列表写在磁盘上。对于每一个坏扇区,用一个备用扇区替换它。有两种方法进行这样的替换。一种方法是控制器将备用扇区之一重映射为坏扇区。另一种方法是将坏扇区之后的所有扇区向上移动一个扇区。在这两种情况下,控制器都必须知道哪个扇区是哪个扇区。它叮以通过内部的表来跟踪这一信息(每个磁道一张表),或者通过重写前导码来给出重映射的扇区号。如果是重写前导码,那么第二种方法就要做更多的工作(因为移动后的扇区的前导码必须重写),但是最终会提供更好的性能,因为整个磁道仍然可以在旋转一周中读出

驱动器安装之后在正常工作期间也会出现错误。在遇到ECC不能处理的锦误时,第一道防线只是试图再次读。某些读错误是瞬时性的,也就是说是由磁头下的灰尘导致的,在第二次尝试时错误就消失了。如果控制器注意到它在某个扇区遇到重复性的错误,那么可以在该扇区完全死掉之前切换到一个备用扇区,这样就不会丢失数据并且操作系统和用户甚至都不会注意到这一问题。通常使用的是将坏扇区映射到备用扇区,因为其他扇区此刻可能包含数据。而移动后面的所有的扇区不但要重写前导码,还要复制所有的数据

2. 在操作系统中对坏块进行处理

如果控制器不具有透明地重映射扇区的能力,那么操作系统必须在软件中做同样的事情。这意味着操作系统必须首先获得一个坏扇区列表,或者是通过从磁盔中读出该列表,或者只是由它自己测试整个磁盘。一旦操作系统知道哪些扇区是坏的,它就可以建立重映射表。如果由操作系统处理重映射,那么它必须确保坏扇区不出现在任何文件中,并且不出现在空闲列表或位图中。做到这一点的一种方法是创建一个包含所有坏扇区的秘密的文件。如果该文件不被加入文件系统,用户就不会意外地读到它(或者更糟粕地释放它)

然而,还存在另一个问题:**备份**。如果磁盘是一个文件一个文件地做备份,那么非常重要的是备份实用程序不去尝试复制坏块文件。为了防止发生这样的事情,操作系统必须很好地隐藏坏块文件,以至于备份实用程序也不能发现它。如果磁盘是一个扇区一个扇区地做备份而不是一个文件一个文件地做备份,那么在备份期间防止读错误是十分困难的,如果不是不可能的话。唯一的希望是备份程序具有足够的智能,在读失败10次后放弃并且继续下一个扇区

坏扇区不是唯一的错误来源,也可能发生磁盘臂中的机械故障引起的**寻道错误**。控制器内部跟踪着磁盘臂的位置,为了执行寻道,它发出一系列脉冲给磁盘臂电机,每个柱面一个脉冲,这样将磁盘臂移到新的柱面。当磁盘臂移到其目标位置时,控制器从下一个扇区的前导码中读出实际的柱面号。如果磁盘臂在错误的位置上,则发生寻道错误。大多数硬盘控制器可以目动纠正寻道错误。

控制器实际是一个专用的小计算机,它有软件、变量、缓冲区,偶尔还出现故障。有时一个不寻常的事件序列就可能引发一个故障,导致控制器陷入一个循环或失去对正在做的工作的跟踪。控制器的设计者通常考虑到最坏的情形,在芯片上提供了一个引脚,当该引脚被置起时,迫使控制器忘记它正在做的任何事情并且将其自身复位。如果其他方法都失败了,磁盘驱动程序可以设置一个控制位以触发该信号,将控制器复位。如果还不成功,驱动程序所能做的就是打印一条消息并且放弃

### 5.4.5 稳定存储器

**稳定存储器**：一个在软件中实现的磁盘子系统，具有如下特性：当一个写命令发给它时,磁盘要么正确地写数据,要么什么也不做,让现有的数据完整无缺地留下。目标是不惜一切代价保持磁盘的一致性。

对于可能发生的错误的模型：该模型假设在磁盘写一个块(一个或多个扇区)时,写操作要么是正确的,要么是错误的,并且该错误可以在随后的读操作中通过检查ECC域的值检测出来。该模型假设错误数据有正确的ECC数据的概率和一个被正确写入的扇区自发地变坏并且变得不可读的概率可以忽略不计。该模型还假设CPU可能出故障,在这样的情况下只能停机。在出现故障的时刻任何处于进行中的磁盘写操作也会停止,导致不正确的数据写在一个扇区中并且后来可能会检测到不正确的ECC。在所有这些情况下,稳定存储器就写操作而言可以提供100%的可靠性,要么就正确地工作,要么就让旧的数据原封不动。当然它不能对物理灾难提供保护

稳定存储器使用一对完全相同的磁盘,对应的块一同工作以形成一个无差错的块,当不存在错误时,在两个驱动器上对应的块是相同的,读取任意一个都可以得到相同的结果。为了达到这一目的,定义了下述三种操作:1.**稳定写**：稳定写首先将块写到驱动器1上,然后将其读回以校验写的是正确的。如果写的不正确,那么就再次做写和重读操作,一直到n次,直到正常为止。如果经过n次连续的失败之后,就将该块重映射到一个备用块上,并且重复写和重读操作直到成功为止,无论要尝试多少个备用块。在对驱动器1的写成功之后,对驱动器2上对应的块进行写和重读,如果需要的话就重复这样的操作,直到最后成功为止。如果不存在CPU崩溃,那么当稳定写完成后,块就正确地被写到两个驱动器上,并一在两个驱动器上得到校验；2.**稳定读**：稳定读首先从驱动器1上读取块。如果这一操作产生错误的ECC,则再次尝试读操作,一直到n次。如果所有这些操作都给出错误的ECC,则从驱动器2上读取对应的数据块。给定一个成动的稳定写为数据块留下两个可靠的副本这样的事实,并且我们假设在合理的时间间隔内相同的块在两个驱动器上自发地变坏的概率可以忽略不计,那么稳定读就总是成功的；3.**崩溃恢复**：崩溃之后,恢复程序扫描两个磁盘,比较对应的块。如果一对块都是好的并且是相同的,就什么都不做。如果其中一个具有ECC错误,那么坏块就用对应的好块来覆盖。如果一对块都是好的但是不相同,那么就将驱动器1上的块写到驱动器2上

如果不存在CPU崩溃,那么这一方法总是可行的,因为稳定写总是对每个块写下两个有效的副本,并且假设自发的错误决不会在相同的时刻发生在两个对应的块上。如果在稳定写期间出现**CPU崩溃**会怎么样取决于崩溃发生的精确时间，有5种可能性：1.CPU崩溃发生在写块的两个副本之前。在恢复的时候,什么都不用修改而旧的值将继续存在,这是允许的；2.CPU崩溃发生在写驱动器1期间,破坏了该块的内容。然而恢复程序能够检测出这一错误,并且从驱动器2恢复驱动器1上的块。因此,这一崩溃的影响被消除并且旧的状态完全被恢复；3.CPU崩溃发生在写完驱动器1之后但是还没有写驱动器2之前。此时已经过了无法复原的时刻:恢复程序将块从驱动器1复制到驱动器2上，写是成功的；4.CPU崩溃发生在写驱动器2期间，破坏了该块的内容。在恢复期间用好的块覆盖坏的块,两个块的最终取值都是新的；5.CPU崩溃发生在写完驱动器2之后。恢复程序看到两个块是相同的,所以什么都不用修改并且在此处写也是成功的

## 5.5 时钟

**时钟**又称为**定时器**，时钟负责维护时间，并且防止一个进程垄断CPU，此外还有其他的功能。时钟软件可以采用设备驱动程序的形式，尽管时钟既不像磁盘那样是一个块设备，也不像鼠标那样是一个字符设备

### 5.5.1 时钟硬件

在计算机里通常使用两种类型的时钟，比较简单的时钟被连接到110V或220V的电源线上，这样每个电压周期产生一个中断，频率是50Hz或60Hz。这些时钟过去曾经占据统治地位，但是如今却非常罕见。另一种类型的时钟由三个部件构成:晶体振荡器、计数器和存储寄存器。计数器在每一个脉冲递减，存储寄存器用于加载计数器。当把一块石英晶体适当地切割并且安装在一定的电压之下时,它就可以产生非常精确的周期性信号,典型的频率范围是几百兆赫兹,具体的频率值与所选的晶体有关。使用电子器件可以将这一基础信号乘以一个小的整数来获得高达1000MHz甚至更高的频率。在任何一台计算机里通常都可以找到至少一个这样的电路，它给计算机的各种电路提供同步信号。该信号被送到计数器，使其递减计数至0。当计数器变为0时，产生一个CPU中断

可编程时钟通常具有几种**操作模式**。**一次完成模式**：当时钟启动时，它把存储寄存器的值复制到计数器中，然后，来自晶体的每一个脉冲使计数器减1。当计数器变为0时，产生一个中断，并停止工作,直到软件再一次显式地启动它。**方波模式**：当计数器变为0并且产生中断之后,存储寄存器的值自动复制到计数器中，并且整个过程无限期地再次重复下去。这些周期性的中断称为**时钟滴答**

优点：中断频率可以由软件控制。可编程时钟芯片通常包含两个或三个独立的可编程时钟，并且还具有许多其他选项(如用正计时代替倒计时、屏蔽中断等)

### 5.5.2 时钟软件

时钟硬件所做的全部工作是根据已知的时间间隔产生中断，涉及时间的其他所有工作都必须由软件-时钟驱动程序完成。时钟驱动程序的确切任务因操作系统而异，但通常包含下面的大多数任务：1.维护日时间；2.防止进程超时运行；3.对CPU的使用情况记账；4.处理用户进程提出的alarm系统调用；5.为系统本身的各个部分提供监视定时器；6.完成概要剖析、监视和统计信息收集

1. 维护日时间

维持正确的日时间，也称为实际时间。需要注意计数器的数据溢出问题，有三种方法解决。

第一种方法是使用64位的计数器，但是这样会使维护计数器的代价变得很高；第二种方法是以秒为单位维护日时间，使用一个辅助计数器来对时钟滴答计数，直到累计至完整的一秒(这种方法可以工作到22世纪)；第三种方法是对时钟滴答计数，但是这一计数工作是相对于系统引导的时间开始，而不是相对一一个固定的外部时间。当读入备份时钟或者用户输入实际时间时，系统引导时间就从当前日期开始计算，并且以任何方便的形式存放在内存中

2. 防止进程超时运行

每当启动一个进程时，调度程序就将一个计数器初始化为以时钟滴答为单位的该进程时间片的取值。每次时钟中断时，时钟驱动程序将时间片计数器减1。当计数器变为0时，时钟驱动程序调用调度程序以激活另一个进程

3. 对CPU的使用情况记账(即记录每个进程总共运行的时间)

最精确的记账方法是，每当一个进程启动时，便启动一个不同于主系统定时器的辅助定时器。当进程终止时,读出这个定时器的值就可以知道该进程运行了多长时间。为了正确地记账，当中断发生时应该将辅助定时器保存起来，中断结束后再将其恢复

一个不太精确但更加简单的记账方法是在一个全局变量中维护一个指针，该指针指向进程表中当前运行的进程的表项。在每一个时钟滴答，使当前进程的表项中的一个域加1。通过这一方法，每个时钟滴答由在该滴答时刻运行的进程"付费"。这一策略的一个小问题是:如果在一个进程运行过程中多次发生中断，即使该进程没有做多少工作，它仍然要为整个滴答付费。由于在中断期间恰当地对CPU进行记账的方法代价过于昂贵，因此很少使用

4. 处理用户进程提出的alarm系统调用

如果时钟驱动程序拥有足够的时钟，它就可以为每个请求设置一个单独的时钟。如果不是这样的情况，它就必须用一个物理时钟来模拟多个虚拟时钟。一种方法是维护一张表，将所有未完成的定时器的信号时刻记入表中，还要维护一个变量给出下一个信号的时刻。每当日时间更新时,时钟驱动程序进行检查以了解最近的信号是否已经发生。如果是的话，则在表中搜索下一个要发生的信号的时刻

在时钟中断期间，时钟驱动器需要将实际时间+1，将时间片-1并检查它是否为0，对CPU记账，以及将报警计数器-1

5. 为系统本身的各个部分提供监视定时器

**监视定时器(watchdog timer, 看门狗定时器)**：操作系统的组成部分设置的定时器，经常用来检测死机之类的问题(特别是在嵌入式设备中)。例如监视定时器可以用来对停止运行的系统进行复位。在系统运行时，它会定期复位定时器，所以定时器永远不会过期。既然如此，定时器过期则证明系统已经很长时间没有运行了,这就会导致纠正的行动-例如全系统复位

6. 完成概要剖析、监视和统计信息收集

时钟最后要做的事情是**剖析**。某些操作系统提供了一种机制，通过该机制用户程序可以让系统构造它的程序计数器的一个直方图，这样它就可以了解时间花在了什么地方。当剖析是可能的事情时，在每一时钟滴答驱动程序都要检查当前进程是否正在被进行剖析，如果是，则计算对应于当前程序计数器的区间号(一段地址范围)，然后将该区间的值+1。这一机制也可用来对系统本身进行剖析

### 5.5.3 软定时器

大多数计算机拥有辅助可编程时钟，可以设置它以程序需要的任何速率引发定时器中断。该定时器是主系统定时器以外的，而主系统定时器的功能已经在上面讲述了。只要中断频率比较低，将这个辅助定时器用于应用程序特定的目的就不存在任何问题。

一般而言，有两种方法管理I/O:**中断和轮询**。中断具有较低的响应时间，也就是说，中断在事件本身之后立即发生，具有很少的延迟或者没有延迟R。另一方面，对于现代CPU而言,由于需要上下文切换以及对于流水线、TLB和高速缓存的影响，中断具有相当大的开销。替代中断的是让应用程序对它本身期待的事件进行轮询。这样做避免了中断，但是可能存在相当长的等待时间，因为一个事件可能正好发生在一次轮询之后，在这种情况下它就要等待几乎整个轮询间隔。平均而言，等待时间是轮询间隔的一半

**软定时器**避免了中断。无论何时当内核因某种其他原因在运行时,在它返回到用户态之前，它都要检查实时时钟以了解软定时器是否到期。如果这个定时器已经到期，则执行被调度的事件,而无需切换到内核态因为系统已经在内核态。在完成工作之后，软定时器被复位以便再次闹响。要做的全部工作是将当前时钟值复制给定时器并且将超时间隔加上

软定时器随着因为其他原因进入内核的频率而脉动，这些原因包括：1.系统调用；2.TLB未命中；3.页面故障；4.I/O中断;5.CPU变成空闲

当然，可能有一段时间不存在系统调用、TLB未命中或页面故障，在这些情况下，没有软定时器会闹响。为了在这些时间间隔上设置一个最大值，可以将辅助硬件定时器设置为每隔一定时间(例如1ms)闹响一次

## 5.6 用户界面：键盘、鼠标和监视器

**终端**：在计算机上，通常存在许多用户，每个用户拥有一个设备，该设备包括一个键盘和一个连在一起的显示器作为一个单位

### 5.6.1 输入软件

在个人计算机上，键盘包含一个嵌入式微处理器，该微处理器通过一个特殊的串行端口与主板上的控制芯片通信(尽管键盘越来越多地连接到USB端口上)。每当一个键被按下的时候都会产生一个中断，并且每当一个键被释放的时候还会产生第二个中断。每当发生这样的键盘中断时，键盘驱动程序都要从与键盘相关联的I/O端口提取信息，以了解发生了什么事情。其他的一切事情都是在软件中发生的，在相当大的程度上独立于硬件

键盘软件：

I/O端口中的数字是键的编号，称为**扫描码**，而不是ASCII码。键盘所拥有的键不超过128个，所以只需7个位表示键的编号。当键按下时，第8位设置为0，当键释放时，第8位设置为1。跟踪每个键的状态(按下或弹起)是驱动程序的任务。所以，硬件所做的全部工作是给出键被按下和释放的中断，其他的事情由软件来做

键盘驱动程序的处理方法：**原始模式/非规范模式**：驱动程序接收输入并不加修改地向上层传送；**术语规范模式/加工模式**：键盘驱动程序处理全部行内编辑，并且只将校正后的行传送给用户程序

**回显**：在显示器上显示刚刚键入的字符。逻辑上，在一个文本行的结尾需要一个回车和一个换行，回车使光标移回到第一列,换行使光标前进到下一行。要求用户在每一行的结尾键入回车和换行是不受欢迎的。这就要求驱动程序将输入转化成操作系统使用的格式。在UNIX中,ENTER键被转换成一个换行用于内部存储;而在Windows中，它被转换成一个回车跟随一个换行。如果标准形式只是存储一个换行(UNIX约定)，那么回车(由Enter键造成)应该转换为换行。如果内部格式是存储两者(Windows约定)，那么驱动程序应该在得到回车时生成一个换行并且在得到换行时生成一个回车。不管是什么内部约定，监视器可能要求换行和回车两者都回显，以便正确地更新屏幕。在诸如大型计算机这样的多用户系统上，不同的用户可能拥有不同类型的终端连接到大型计算机上,这就要求键盘驱动程序将所有不同的回车/换行组合转换成内部系统标准并且安排好正确地实现回显

### 5.6.2 输出软件

1. 文本窗口

屏幕编辑器和许多其他复杂的程序需要能够以更加复杂的方式更新屏幕，例如在屏幕的中间替换一行。为满足这样的需要，大多数输出驱动程序支持一系列命令来移动光标，在光标处插入或者删除字符或行。这些命令常常被称为**转义序列**

2. X窗口系统

X窗口系统经常仅称为X，具有非常好的可移植性，并且完全运行在用户空间中。在Linux系统上，流行的Gnome和KDE桌面环境就运行在X之上

当X在一台机器上运行时,从键盘或鼠标采集输入并且将输出写到屏幕上的软件称为**X服务器**。它必须跟踪当前选择了哪个窗口(鼠标指针所在处)，这样它就知道将新的键盘输入发送给哪个客户。它与称为**X客户**的运行中的程序进行通信(可能通过网络)。它将键盘与鼠标输入发送给X客户,并且从X客户接收显示命令。X服务器总是位于用户的计算机内部，而X客户有可能在远方的远程计算服务器上，这看起来也许有些不可思议，但是X服务器的主要工作是在屏幕上显示位，所以让它靠近用户是有道理的。从程序的观点来看，X客户是一个客户，吩咐服务器做事情，例如显示文本和几何图形。服务器(在本地PC中)只是做客户吩咐它做的事情,就像所有服务器所做的那样

X只是一个窗口系统，它不是一个完全的GUI。为了获得完全的GUI，要在其上运行其他软件层。一层是Xlib，它是一组库过程，用于访问X的功能。这些过程形成了X窗口系统的基础，这些过程过于原始了，以至于大多数用户程序不能直接访问它们

为了使得对X的编程更加容易，作为X的一部分提供了一个工具包，组成了**Intrinsics(本征函数集)**。这一层管理按钮、滚动条以及其他称为**窗口小部件**的GUI元素。为了产生真正的GUI界面，具有一致的外观与感觉，还需要另外一层软件(或者几层软件)。一个例子是Motif,它是Solaris和其他商业UNIX系统上使用的公共桌面环境的基础。大多数应用程序利用的是对Motif的调用，而不是对Xlib的调用。Gnome和KDE的结构如下表所示，只是所用的库有所不同。Gnome使用GTK+库，KDE使用Qt库

|主机|
|:-:|
|窗口管理器/应用程序|
|Motif|
|本征函数集|
|Xlib|
|X客户(向上为用户空间)|
|UNIX(向下为内核空间)|
|硬件|

此外，值得注意的是窗口管理并不是X本身的组成部分。将其遗漏的决策完全是故意的。一个单独的客户进程，称为**窗口管理器**，控制着屏幕上窗口的创建、删除以及移动。为了管理窗口，窗口管理器要发送命令到X服务器告诉它做什么。窗口管理器经常运行在与X客户相同的机器上，但是理论上它可以运行在任何地方

这一模块化设计，包括若干层和多个程序，使得X高度可移植和高度灵活。它已经被移植到UNIX的大多数版本上，包括Solaris、BSD的所有派生版本、AIX、Linux等，这就使得对于应用程序开发人员来说在多种平台上拥有标准的用户界面成为可能。它还被移植到其他操作系统上。相反，在Windows中，窗口与GUI系统在GDI中混合在一起并且处于内核之中，这使得它们维护起来十分困难，并且当然是不可移植的

3. 图形用户界面

**GUI(图形用户界面)**：暂时撇开触摸屏使能的接口不谈，GUI具有用字符WIMP表示的四个基本要素，这些字母分别代表窗口(Window)、图标(Icon)、菜单(Menu)和定点设备(Pointing device)。窗口是一个矩形块状的屏幕区域，用来运行程序。图标是小符号，可以在其上点击导致某个动作发生。菜单是动作列表，人们可以从中进行选择。最后，定点设备是鼠标、轨迹球或者其他硬件设备，用来在屏幕上移动光标以便选择项目。

GUI软件可以在用户级代码中实现（如UNIX系统所做的那样)，也可以在操作系统中实现（如Windows的情况)

GUI系统的输入仍然使用键盘和鼠标，但是输出几乎总是送往特殊的硬件电路板，称为**图形适配器**。图形适配器包含特殊的内存,称为**视频RAM**,它保存出现在屏幕上的图像。图形适配器通常具有强大的32位或64位CPU和多达1GB自己的RAM,独立于计算机的主存

4. 位图

**位图**：位图文件可以通过茌图像上覆盖一层网格扫描输入。每一个网格方块的平均红绿蓝取值被采样并且保存为一个像素的值。位图的另一个用途是用于文本。在某种字体中表示一个特殊字符的一种方法是将其表示为小的位图。于是往屏幕上添加文本就变成移动位图

位图具有的一个问题是它们不能缩放，此外在具有不同彩色属性的设备之间进行复制，或者在单色设备与彩色设备之间今次那个复制效果并不理想

由于这样的缘故,Windows还支持一个称为DIB(设备无关的位图)的数据结构。采用这种格式的文件使用扩展名.bmp。这些文件在像素之前具有文件与信息头以及一个颜色表,这样的信息使得在不同的设备之间移动位图十分容易。

5. 字体

TrueType字体不是位图而是字符的轮廓。每个TrueType字符是通过围绕其周界的一系列点来定义的,所有的点都是相对于(0,0)原点。使用这一系统,放大或者缩小宇符是十分容易的,必须要做的全部事情只是将每个坐标乘以相同的比例因子。采用这种方法,TrueType字符可以放大或者缩小到任意的点阵尺寸,甚至是分数点阵尺寸。一旦给定了适当的尺寸,各个点可以使用逐点连算法连接起来。轮廓完成之后,就可以填充字符了

一旦填充的字符在数学形式上是可用的,就可以对它进行栅格化,也就是说,以任何期望的分辨率将其转换成位图。通过首先缩放然后栅格化,我们可以肯定显示在屏幕上的字符与出现在打印机上的字符将是尽叮能接近的,差别只在于量化误差。为了进一步改进质量,可以在每个字符中嵌入表明如何进行栅格化的线索

6. 触摸屏

**电阻屏**：顶部有一层柔性的塑料表面。要将**铟锡氧化物(ITO**)薄膜(或者类似的导体材料)以细线方式印制在表面的底侧。在它下面但不与其完全接触的是第二层同样覆盖了一层ITO的面。在上表面,电荷沿垂直方向运动,并且在上下存在导电连接。在底下一层,电荷沿水平方问运动,并且在左右存在连接。当你触摸屏幕时,会使塑料凹陷,从而使顶层ITO与底层相接触。为了找到手指或触笔接触的准确位置,需要在底层的所有水平位置和顶层的所有垂直位置沿两个方向对电阻进行测量。优点是由压力决定测量的产出，缺点在于一般不能支持多点触控

**电容屏**：有两层硬表面,一般是玻璃,每个面都镀有ITO。典型的布局是让ITO以平行线方式添加到每个表面,并且顶层中的线与底层中的线相互垂直。例如,顶层可能沿垂直方向镀上细线,而在底层则镀有沿水平方向的类似条纹模式。两个带电表面被空气隔开,形成实际上是小电容器的网格。电压交替地施加在水平线或者垂直线上,而在另一线上将电压值读出,该电压值则受每一交叉点处电容值的影响。当你将手指放在屏幕之上时,会改变局部电容。通过在各处准确地测量微小的电压变化,就有可能发现手指在屏幕上的位置。这一操作每秒钟重复许多次,将触点的坐标以(x,y)对组成的串提供给设备驱动程序。对于进一步的处理,例如确定发生的是点击、捏拢、张开还是滑动,则由操作系统完成

## 5.8 电源管理

存在两种减少能量消耗的一般方法。第一种方法是当计算机的某些部件(主要是I/O设备)不用的时候由操作系统关闭它们,因为关闭的设备使用的能量很少或者不使用能量。第二种方法是应用程序使用较少的能量,这样为了延长电池时间可能会降低用户体验的质量

### 5.8.1 硬件问题

大多数计算机厂商对于电池节约采取的一般措施是将CPU、内存以及I/O设备设计成具有多种状态:工作、睡眠、休眠和关闭。要使用设备,它必须处于工作状态。当设备在短时间内暂时不使用时,可以将其置于睡眠状态,这样可以减少能量消耗。当设备在一个较长的时间间隔内不使用时,可以将其置于休眠状态,这样可以进一步减少能量消耗。这里的权衡是,使一个设备脱离休眠状态常常比使一个设备脱离睡眠状态花费更多的时间和能量。最后,当一个设备关闭时,它什么事情也不做并且也不消耗电能。并非所有的设备都具有这些状态,但是当它们具有这些状态时,应该由操作系统在正确的时机管理状态的变迁

电源管理提出了操作系统必须处理的若干回题,其中许多问题涉及资源休眠-选择性地、临时性地关闭设备,或者至少当它们空闲时减少它们的功率消耗。必须回答的问题包括:哪些设备能够被控制?它们是工作的还是关闭的,或者它们具有中间状态吗?在低功耗状态下节省了多少电能?重启设备消耗能量吗?当进入低功耗状态时是不是必须保存某些上下文?返回到全功耗状态要花费多长时间?

### 5.8.2 操作系统问题

* 硬盘

硬盘消耗大量的能量以保持高速旋转,即使不存在存取操作。许多计算机,特别是笔记本电脑,在几秒钟或者几分钟不活动之后将停止磁盘旋转。当下一次需要磁盘的时候,磁盘将再次开始旋转。不幸的是,一个停止的磁盘是休眠而不是睡眠,因为要花费相当多的时间将磁盘再次旋转起来,导致用户感到明显的延迟。此外,重新启动磁盘将消耗相当多额外的能量。

节省磁盘能量的另一种方法是在RAM中拥有一个大容量的磁盘高速缓存，如果所需要的数据块在高速缓存中,空闲的磁盘就不必为满足读操作而重新启动。类似地,如果对磁盘的写操作能够在高速缓存中缓冲,一个停止的磁盘就不必只为了处理写操作而重新启动。磁盘可以保持关闭状态直到高速缓存填满或者读缺失发生

避免不必要的磁盘启动的另一种方法是:操作系统通过发送消息或信号保持将磁盘的状态通知给正在运行的程序。某些程序具有叮以目由决定的写操作,这样的写操作可以被略过或者推迟。例如,一个字处理程序可能被设置成每隔几分钟将正在编辑的文件写入磁盘。如果字处理程序知道当它在正常情况下应该将文件写到磁盘的时刻磁盘是关闭的,它就可以将本次写操作推迟直到下一次磁盘开启

* CPU

CPU也能够被管理以节省能量。笔记本电脑的CPU能够用软件置为睡眠状态,将电能的使用减少到几乎为零。在这一状态下CPU唯一能做的事情是当中断发生时醒来。因此,只要CPU变为空闲,无论是因为等待I/O还是因为没有工作要做，它都可以进入睡眠状态

在许多计算机上,在CPU电压、时钟周期和电能消耗之间存在着关系。CPU电压可以用软件降低,这样可以节省能量但是也会(近似线性地)降低时钟速度。由于电能消耗与电压的平方成正比,将电压降低一半会使CPU的速度减慢一半,而电能消耗降低到只有1/4。对于具有明确的最终时限的程序而言,这一特性可以得到利用,例如多媒体观察器必须每40ms解压缩并显示一帧,但是如果它做得太快它就会变得空闲。假设CPU全速运行40ms消耗x焦耳能量,那么半速运行则消耗x/4焦耳的能量。如果多媒体观察器能够在20ms内解压缩并显示一帧,那么操作系统能够以全功幸运行20ms,然后关间20ms,总的能量消耗是x/2焦耳。作为替代,它能够以半功率运行并且恰好满足最终时限,但是能量消耗是x/4焦耳。简而言之，慢速运行比快速运行具有更高的能量效率

有趣的是,放慢CPU核并不总是意味着性能的下降。有时在使用较慢的核的情况下,网络栈的性能也会得到改进。对这一现象的解释是CPU核可能为了自己好而运行得更快。例如,设想一个CPU有若干个快速的核,其中有一个核负责为运行在另一个核上的生产者传输网络包。生产者和网络栈通过共享内存直接通信,并且它们都运行在专门的核上。生产者执行相当数量的计算,并且不能很好地跟上运行网络栈的核的步伐。在典型的运行过程中,网络将传输它必须要传输的所有数据,并且要花一定时间来轮询共享内存,以了解是否真的没有更多的数据要传输。最后,它将放弃CPU核并且睡眠,因为连续轮询造成的电能消耗是非常严重的。不久,生产者提供了更多的数据,但是此时网络栈正在熟睡,唤醒网络栈要花时间而且会降低吞吐量。一种可能的解决方案是永不睡眠,但是这样做也不招人喜欢,因为这会增加电能消耗-与我们要达到的目的正好相反。一种更加吸引人的解决方案是在较慢的核上运行网络栈,这样它就能持续地保持忙碌(并且永不睡眠),与此同时还能够减少电能消耗。与所有的核都炽烈地高速运行这样的配置相比,精心地放慢网络核的性能会更好

* 内存

对于内存,存在两种可能的选择来节省能量。首先,可以刷新然后关闯高速缓存。高速缓存总是能够从内存重新加载而不损失信息。重新加载可以动态些且快速地完成,所以关闯高速缓存是进入睡眠状态。更加极端的选择是将主存的内容写到磁盘上,然后关闭主存本身。这种方法是休眠,因为实际上所有到内存的电能都被切断了,其代价是相当长的重新加载时间,尤其是如果磁盘也被关闭了的话。当内存被切断时,CPU或者也被关闭,或者必须自ROM执行。如果CPU被关闭,将其唤醒的中断必须促使它跳转到ROM中的代码,从而能够重新加载内存并且使用内存。尽管存在所有这些开销,将内存关闭较长的时间周期(例如几个小时)也许是值得的。与常常要花费一分钟或者更长时间从磁盘重新启动操作系统相比,在几秒钟之内重新吕动内存想来更加受欢迎

* 无线通信

无线通信所必须的无线电发送器和接收器消耗电能都特别大，如果接收器为了侦听到来的信息而始终开着，电池可能很快耗完，但如果无线电设备关闭，则可能会错过到来的信息

一种解决方案利用了移动的计算机是与固定的基站通信,而固定基站具有大容量的内存与磁盘并且没有电源限制。解决方案是当移动计算机将要关闭无线电设备时,让移动计算机发送一条消息到基站。从那时起,基站在其磁盘上缓冲到来的消息。当移动计算机再次打开无线电设备时,它会通知基站。此刻,所有积累的消息可以发送给移动计算机。当无线电设备关闭时,生成的外发的消息可以在移动计算机上缓冲。如果缓冲区有填满的危险,可以将无线电设备打开并且将排队的消息发送到基站。

应该在何时将无线电设备关闭?一种可能是让用户或应用程序来决定。另一种方法是在若干秒的空闲时间之后将其关闯。应该在何时将无线电设备再次打开?用户或应用程序可以再一次做出决定,或者可以周期性地将其打开以检查到来的消息并且发送所有排队的消息。当然,当输出缓冲区接近填满时也应该将其打开。各种各样的其他休眠方法也是可能的

* 驱动程序接口

Windows系统拥有一个进行电源管理的机制,称为**ACPI(高级配置与电源接口)**。操作系统可以向任何符合标准的驱动程序发出命令,要求它报告其设备的性能以及它们当前的状态。当与即插即用相结合时,该特性尤其重要,因为在系统刚刚引导之后,操作系统甚至还不知道存在什么设备,更不用说它们关于能量消耗或电源管理的属性了。ACPI还可以发送命令给驱动程序,命令它们削减其功耗水平(当然要基于早先荻悉的设备性能)。还存在某些其他方式的通信。特别地,当一个设备(例如键盘或鼠标)在经历了一个时期的空闲之后检测到活动时,这是一个信号让系统返回到(接近)正常运转

### 5.8.3 应用程序问题

到目前为止,我们了解了操作系统能够降低各种类型的设备的能量使用量的方法。但是,还存在着另一种方法:指示程序使用较少的能量,即使这意味着提供低劣的用户体验。一般情况下,当电池的电荷低于某个阈值时传递这样的信息,然后由应用程序负责在退化性能以廷长电池寿命与维持性能并且冒着用光电池的危险之间作出决定。这里出现的一个问题是程序怎样退化其性能以节省能量?一种方案是信息以各种形式呈现给用户，当退化不存在时,呈现的是最优可能的信息。当退化存在时,全现给用户的信息的保真度(准确度)比它能够达到的保真度要差

## 5.10 小结

输入/输出是一个经常被忽略但是十分重要的话题。任何一个操作系统都有大量的组分与I/O有关。I/O可以用三种方式来实现。第一是程序控制I/O,在这种方式下主CPU输入或输出每个字节或字并且闲置在一个密封的循环中等待,直到它能够获得或者发送下一个字节或字。第二是中断驱动的I/O,在这种方式下CPU针对一个字节或字开始I/O传送并且离开去做别的事情,直到一个中断到来发出信号通知I/O完成。第三是DMA,在这种方式下有一个单独的芯片管理着一个数据块的完整传送过程,只有当整个数据块完成传送时才引发一个中断

I/O可以组织成4个层次:中断服务程序、设备驱动程序、与设备无关的I/O软件和运行在用户空间的I/O库与假脱机程序。设备驱动程序处理运行设备的细节并且向操作系统的其余部分提供统一的接口。与设备无关的I/O软件做类似缓冲与错误报告这样的事情

盘具有多种类型,包括磁盘、RAID和各类光盘。磁盘臂调度算法经常用来改进磁盘性能,但是虚拟几何规格的出现使事情变得十分复杂。通过将两块磁盘组成一对,可以构造稳定的存储介质,具有某些有用的性质

时钟可以用于跟踪实际时间,限制进程可以运行多长时间;处理监视定时器,以及进行记账

面向字符的终端具有多种多样的问题,这些问题涉及特殊的字符如何输入以及特殊的转义序列如何输出。输入可以采用原始模步或加工模式,取决于程序对于输入需要有多少控制。针对输出的转义序列控制着光标的移动并且允许在屏幕上插入和删除文本。

大多数UNIX系统使用X窗口系统作为用户界面的基础。它包含与特殊的库相绑定并发出绘图命后的程序,以及在显示器上执行绘图的服务器

许多个人计算机使用GUI作为它们的输出。GUI基于WIMP范式:窗口、图标、菜单和定点设备。基于GUI的程序一般是事件驱动的,当键盘事件、鼠标事件和其他事件发生时立刻会被发送给程序以便处理。在UNIX系统中,GUI几乎总是运行在X之上

瘦客户机与标准PC相比具有某些优势,对用户而言,值得注意的是简单性并且需要较少维护

最后,电源管理对于手机、平板电脑和笔记本电脑来说是一个主要的问题,因为电池寿命是有限的,而对台式机和服务器则意味着机构的电费账单。操作系统可以采用各种技术来减少功率消耗。通过牺性棠些质量以换取更长的电池寿命,应用程序也可以做出贡献