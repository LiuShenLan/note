- [6.死锁](#6死锁)
	- [6.1 资源](#61-资源)
		- [6.1.1 可抢占资源与不可抢占资源](#611-可抢占资源与不可抢占资源)
		- [6.1.2 资源获取](#612-资源获取)
	- [6.2 死锁简介](#62-死锁简介)
		- [6.2.1 资源死锁的条件](#621-资源死锁的条件)
		- [6.2.2 死锁建模](#622-死锁建模)
	- [6.3 鸵鸟算法](#63-鸵鸟算法)
	- [6.4 死锁检测和死锁恢复](#64-死锁检测和死锁恢复)
		- [6.4.1 每种类型一个资源的死锁检测](#641-每种类型一个资源的死锁检测)
		- [6.4.2 每种类型多个资源的死锁检测](#642-每种类型多个资源的死锁检测)
		- [6.4.3 从死锁中恢复](#643-从死锁中恢复)
	- [6.5 死锁避免](#65-死锁避免)
		- [6.5.1 资源轨迹图](#651-资源轨迹图)
		- [6.5.2 安全状态和不安全状态](#652-安全状态和不安全状态)
		- [6.5.3 单个资源的银行家算法](#653-单个资源的银行家算法)
		- [6.5.4 多个资源的银行家算法](#654-多个资源的银行家算法)
	- [6.6 死锁预防](#66-死锁预防)
		- [6.6.1 破坏互斥条件](#661-破坏互斥条件)
		- [6.6.2 破坏占有并等待条件](#662-破坏占有并等待条件)
		- [6.6.3 破坏不可抢占条件](#663-破坏不可抢占条件)
		- [6.6.4 破坏环路等待条件](#664-破坏环路等待条件)
	- [6.7 其他问题](#67-其他问题)
		- [6.7.1 两阶段加锁](#671-两阶段加锁)
		- [6.7.2 通信死锁](#672-通信死锁)
		- [6.7.3 活锁](#673-活锁)
		- [6.7.4 饥饿](#674-饥饿)
	- [6.9 小结](#69-小结)

# 6.死锁

## 6.1 资源

在进程对设备、文件等取得了排他性访问权时，有可能会出现死锁。把这类需要排他性使用的对象称为**资源** 。资源可以是硬件设备或是一组信息。通常在计算机中有多种(可获取的)资源。一些类型的资源会有若干个相同的实例，当某一资源有若干实例时，其中任何一个都可以用来满足对资源的请求。简单来说，资源就是随着时间的推移,必须能获得、使用以及释放的任何东西

### 6.1.1 可抢占资源与不可抢占资源

资源分为两类:可抢占的和不可抢占的。**可抢占资源**可以从拥有它的进程中抢占而不会产生任何副作用，存储器就是一类可抢占的资源；**不可抢占资源**是指在不引起相关的计算失败的情况下，无法把它从占有它的进程处抢占过来

某个资源是否可抢占取决于上下文环境。在一台标准的PC中，内存中的页面总是可以置换到磁盘中并置换回来，故内存是可抢占的。但是在一部不支持交换和页面调度的智能机上，仅通过将内存消耗大户交换出来是不能避免死锁的。总的来说，死锁与不可抢占资源有关，有关可抢占资源的潜在死锁通常可以通过在进程之间重新分配资源而化解。所以,我们的重点放在不可抢占资源上

使用一个资源所需要的事件顺序可以用抽象的形式表示如下:1.请求资源；2.使用资源；3.释放资源。若请求时资源不可用，则请求进程被迫等待。在一些操作系统中资源请求失败时进程会自动被阻塞，在资源可用时再唤醒它。在其他的系统中，资源请求失败会返回一个错误代码，请求的进程会等待一段时间，然后重试。当一个进程请求资源失败时，它通常会处于这样一个小循环中:请求资源，休眠，再请求。这个进程虽然没有被阻塞，但是从各角度来说，它不能做任何有价值的工作,实际和阻塞状态一样。在后面的讨论中，我们假设:如果某个进程请求资源失败，那么它就进入休眠状态

### 6.1.2 资源获取

对于数据库系统中的记录这类资源,应该由用户进程来管理其使用。一种允许用户管理资源的可能方法是为每一个资源配置一个信号量。这些信号量都被初始化为1。互斥信号量也能起到相同的作用。上述的三个步骤可以实现为信号量的down操作来获取资源，使用资源，最后使用up操作来释放资源

考虑两个进程(A和B)以及两个资源(资源1和资源2)的情况。第一种情况是两个进程都按照相同的顺序获取资源(如首先获取资源1，然后获取资源2)，其中一个进程先于另一个进程获取资源。这个进程能够成功地获取第二个资源并完成它的任务。如果另一个进程想在第一个资源被释放之前获取该资源，那么它会由于资源加锁而被阻塞，直到该资源可用为止；第二种情况是两个进程按照不同的顺序获取资源，可能其中一个进程获取了两个资源并有效地阻塞了另外一个进程，直到它使用完这两个资源为止。但是，也有可能进程A获取了资源1，进程B获取了资源2，每个进程如果都想请求另一个资源就会被阻塞，那么,每个进程都无法继续运行。这种情况就是死锁。可以看到一个编码风格上的细微差别(哪一个资源先获取)造成了可以执行的程序和不能执行而且无法检测错误的程序之间的差别

## 6.2 死锁简介

**死锁定义**：如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁的

在大多数情况下，每个进程所等待的事件是释放进程集合中其他进程所占有的资源。换言之，这一死锁进程集合中的每一个进程都在等待另一个死锁的进程已经占有的资源。但是由于所有进程都不能运行，它们中的任何一个都无法释放资源，所以没有一个进程可以被唤醒。进程的数量以及占有或者请求的资源数量和种类都是无关紧要的，而且无论资源是何种类型(软件或者硬件)都会发生这种结果。这种死锁称为**资源死锁**。这是最常见的类型，但并不是唯一的类型。本节详细介绍资源死锁，在本章末概述其他类型的死锁

### 6.2.1 资源死锁的条件

发生资源死锁的四个必要条件：

1. 互斥条件。每个资源要么已经分配给了一个进程，要么就是可用的

2. 占有和等待条件。已经得到了某个资源的进程可以再请求新的资源

3. 不可抢占条件。已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放

4. 环路等待条件。死锁发生时，系统中一定有由两个或两个以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源

### 6.2.2 死锁建模

可以用有向图建立上述四个条件的模型。在有向图中有两类节点：用圆形表示进程，用方形表示资源。从资源节点到进程节点的有向边表示该资源已被请求，授权并被进程占用。由进程节点到资源节点的有向边表示当前进程正在请求该资源，并且该进程已被阻塞，处于等待该资源的状态。有向图中的表示与这些进程的资源有关的死锁

资源分配图可以用作一种分析工具，考察对一给定的请求/释放的序列是否会引起死锁。只需要按照请求和释放的次序一步步进行，每一步之后都检查图中是否包括了环路。如果有环路，那么就有死锁，反之，则没有死锁

有四种处理死锁的策略：

1. 忽略该问题。也许如果你忽略它，它也会忽略你

2. 检测死锁并恢复。让死锁发生，检测它们是否发生，一旦发生死锁，采取行动解决问题

3. 仔细对资源进行分配，动态地避免死锁

4. 通过破坏引起死锁的四个必要条件之一，防止死锁的产生

## 6.3 鸵鸟算法

最简单的解决方法是鸵鸟算法：把头埋到沙子里，假装根本没有问题发生

## 6.4 死锁检测和死锁恢复

第二种技术是死锁检测和恢复。在使用这种技术时，系统并不试图阻止死锁的产生，而是允许死锁发生，当检测到死锁发生后，采取措施进行恢复。死锁的检测是一个经典的图论问题

### 6.4.1 每种类型一个资源的死锁检测

考虑每种资源类型只有一个资源的系统，可以对这样的系统构造一张资源分配图，如果这张图包含了一个或一个以上的环，那么死锁就存在。在此环中的任何一个进程都是死锁进程。如果没有这样的环，系统就没有发生死锁

可以使用深度优先搜索检测是否存在有向环，但这不是最佳算法

### 6.4.2 每种类型多个资源的死锁检测

* 如果有多种相同的资源存在，就需要采用另一种方法来检测死锁。现在提供一种基于矩阵的算法来检测从$P_1$到$P_n$这n个进程中的死锁

	* **现有资源向量E**：代表每种已存在的资源总数。假设资源的类型数为m，$E_1$代表资源类型1，$E_2$代表资源类型2,$E_i$代表资源类型i(1≤i≤m)

	* **可用资源向量A**：在任意时刻，某些资源已被分配所以不可用，那么$A_i$表示当前可供使用的资源数(即没有被分配的资源)。如果资源i都被分配出去了，那么$A_i$的值为0

	* **当前分配矩阵C**：C的第i行代表进程$P_i$当前所持有的每一种类型资源的资源数。所以,$C_{ij}$代表进程i所持有的资源j的数量

	* **请求矩阵R**：$R_{ij}$代表进程$P_i$所需要的资源j的数量

	* 这四种数据结构之间有一个重要的恒等式。具体地说，某种资源要么已分配要么可用，即$\sum^n_{i=1}C_{ij}+A_j=E_j$

死锁检测算法就是基于向量的比较。我们定义向量A和向量B之间的关系为A≤B以表明A的每一个分量≤B向量相对应的分量。从数学上来说，A≤B当且仅当且$A_i$≤$B_i$(0≤i≤m)

每个进程起初都是没有标记过的。算法开始会对进程做标记，进程被标记后就表明它们能够被执行,不会进入死锁。当算法结束时，任何没有标记的进程都是死锁进程。该算法假定了一个最坏情形:所有的进程在退出以前都会不停地获取资源

* 死锁检测算法如下:
	1. 寻找一个没有标记的进程$P_i$，对于它而言R矩阵的第i行向量≤A
	2. 如果找到了这样一个进程，那么将C矩阵的第i行向量加到A中，标记该进程，并转到第1步(即这一进程被运行完毕，释放自己持有的资源并将它们返回到可用资源库中，然后这一进程被标记为完成)
	3. 如果没有这样的进程，那么算法终止
	* 虽然算法的运行过程是不确定的(因为进程可按任何行得通的次序执行)，但结果是相同的

现在我们知道了如何检测死锁(至少是在这种预先知道静态资源请求的情况下),但问题在于何时去检测它们。一种方法是每当有资源请求时去检测,毫无疑问越早发现越好，但这种方法会占用昂贵的CPU时间；另一种方法是每隔k分钟检测一次，或者当CPU的使用率降到某一阈值时去检测。考虑到CPU使用效率的原因，如果死锁进程数达到一定数量，就没有多少进程可运行了，所以CPU会经常空闲

### 6.4.3 从死锁中恢复

1. 利用抢占恢复

在某些情况下，可能会临时将某个资源从它的当前所有者那里转移给另一个进程。许多情况下，尤其是对运行在大型主机上的批处理操作系统来说，需要人工进行干预。在不通知原进程的情况下，将某一资源从一个进程强行取走给另一个进程使用，接着又送回，这种做法是否可行主要取决于该资源本身的特性。用这种方法恢复通常比较困难或者说不太可能。若选择挂起某个进程，则在很大程度上取决于哪一个进程拥有比较容易收回的资源

2. 利用回滚恢复

如果系统设计人员以及主机操作员了解到死锁有可能发生，他们就可以周期性地对进程进行**检查点检查(checkpointed)**。进程检查点检查就是将进程的状态写入一个文件以备以后重启。该检查点中不仅包括存储映像，还包括了资源状态，即哪些资源分配给了该进程。为了使这一过程更有效，新的检查点不应覆盖原有的文件，而应写到新文件中。这样，当进程执行时，将会有一系列的检查点文件被累积起来。

一旦检测到死锁，就很容易发现需要哪些资源。为了进行恢复，要从一个较早的检查点上开始，这样拥有所需要资源的进程会回滚到一个时间点，在此时间点之前该进程获得了一些其他的资源。在该检查点后所做的所有工作都丢失。(例如，检查点之后的输出必须丢弃，因为它们还会被重新输出)。实际上，是将该进程复位到一个更早的状态，那时它还没有取得所需的资源。接着就把这个资源分配给一个死锁进程。如果复位后的进程试图重新获得对该资源的控制，它就必须一直等到该资源可用时为止

3. 通过杀死进程恢复

最直接也是最简单的解决死锁的方法是杀死一个或若干个进程

一种方法是杀掉环中的一个进程。如果走运的话，其他进程将可以继续。如果这样做行不通的话，就需要继续杀死别的进程直到打破死锁环

另一种方法是选一个环外的进程作为牺牲品以释放该进程的资源。在使用这种方法时，选择一个要被杀死的进程要特别小心，它应该正好持有环中某些进程所需的资源。杀死第三个进程将释放这些资源,从而打破前两个进程的死锁。有可能的话，最好杀死可以从头开始重新运行而且不会带来副作用的进程

## 6.5 死锁避免

在讨论死锁检测时，我们假设当一个进程请求资源时，它一次就请求所有的资源。不过在大多数系统中,一次只请求一个资源。系统必须能够判断分配资源是否安全,并且只能在保证安全的条件下分配资源。问题是:是否存在一种算法总能做出正确的选择从而避免死锁?答案是肯定的,但条件是必须事先获得一些特定的信息

### 6.5.1 资源轨迹图

避免死锁的主要算法是基于一个安全状态的概念

可以在二维坐标系中用横纵坐标表示两个进程的运行状态阶段，用矩形区域表示两个进程同时请求的一个资源，坐标图中的折线表示程序的运行路径。在单处理机情况下，所有路径都只能是水平或垂直方向的，不会出现斜向的。因此运动方向一定是向上或向右，不会向左或向下，因为进程的执行不可能后退

### 6.5.2 安全状态和不安全状态

将要研究的死锁避免算法使用了现有资源向量E、可用资源向量A、当前分配矩阵C和请求矩阵R数据结构。在任何时刻，当前状态包含了E、A、C和R。如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。值得注意的是，不安全状态并不是死锁，甚至其中有进程能够完成。

安全状态和不安全状态的区别是：从安全状态出发，系统能够保证所有进程都能完成；而从不安全状态出发，就没有这样的保证

### 6.5.3 单个资源的银行家算法

**银行家算法**：银行家算法就是对每一个请求进行检查，检查如果满足这一请求是否会达到安全状态。若是，那么就满足该请求;否则，就推迟对这一请求的满足。为了检查状态是否安全，操作系统需要考虑他是否有足够的资源满足某一个进程。如果可以，那么该资源就是能够收回的，并且接着检查最接近最大需求的一个进程，以此类推。如果所有资源最终都能被收回，那么该状态是安全的，最初的请求可以批准

### 6.5.4 多个资源的银行家算法

可以把银行家算法进行推广以处理多个资源。现有资源向量E、可用资源向量A、当前分配矩阵C和请求矩阵R数据结构，然后计算出仍然需要的资源矩阵N

* 检查一个状态是否安全的算法如下:
	1. 查找所需资源矩阵N中是否有一行，其没有被满足的资源数均≤A。如果不存在这样的行,那么系统将会死锁，因为任何进程都无法运行结束(假定进程会一直占有资源直到它们终止为止)
	2. 假若找到这样一行，那么可以假设它获得所需的资源并运行结束，将该进程标记为终止，并将其资源加到向量A上
	3. 重复以上两步，或者直到所有的进程都标记为终止，其初始状态是安全的，或者所有进程的资源需求都得不到满足，此时就是发生了死锁
	* 如果在第1步中同时有若干进程均符合条件，那么不管挑选哪一个运行都没有关系，因为可用资源或者会增多,或者至少保持不变

该算法虽然很有意义但缺乏实用价值，因为很少有进程能够在运行前就知道其所需资源的最大值。而且进程数也不是固定的，往往在不断地变化(如新用户的登录或退出)，况且原本可用的资源也可能突然间变成不可用(如磁带机可能会坏掉)。因此，在实际中，如果有，也只有极少的系统使用银行家算法来避免死锁。然而，一些系统可以使用诸如银行家算法之类的启发式方法来避免死锁。例如，当缓冲区利用率达到70%以上时，网络会实现自动节流，此时网络预计剩余的30%就足够使用户完成服务并返回资源

## 6.6 死锁预防

死锁避免从本质上来说是不可能的，因为它需要获知未来的请求，而这些请求是不可知的。如果能够保证[资源死锁的四个条件](#621-资源死锁的条件)中至少有一个不成立，那么死锁就不会产生

### 6.6.1 破坏互斥条件

先考虑破坏互斥使用条件。如果资源不被一个进程所独占，那么死锁肯定不会产生。当然，允许两个进程同时使用打印机会造成混乱，通过采用[假脱机](5.输入输出.md#534-用户空间的io软件)打印机技术可以允许若干个进程同时产生输出。该模型中唯一真正请求使用物理打印机的进程是打印机守护进程，由于守护进程决不会请求别的资源,所以不会因打印机而产生死锁

假设守护进程被设计为在所有输出进入假脱机之前就开始打印，那么如果一个输出进程在头一轮打印之后决定等待几个小时,打印机就可能空置。为了避免这种现象，一般将守护进程设计成在完整的输出文件就绪后才开始打印。但是如果两个进程分别占用了可用的假脱机磁盘空间的一半用于输出，而任何一个也没有能够完成输出，那么会怎样?在这种情形下，就会有两个进程，其中每一个都完成了部分的输出，但不是它们的全部输出，于是无法继续进行下去。没有一个进程能够完成结果在磁盘上出现了死锁

不过，有一个小思路是经常可适用的。那就是，避免分配那些不是绝对必需的资源，尽量做到尽可能少的进程可以真正请求资源

### 6.6.2 破坏占有并等待条件

只要禁止已持有资源的进程再等待其他资源便可以消除死锁。一种实现方法是规定所有进程在开始执行前请求所需的全部资源。如果所需的全部资源可用，那么就将它们分配给这个进程，于是该进程肯定能够运行结束。如果有一个或多个资源正被使用，那么就不进行分配,进程等待

这种方法的一个直接问题是很多进程直到运行时才知道它需要多少资源。实际上，如果进程能够知道它需要多少资源，就可以使用银行家算法。另一个问题是这种方法的资源利用率不是最优的。例如，有一个进程先从输入磁带上读取数据，进行一小时的分析，最后会写到输出磁带上，同时会在绘图仪上绘出。如果所有资源都必须提前请求，这个进程就会把输出磁带机和绘图仪控制住一小时

不过，一些大型机批处理系统要求用户在所提交的作业的第一行列出它们需要多少资源。然后，系统立即分配所需的全部资源，并且直到作业完成才回收资源。虽然这加重了编程人员的负担，也造成了资源的浪费,但这的确防止了死锁

另一种破坏占有并等待条件的略有不同的方案是,要求当一个进程请求资源时，先暂时释放其当前占用的所有资源,然后再尝试一次获得所需的全部资源

### 6.6.3 破坏不可抢占条件

破坏第三个条件(不可抢占)也是可能的。假若一个进程已分配到一台打印机,且正在进行打印输出，如果由于它需要的绘图仪无法获得而强制性地把它占有的打印机抢占掉，会引起一片混乱。但是，一些资源可以通过虚拟化的方式来避免发生这样的情况。假脱机打印机向磁盘输出，并且只允许打印机守护进程访问真正的物理打印机，这种方式可以消除涉及打印机的死锁,然行却可能带来由磁盘空间导致的死锁。但是对于大容量磁盘，要消耗完所有的磁盘空间一般是不可能的

然而，并不是所有的资源都可以进行类似的虚拟化。例如，数据库中的记录或者操作系统中的表都必须被锁定，因此存在出现死锁的可能

### 6.6.4 破坏环路等待条件

消除环路等待有几种方法

一种是保证每一个进程在任何时刻只能占用一个资源，如果要请求另外一个资源，它必须先释放第一个资源。但假如进程正把一个大文件从磁带机上读入并送到打印机打印，那么这种限制是不可接受的

另一种避免出现环路等待的方法是将所有资源统一编号排序。现在的规则是:进程可以在任何时刻提出资源请求,但是所有请求必须按照资源编号的顺序(升序)提出。若按此规则，资源分配图中肯定不会出现环

对于多于两个进程的情况，同样的逻辑依然成立。在任何时候，总有一个已分配的资源是编号最高的。占用该资源的进程不可能请求其他已分配的各种资源。它或者会执行完毕，或者最坏的情形是去请求编号更高的资源，而编号更高的资源肯定是可用的。最终，它会结束并释放所有资源，这时其他占有最高编号资源的进程也可以执行完。简言之，存在一种所有进程都可以执行完毕的情景，所以不会产生死锁

该算法的一个变种是取消必须按升序请求资源的限制，而仅仅要求不允许进程请求比当前所占有资源编号低的资源

尽管对资源编号的方法消除了死锁的问题,但几乎找不出一种使每个人都满意的编号次序。当资源包括进程表项、假脱机磁盘空间、加锁的数据库记录及其他抽象资源时,潜在的资源及各种不同用途的数目会变得很大,以至于使编号方法根本无法使用

死锁预防方法汇总↓：
|条件|处理方式|
|:-:|:-:|
|互斥|一切都使用假脱机技术|
|占有和等待|在开始就请求全部资源|
|不可抢占|抢占资源|
|环路等待|对资源按序编号|

## 6.7 其他问题

### 6.7.1 两阶段加锁

虽然在一般情况下避免死锁和预防死锁并不是很有希望，但是在一些特殊的应用方面，有很多卓越的专用算法。例如，在很多数据库系统中，一个经常发生的操作是请求锁住一些记录，然后更新所有锁住的记录。当同时有多个进程运行时,就有出现死锁的危险

常用的方法是**两阶段加锁**。在第一阶段，进程试图对所有所需的记录进行加锁,一次锁一个记录。如果第一阶段加锁成功,就开始第二阶段，完成更新然后释放锁。在第一阶段并没有做实际的工作

如果在第一阶段某个进程需要的记录已经被加锁，那么该进程释放它所有加锁的记录，然后重新开始第一阶段。从某种意义上说，这种方法类似于提前或者至少是未实施一些不可逆的操作之前请求所有资源。在两阶段加锁的一些版本中，如果在第一阶段遇到了已加锁的记录，并不会释放锁然后重新开始，这就可能产生死锁

不过，在一般意义下，这种策略并不通用。例如，在实时系统和进程控制系统中，由于一个进程缺少一个可用资源就半途中断它，并重新开始该进程，这是不可接受的。如果一个进程已经在网络上读写消息、更新文件或从事任何不能安全地重复做的事，那么重新运行进程也是不可接受的。只有当程序员仔细地安排了程序，使得在第一阶段程序可以在任意一点停下来，并重新开始而不会产生错误，这时这个算法才可行。但很多应用并不能按这种方式来设计

### 6.7.2 通信死锁

到目前为止，我们的工作都集中在资源死锁上。若一个进程请求某个其他进程持有的资源，就必须等待直到其使用者释放资源。这些资源有时是硬件或软件对象。资源死锁是**竞争性同步**的问题。进程在执行过程中如果与竞争的进程无交叉，便会顺利执行。进程将资源加锁，是为了防止交替访问资源而产生不一致的资源状态。交替访问加锁的资源将有可能产生死锁。信号量是比蓝光光驱更抽象的一种资源，但是若每个进程都成功获得了一个资源(一个信号量)，并在请求另一个资源(另一个信号量)时产生死锁。这是一种典型的资源死锁

资源死锁是最普遍的一种类型但不是唯一的一种。另一种死锁发生在通信系统中(比如说网络)，即两个或两个以上进程利用发送信息来通信时。一种普遍的情形是进程A向进程B发送请求信息，然后阻塞直至B回复。假设请求信息丢失，A将阻塞以等待回复，而B会阻塞等待一个向其发送命令的请求，因此发生死锁

尽管如此，但这并不是一个经典的资源死锁。A没有占有B所需的资源，反之亦然。事实上，并没有完全可见的资源。但是，根据标准的定义，在一系列进程中，每个进程因为等待另外一个进程引发的事件而产生阻塞，这就是一种死锁。相比于更加常见的资源死锁，把上面这种情况叫作**通信死锁**。通信死锁是**协同同步**的异常情况，处于这种死锁中的进程如果是各自独立执行的，则无法完成服务

通信死锁不能通过对资源排序(因为没有)或者通过仔细地安排调度来避免(因为任何时刻的请求都是不允许被延迟的)。幸运的是，另外一种技术通常可以用来中断通信死锁:超时。在大多数网络通信系统中，只要一个信息被发送至一个特定的地方，并等待其返回一个预期的回复，发送者就同时启动计时器。若计时器在回复到达前计时就停止了，则信息的发送者可以认定信息已经丢失，并重新发送(如果需要，则一直重复)。通过这种方式，可以避免死锁。换种说法就是，超时策略作为一种启发式方法可探测死锁并使进程恢复正常。这种方式也适用于资源死锁。另外，有些用户使用的设备驱动程序是多变的或者有漏洞的，会导致死锁或系统冻结，这些用户也要依赖于超时策略

当然如果原始信息没有丢失，而仅仅是回复延时，接受者可能收到两次或者更多次信息，甚至导致意想不到的结果

### 6.7.3 活锁

在某些情况下，当进程意识到它不能获取所需要的下一个锁时,就会尝试礼貌地释放已经获得的锁，然后等待1ms,再尝试一次。从理论上来说，这是用来检测并预防死锁的好方法。但是，如果另一个进程在相同的时刻做了相同的操作，那么就像两个人在一条路上相遇并同时给对方让路一样,相同的步调将导致双方都无法前进。这个过程中没有进程阻塞，甚至可以说进程在正常活动，所以这不是死锁，然而进程并不会继续往下执行，可以称之为**活锁**

### 6.7.4 饥饿

与死锁和活锁非常相似的一个问题是**饥饿**。在动态运行的系统中，在任何时刻都可能请求资源。这就需要一些策略来决定在什么时候谁获得什么资源。虽然这个策略表面上很有道理，但依然有可能使一些进程永远得不到服务，虽然它们并不是死锁进程

作为一个例子，考虑打印机分配。设想系统采用某种算法来保证打印机分配不产生死锁。现在假设若干进程同时都请求打印机，究竟哪一个进程能获得打印机呢?一个可能的分配方案是把打印机分配给打印最小文件的进程(假设这个信息可知)。这个方法让尽量多的顾客满意，并且看起来很公平。我们考虑下面的情况:在一个繁忙的系统中，有一个进程有一个很大的文件要打印，每当打印机空闲，系统纵观所有进程，并把打印机分配给打印最小文件的进程。如果存在一个固定的进程流，其中的进程都是只打印小文件，那么，要打印大文件的进程永远也得不到打印机。很简单，它会"饥饿而死"(无限制地推后，尽管它没有被阻塞)

饥饿可以通过先来先服务资源分配策略来避免。在这种机制下，等待最久的进程会是下一个被调度的进程。随着时间的推移，所有进程都会变成最"老"的，因而，最终能够获得资源而完成

## 6.9 小结

死锁是任何操作系统中都存在的潜在问题。当一组进程中的每个进程都因等待由该组进程中的另一进程所占有的资源而导致阻塞，死锁就发生了。这种情况会使所有的进程都处于无限等待的状态。一般来讲，这是进程一直等待被其他进程占用的某些资源释放的事件。死锁的另外一种可能情况是一组通信进程都在等待一个消息，而通信信道却是空的，并且也没有采用超时机制

通过跟踪哪一个状态是安全状态，哪一个状态是不安全状态，可以避免资源死锁。安全状态就是这样一个状态:存在一个事件序列，保证所有的进程都能完成。不安全状态就没有这样的保证。银行家算法可以通过拒绝可能引起不安全状态的请求来避免死锁

也可以在设计系统时从系统结构上预防资源死锁的发生，这样可以永久性地解决资源死锁问题。例如，只允许进程在任何时刻最多占有一个资源，这就破坏了循环等待环路。也可以将所有的资源编号,规定进程按严格的升序请求资源,这样也能预防死锁

资源死锁并不是唯一的一种死锁。尽管我们可以通过设置适当的超时机制来解决通信死锁，但它依然是某些系统中潜在的问题

活锁和死锁的问题有些相似,那就是它也可以停止所有的转发进程，但是二者在技术上不同，由于活锁包含了一些实际上并没有锁住的进程，因此可以通过先来先服务的分配策略来避免饥饿
