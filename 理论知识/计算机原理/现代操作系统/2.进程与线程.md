- [2. 进程与线程](#2-进程与线程)
	- [2.1 进程](#21-进程)
		- [2.1.1 进程模型](#211-进程模型)
		- [2.1.2 进程的创建](#212-进程的创建)
		- [2.1.3 进程的终止](#213-进程的终止)
		- [2.1.4 进程的层次结构](#214-进程的层次结构)
		- [2.1.5 进程的状态](#215-进程的状态)
		- [2.1.6 进程的实现](#216-进程的实现)
		- [2.1.7 多道程序设计模型](#217-多道程序设计模型)
	- [2.2 线程](#22-线程)
		- [2.2.2 经典的线程模型](#222-经典的线程模型)
		- [2.2.4 在用户空间中实现线程](#224-在用户空间中实现线程)
		- [2.2.5 在内核中实现线程](#225-在内核中实现线程)
		- [2.2.6 混合实现](#226-混合实现)
		- [2.2.7 调度程序激活机制](#227-调度程序激活机制)
		- [2.2.8 弹出式线程](#228-弹出式线程)
		- [2.2.9 使单线程代码多线程化](#229-使单线程代码多线程化)
	- [2.3 进程间通信(IPC)](#23-进程间通信ipc)
		- [2.3.1 竞争条件](#231-竞争条件)
		- [2.3.3 忙互斥等待](#233-忙互斥等待)
		- [2.3.4 睡眠与唤醒](#234-睡眠与唤醒)
		- [2.3.5 信号量](#235-信号量)
		- [2.3.6 互斥量](#236-互斥量)
		- [2.3.7 管程](#237-管程)
		- [2.3.8 消息传递](#238-消息传递)
		- [2.3.9 屏障](#239-屏障)
		- [2.3.10 避免锁：读-复制-更新](#2310-避免锁读-复制-更新)
	- [2.4 调度](#24-调度)
		- [2.4.1 调度简介](#241-调度简介)
		- [2.4.2 批处理系统中的调度](#242-批处理系统中的调度)
		- [2.4.3 交互式系统中的调度](#243-交互式系统中的调度)
		- [2.4.4 实时系统中的调度](#244-实时系统中的调度)
		- [2.4.5 策略和机制](#245-策略和机制)
	- [2.5 经典的IPC问题](#25-经典的ipc问题)
		- [2.5.1 哲学家就餐问题](#251-哲学家就餐问题)
		- [2.5.2 读者-写者问题](#252-读者-写者问题)
	- [2.7 小结](#27-小结)

# 2. 进程与线程

## 2.1 进程

### 2.1.1 进程模型

**进程**：在进程模型中，计算机上所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值

从概念上说,每个进程拥有它自己的虚拟CPU。当然,实际上真正的CPU在各进程之间来回切换。这种快速的切换称作**多道程序设计**。

### 2.1.2 进程的创建

四种主要事件会导致进程的创建：系统初始化、正在运行的程序执行了创建进程的系统调用、用户请求创建一个新进程、一个批处理作业的初始化

**守护进程**：
停留在后台处理诸如电子邮件、Web页面、新闻、打印之类活动的进程

父进程与子进程可写的内存是不可以共享的。子进程可以共享父进程的所有内存，但此时内存通过**写时复制**共享，一旦两者之一想要修改部分内存，则这块内存首先被明确的复制，以确保修改发生在私有内存区域

### 2.1.3 进程的终止

通常进程终止的条件：正常退出(自愿)、出错退出(自愿)、严重错误(非自愿)、被其他进程杀死(非自愿)

### 2.1.4 进程的层次结构

在UNIX系统中，进程和它的所有子进程以及后裔共同组成一个进程组。所有的进程都属于以init为根的一棵树。相反，Windows中没有进程层次的概念，所有的进程都是地位相同的。唯一类似于进程层次的暗示，是在创建进程的时候,父进程得到一个特别的令牌(称为句柄),该句柄可以用来控制子进程。但是,它有权把这个令牌传送给某个其他进程,这样就不存在进程层次了。在UNIX中,进程就不能剥夺其子进程的"继承权"。

### 2.1.5 进程的状态

进程的三种**状态**：运行态(该时刻进程实际占用CPU)、就绪态(可运行，但因为其他进程正在运行而暂时停止)、阻塞态(除非某种外部事件发生，否则进程不能运行)

进程状态之间的**转换关系**：运行态因为等待输入而被阻塞、进程调度程序使进程在运行态与就绪态之间切换、当进程等待的一个外部事件发生时(如一些输入到达)进程由阻塞态转换为就绪态(如果此时没有其他进程运行，则立即转化为运行态，否则该进程将处于就绪态，等待CPU空闲并且轮到它运行)

### 2.1.6 进程的实现

为了实现进程模型,操作系统维护着一张表格(一个结构数组),即**进程表**。每个进程占用一个进程表项。该表项包含了进程状态的重要信息,包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息,以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息,从而保证该进程随后能再次启动,就像从未被中断过一样。

与每一I/O类关联的是一个称作**中断向量**的位置(靠近内存底部的固定区域)。它包含中断服务程序的入口地址。假设当一个磁盘中断发生时,用户进程3正在运行,则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈,计算机随即跳转到中断向量所指示的地址。这些是硬件完成的所有操作,然后软件,特别是中断服务例程就接管一切剩余的工作。

* 中断发生后操作系统最底层的工作步骤：
  1. 硬件压入堆栈程序计数器等
  2. 硬件从中断向量装入新的程序计数器
  3. 汇编语言过程保存寄存器值
  4. 汇编语言过程设置新的堆栈
  5. C中断服务例程运行(典型地读和缓冲输入)
  6. 调度程序决定下一个将运行的进程
  7. C过程返回至汇编代码
  8. 汇编语言过程开始运行新的当前进程。

### 2.1.7 多道程序设计模型

$CPU利用率=1-p^n$：式中p为一个进程等待I/O操作的时间与其停留在内存中时间的比，n为内存中同时有n个进程，成为多道程序设计的道数，$p^n$为所有n个进程都在等待I/O(此时CPU空转)的概率。此概率模型只描述了一个大致的状况，且假设所有n个进程是独立的

## 2.2 线程

线程共享地址空间，但是进程地址空间是独立的

**高速缓存**：web服务器可以把获得大量访问的页面集合保存在内存中，避免到磁盘去调入这些页面，从而改善性能

**有限状态机**：每个计算都有一个被保存的状态，存在一个会发生且使得相关状态发生改变的事件集合

|模型|特性|
|:-:|:-:|
|多线程|并行性、阻塞系统调用|
|单线程进程|无并行性、阻塞系统调用|
|有限状态机|并行性、非阻塞系统调用、中断|

### 2.2.2 经典的线程模型

进程模型基于两种独立的概念：资源分组处理与执行

**进程**拥有一个执行的线程,通常简写为**线程**。在线程中有一个程序计数器,用来记录接着要执行哪一条指令。线程拥有寄存器,用来保存线程当前的工作变量。线程还拥有一个堆栈,用来记录执行历史,其中每一帧保存了一个已调用的但是还没有从中返回的过程。尽管线程必须在某个进程中执行,但是线程和它的进程是不同的概念,并且可以分别处理。进程用于把资源集中到一起,而线程则是在CPU上被调度执行的实体。

* 一个进程中所有线程共享的内容：地址空间、全局变量、打开文件、子进程、即将发生的定时器、信号与信号处理程序、账户信息

* 每个线程中自己的内容：程序计数器、寄存器、堆栈、状态

与传统进程一样，线程可以处于若干种状态的任何一个：运行、阻塞、就绪或终止。正在运行的线程拥有CPU并且是活跃的。被阻塞的线程正在等待某个释放它的事件。线程可以被阻塞,以便等待某个外部事件的发生或者等待其他线程来释放它。就绪线程可被调度运行,并且只要轮到它就很快可以运行。线程状态之间的转换和进程状态之间的转换是一样的

每个线程都有自己的堆栈

有时，线程是有层次的，他们具有一种父子关系，但是，通常不存在这样一种关系，所有的线程都是平等的

不同于进程，(线程库)无法利用时钟中断强制线程让出CPU，所以设法使线程行为"高尚"起来，并且随着时间的推移自动交出CPU，以便其他线程有机会运行，就变得非常重要

### 2.2.4 在用户空间中实现线程

有两种主要的方法实现线程包：在用户空间中和在内核中，不过混合实现方式也是可能的。

**在用户空间中实现线程**：内核对线程包一无所知。从内核角度考虑，就是按正常的方式管理，即单线程进程。

* 优点1：用户级线程包可以在不支持线程的操作系统上实现

在用户空间管理线程时，每个进程需要有其专用的**线程表**，用来跟踪该进程中的线程。这些表和内核中的进程表类似，不过它仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈指针、寄存器和状态等。

* 优点2：线程切换至少比陷入内核要快一个数量级(或者更多)

线程可以把该线程的信息保存在线程表中，进而可以调用线程调度程序来选择另一个要运行的程序。保存该线程状态的过程和调度程序都只是本地过程,所以启动它们比进行内核调用效率更高。另一方面,不需要陷入内核,不需要上下文切换,也不需要对内存高速缓存进行刷新,这就使得线程调度非常快捷。

* 优点3：用户级线程允许每个进程有自己定制的调度算法

* 问题1：实现阻塞系统调用。一个线程进行阻塞系统调用会停止所有的线程

在某些UNIX系统中，有一个系统调用select可以允许调用者通知预期的阻塞系统调用是否会阻塞。首先进行select调用，在不会阻塞的情况下进行可能导致阻塞的系统调用。在系统调用周围从事检查的这类代码称为**包装器**

* 问题2：如果一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃CPU

### 2.2.5 在内核中实现线程

**在内核中实现线程**：不需要运行时系统，并且每个进程中也没有线程表。相反，在内核中有用来记录系统中所有线程的线程表。当某个线程希望创建一个新线程或撒销一个已有线程时,它进行一个系统调用,这个系统调用通过对线程表的更新完成线程创建或撒销工作。

所有能够阻塞线程的调用都以系统调用的形式实现,这与运行时系统过程相比,代价是相当可观的。当一个线程阻塞时,内核根据其选择,可以运行同一个进程中的另一个线程(若有一个就绪线程)或者运行另一个进程中的线程。而在用户级线程中,运行时系统始终运行自己进程中的线程,直到内核剥夺它的CPU(或者没有可运行的线程存在)为止。

由于在内核中创建或撒销线程的代价比较大,某些系统采取“环保“的处理方式,回收其线程。当某个线程被撤销时,就把它标志为不可运行的,但是其内核数据结构没有受到影响。稍后,在必须创建一个新线程时,就重新启动某个旧线程,从而节省了一些开销。在用户级线程中线程回收也是可能的,但是由于其线程管理的代价很小,所以没有必要进行这项工作。

内核线程不需要任何新的、非阻塞系统调用。另外,如果某个进程中的线程引起了页面故障,内核可以很方便地检查该进程是否有任何其他可运行的线程,如果有,在等待所需要的页面从磁盘读入时,就选择一个可运行的线程运行。这样做的主要缺点是系统调用的代价比较大,所以如果线程的操作(创建、终止等)比较多,就会带来很大的开销。

### 2.2.6 混合实现

人们已经研究了各种试图将用户级线程的优点和内核级线程的优点结合起来的方法。一种方注是使用内核级线程,然后将用户级线程与某些或者全部内核线程多路复用起来。如果采用这种方法，编程人员可以决定有多少个内核级线程和多少个用户级线程彼此多路复用。这一模型带来最大的灵活度

采用这种方法,内核只识别内核级线程,并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。如同在没有多线程能力操作系统中某个进程中的用户级线程一样,可以创建、撒销和调度这些用户级线程。在这种模型中,每个内核级线程有一个可以轮流使用的用户级线程集合。

### 2.2.7 调度程序激活机制

在一些关键点上内核级线程优于用户级线程，但内核级线程的速度慢

**调度程序激活机制**：目标是模拟内核线程的功能，但是为线程包提供通常在用户空间中才能实现的更好的性能和更大的灵活性。特别地,如果用户线程从事某种系统调用时是安全的,那就不应该进行专门的非阻塞调用或者进行提前检查。无论如何,如果线程阻塞在某个系统调用或页面故障上,只要在同一个进程中有任何就绪的线程,就应该有可能运行其他的线程。

由于避免了在用户空间和内核空间之间的不必要转换，从而提高了效率

当使用调度程序激活机制时,内核给每个进程安排一定数量的虚拟处理器,并且让(用户空间)运行时系统将线程分配到处理器上。这一机制也可以用在多处理器中,此时虚拟处理器可能成为真实的CPU。分配给一个进程的虚拟处理器的初始数量是一个,但是该进程可以申请更多的处理器并且在不用时退回。内核也可以取回已经分配出去的虚拟处理器,以便把它们分给需要更多处理器的进程。

使该机制工作的基本思路是,当内核了解到一个线程被阻塞之后(例如,由于执行了一个阻塞系统调用或者产生了一个页面故障),内核通知该进程的运行时系统,并且在堆栈中以参数形式传递有问题的线程编号和所发生事件的一个描述。内核通过在一个已知的起始地址启动运行时系统,从而发出了通知,这是对UNIX中信号的一种粗略模拟。这个机制称为**上行调用**

一旦如此激活,运行时系统就重新调度其线程,这个过程通常是这样的:把当前线程标记为阻塞并从就绪表中取出另一个线程,设置其寄存器,然后再启动之。稍后,当内核知道原来的线程又可运行时,内核就又一次上行调用运行时系统,通知它这一事件。此时该运行时系统按照自己的判断,或者立即重启动被阻塞的线程,或者把它放入就绪表中稍后运行。

在某个用户线程运行的同时发生一个硬件中断时,被中断的CPU切换进内核态。如果被中断的进程对引起该中断的事件不感兴趣,比如,是另一个进程的I/O完成了,那么在中断处理程序结束之后,就把被中断的线程恢复到中断之前的状态。不过,如果该进程对中断感兴趣,比如,是该进程中的某个线程所需要的页面到达了,那么被中断的线程就不再启动,代之为挂起被中断的线程。而运行时系统则启动对应的虚拟CPU,此时被中断线程的状态保存在堆栈中。随后,运行时系统决定在该CPU上调度哪个线程:被中断的线程、新就绪的线程还是某个第三种选择。

调度程序激活机制的一个目标是作为上行调用的信赖基础,这是一种违反分层次系统内在结构的概念。通常,n层提供n+1层可调用的特定服务,但是n层不能调用n+1层中的过程。上行调用并不遵守这个基本原理。

### 2.2.8 弹出式线程

**弹出式线程**：一个消息的到达导致系统创建一个处理该消息的线程。优点：由于这种线程刚创建，没有寄存器与堆栈等，因此可以快速创建线程。消息到达与处理开始之间的时间非常短

在内核空间中运行弹出式线程通常比在用户空间中容易且快捷，而且内核空间中的弹出式线程可以很容易访问所有的表格和I/O设备，但是出错的内核线程会比出错的用户线程造成更大的损害

### 2.2.9 使单线程代码多线程化

对线程而言的全局变量并不是对整个程序也是全局的。可以为每个线程赋予其私有的全局变量

试图将单一线程程序转为多线程程序的另一个问题是,有许多库过程并不是可重入的。一种解决方案是为每个过程提供一个包装器，该包装器设置一个二进制位从而标志某个库处于使用中。在先前的调用还没有完成之前，任何试图使用该库的其他线程都会被阻塞。尽管这个方式可以工作，但它会极大地降低系统潜在的并行性

有些信号逻辑上是线程专用的,但是另一些却不是。

最后一个问题是堆栈的管理

## 2.3 进程间通信(IPC)

一个进程如何把信息传递给另一个、确保两个或更多的进程在关键活动中不会出现交叉、多个进程正确的运行顺序。(后两个问题同样适用于线程)

### 2.3.1 竞争条件

在一些操作系统中,协作的进程可能共享一些彼此都能读写的公用存储区

**竞争条件**：两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序

**互斥**：以某种手段确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作

**临界区域**或**临界区**：对共享内存进行访问的程序片段

避免竞争条件、保证使用共享数据的并发进程能够正确和高效地进行协作所需要的条件：1.任何两个进程不能同时处于其临界区；2.不应对CPU的速度和数量做任何假设；3.临界区外运行的进程不得阻碍其他进程；4.不得使进程无期限等待进入临界区

### 2.3.3 忙互斥等待

1. 屏蔽中断

在单处理器系统中,最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断,并在就要离开之前再打开中断。屏蔽中断后,时钟中断也被屏蔽。CPU只有发生时钟中断或其他中断时才会进行进程切换,这样,在屏蔽中断之后CPU将不会被切换到其他进程。

但是把屏蔽中断的权利交给用户进程并不明智，并且如果系统是多处理器系统，则屏蔽中断仅仅对执行disable指令的那个CPU有效

屏蔽中断对操作系统本身是一项很有用的技术，但对于用户进程则不是一种合适的通用互斥机制

2. 锁变量

设想有一个共享(锁)变量,其初始值为0。当一个进程想进入其临界区时,它首先测试这把锁。如果该锁的值为0,则该进程将其设置为1并进入临界区。若这把锁的值已经为1,则该进程将等待直到其值变为0。于是,0就表示临界区内没有进程,1表示已经有某个进程进入临界区。

但是在读锁变量与设置锁变量之间，其他进程仍然可能会被调度运行

3. 严格轮换法

连续测试一个变量直到某个值出现为止,称为**忙等待**,由于这种方式浪费CPU时间,所以通常应该避免。只有在有理由认为等待时间是非常短的情形下,才使用忙等待。用于忙等待的锁,称为**自旋锁**

在一个进程比另一个进程慢了很多的情况下，轮流进入临界区并不是一个好办法

违反了上节中的条件：3.临界区外运行的进程不得阻碍其他进程；

4. Peterson解法

```C
#define FALSE 0
#define TRUE 1
#define N 2 // 进程数量

int turn;	// 当前进程编号
int interested[N];	// 进程运行flag

void enter_region(int process) {	// 进入临界区
	// process: 当前进程编号
	int other = 1 - process;	// 另一进程编号

	interested[process] = TRUE;
	turn = process;

	while(turn == process && interested[other] == TRUE)
		;
}	// 后跟需要在临界区执行的函数

void leave_region(int process) {	// 离开临界区
	interested[process] = FALSE;
}
```

5. TSL指令

需要硬件支持的方案：测试并加锁指令`TSL RX,LOCK`。它将一个内存字lock读到寄存器RX中,然后在该内存地址上存一个非零值。读字和写字操作保证是不可分割的,即该指令结束之前其他处理器均不允许访问该内存字。执行TSL指令的CPU将锁住内存总线,以禁止其他CPU在本指令结束之前访问内存

锁住存储总线不同于屏蔽中断。屏蔽中断,然后在读内存字之后跟着写操作并不能阻止总线上的第二个处理器在读操作和写操作之间访问该内存字。事实上,在处理器1上屏蔽中断对处理器2根本没有任何影响。让处理器2远离内存直到处理器1完成的唯一方法就是锁住总线,这需要一个特殊的硬件设施(基本上,一根总线就可以确保总线由锁住它的处理器使用,而其他的处理器不能用)。

用TSL指令进入和离开临界区↓：
```x86asm
enter_region:	; 进入临界区
	TSL REGISTER,LOCK	; 复制锁到寄存器REGISTER并将锁设置为1
	CMP REGISTER,#0		; 将锁与零比较
	JEN enter_region	; 若不为零，说明锁已被设置，返回循环开始
	RET					; 进入了临界区，返回调用者，后面执行需要在临界区内执行的函数

leave_region:	; 离开临界区
	MOVE LOCK,#0		; 在锁中存入0
	RET					; 返回调用者
```

一个可替代`TSL`的指令是`XCHG`，它原子性地交换两个位置的内容

用XCHG指令进入和离开临界区↓：
```x86asm
enter_region:	; 进入临界区
	MOV REGISTER,#1		; 在寄存器存放1
	XCHG REGISTER,LOCK	; 交换寄存器与锁变量的内容
	CMP REGISTER,#0		; 将锁与零比较
	JEN enter_region	; 若不为零，说明锁已被设置，返回循环开始
	RET					; 进入了临界区，返回调用者，后面执行需要在临界区内执行的函数

leave_region:	; 离开临界区
	MOVE LOCK,#0		; 在锁中存入0
	RET					; 返回调用者
```

### 2.3.4 睡眠与唤醒

Perterson解法、TSL或XCHG解法都是正确的，但是都有忙等待的缺点。这些解法的本质是当一个线程想进入临界区时，先检查是否允许进入，若不允许，则该进程将原地等待，直到允许为止

**优先级反转问题**：考虑一台计算机有两个进程,H优先级较高,L优先级较低。调度规则规定,只要H处于就绪态它就可以运行。在某一时刻,L处于临界区中,此时H变到就绪态,准备运行。现在H开始忙等待,但由于当H就绪时L不会被调度,也就无法离开临界区,所以H将永远忙等待下去

调用sleep函数的进程将被阻塞，即被挂起，直到另外一个进程将其唤醒wakeup

**生产者-消费者(有界缓冲区**)问题：两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者,将信息放入缓冲区;另一个是消费者,从缓冲区中取出信息(也可以把这个问题一般化为m个生产者和n个消费者问题,但是这里只讨论一个生产者和和一个消费者的情况，这样可以简化解决方案)

问题在于当缓冲区已满,而此时生产者还想向其中放入一个新的数据项的情况。其解决办法是让生产者睡眠,待消费者从缓冲区中取出一个或多个数据项时再唤醒它。同样地,当消费者试图从缓冲区中取数据而发现缓冲区为空时,消费者就睡眠,直到生产者向其中放入一些数据时再将其唤醒。

```C
#define N 100	// 缓冲区中的槽数目
int count = 0;	// 缓冲区中的数据项数目

void producer(void) {	// 生产者
	int item;

	while(TRUE) {
		item = produce_item();	// 产生下一新数据项
		if (count == N)
			sleep();
		insert_item(item);	// 将数据插入缓冲区
		++count;
		if (count == 1)	// 刚向空缓冲区中插入了一个数据项
			wakeup(consumer);
	}
}

void consumer(void) {	// 消费者
	int item;

	while(TRUE) {
		if (count == 0)
			sleep();
		item = remove_item();	// 从缓冲区中取出一个数据项
		--count;
		if (count == N - 1)	// 刚从满缓冲区中取出了一个数据项
			wakeup(producer);
		consume_item(item);
	}
}
```

有可能出现的竞争条件：发给一个尚未睡眠进程的wakeup信号丢失了，这会导致消费者加载之前读取的count为0从而睡眠，从而只有生产者被唤醒，缓冲区填满之后生产者也睡眠，没有活动的进程。可以添加一个**唤醒等待位**：当一个wakeup信号发送给一个清醒的进程信号时，将该位置置1，随后，当该进程要睡眠时，如果唤醒等待位为1，则将该位清除，而该进程仍然保持清醒。唤醒等待位实际上就是wakeup信号的一个小仓库。但原则上讲，这并没有从根本上解决问题

### 2.3.5 信号量

**信号量**：使用一个整型变量来累计唤醒次数，供以后使用。一个信号量的取值可以为0(表示没有保存下来的唤醒操作)或者为正值(表示有一个或多个唤醒操作)

**原子操作**：一组相关联的操作要么都不间断地执行,要么都不执行。这种原子性对于解决同步问题和避免竞争条件是绝对必要的。

对一信号量执行down操作，则检查其值是否>0，若>0则将其值减1(即用掉一个保存的唤醒信号)并继续；若该值为0，则进程将休眠，而且此时down操作并未结束。检查数值、修改变量值以及可能发生的睡眠操作均作为一个单一的、不可分割的**原子操作**完成。保证一旦一个信号量操作开始,则在该操作完成或阻塞之前,其他进程均不允许访问该信号量。

up操作对信号量的值增1。如果一个或多个进程在该信号量上睡眠,无法完成一个先前的down操作,则由系统选择其中的一个(如随机挑选)并允许该进程完成它的down操作。于是,对一个有进程在其上睡眠的信号量执行一次up操作之后,该信号量的值仍旧是0,但在其上睡眠的进程却少了一个。信号量的值增1和唤醒一个进程同样也是不可分割的。不会有某个进程因执行up而阻塞,正如在前面的模型中不会有进程因执行wakeup而阻塞一样。

用信号量解决生产者-消费者问题：为确保信号量能正确工作,最重要的是要采用一种不可分割的方式来实现它。通常是将up和down作为系统调用实现,而且操作系统只需在执行以下操作时暂时屏蔽全部中断:测试信号量、更新信号量以及在需要时使某个进程睡眠。由于这些动作只需要几条指令,所以屏蔽中断不会带来什么副作用。如果使用多个CPU,则每个信号量应由一个锁变量进行保护。通过TSL或XCHG指令来确保同一时刻只有一个CPU在对信号量进行操作。使用TSL或XCHG指令来防止几个CPU同时访问一个信号量,这与生产者或消费者使用忙等待来等待对方腾出或填充缓冲区是完全不同的。信号量操作仅需几个毫秒,而生产者或消费者则可能需要任意长的时间。

**二元信号量**：供两个或多个进程使用的信号量，其初值为1，保证同时只有一个进程可以进入临界区。如果每个进程在进入临界区前都执行一个down操作，并在刚刚退出时执行一个up操作，就能够实现互斥

```C
#define N 100	// 缓冲区中的槽数目
typedef int semaphore	// 信号量是一种特殊的整型数据
semaphore mutex = 1;	// 通过该信号控制对临界区的访问
semaphore empty = N;	// 缓冲区的空槽数目
semaphore full = 0;	// 缓冲区的满槽数目

void producer(void) {	// 生产者
	int item;

	while(TRUE) {
		item = produce_item();	// 产生下一新数据项
		down(&empty);	// 将空槽数目减1
		down(&mutex);	// 进入临界区
		insert_item(item);	// 将数据插入缓冲区
		up(&mutex);	// 离开临界区
		up(&full);	// 将满槽数目加1
	}
}

void consumer(void) {	// 消费者
	int item;

	while(TRUE) {
		down(&full);	// 将满槽数目减1
		down(&mutex);	// 进入临界区
		item = remove_item();	// 从缓冲区中取出一个数据项
		up(&mutex);	// 离开临界区
		up(&empty);	// 将空槽数目加1
		consume_item(item);	// 处理数据项
	}
}
```

信号量的另一种用途是用于实现**同步**。信号量full和empty用来保证某种事件的顺序发生或不发生。在本例中,它们保证当缓冲区满的时候生产者停止运行,以及当缓冲区空的时候消费者停止运行。这种用法与互斥是不同的。

### 2.3.6 互斥量

如果不需要信号量的计数能力,有时可以使用信号量的一个简化版本,称为**互斥量**。互斥量仅仅适用于管理共享资源或一小段代码。由于互斥量在实现时既容易又有效,这使得互斥量在实现用户空间线程包时非常有用

互斥量是一个可以处于两态之一的变量:解锁和加锁。这样,只需要一个二进制位表示它,不过实际上,常常使用一个整型量,0表示解锁,而其他所有的值则表示加锁。互斥量使用两个过程。当一个线程(或进程)需要访问临界区时,它调用mutex_lock。如果该互斥量当前是解锁的(即临界区可用),此调用成功,调用线程可以自由进入该临界区。另一方面,如果该互斥量已经加锁,调用线程被阻塞,直到在临界区中的线程完成并调用mutex_unlock。如果多个线程被阻塞在该互斥量上,将随机选择一个线程并允许它获得锁。

```x86asm
mutex_lock:	; 加锁
	TSL REGISTER,MUTEX	; 将互斥信号量复制到寄存器，并且将互斥信号量置为1
	CMP REGISTER,#0		; 将互斥信号量与零比较
	JZE ok				; 互斥信号量为0，则为解锁状态，返回并进入临界区
	CALL thread_yield	; 互斥信号量已被加锁，调度另一线程
	JMP mutex_lock		; 稍后再试
ok:
	RET					; 返回调用者，进入临界区

mutex_unlock:	; 解锁
	MOVE MUTEX,#0		; 将mutex置为0
	RET					; 返回调用者
```

当enter_region进入临界区失败时,它始终重复测试锁(忙等待)。实际上,由于时钟超时的作用,会调度其他进程运行。这样迟早拥有锁的进程会进入运行并释放锁。在(用户)线程中,情形有所不同,因为没有时钟停止运行时间过长的线程。结果是通过忙等待的方式来试图获得锁的线程将永远循环下去,决不会得到锁,因为这个运行的线程不会让其他线程运行从而释放锁。

在mutex_lock取锁失败时,它调用thread_yield将CPU放弃给另一个线程。这样,就没有忙等待。在该线程下次运行时,它再一次对锁进行测试。由于thread_yield只是在用户空间中对线程调度程序的一个调用,所以它的运行非常快捷。这样,mutex_lock和mutex_unlock都不需要任何内核调用。通过使用这些过程,用户线程完全可以实现在用户空间中的同步,这些过程仅仅需要少量的指令。

在用户级线程包中，多个线程访问同一个互斥量是没有问题的，因为所有的线程都在一个公共地址空间中操作。多个进程访问一些共享变量，有两个方案。第一种，有些共享数据结构，如信号量，可以放在内核中，并且只能通过系统调用来访问。第二种，多数现代操作系统(包括UNIX和Windows)提供一种方法，让进程与其他进程共享其部分地址空间。在这种方法中，缓冲区和其他数据结构可以共享。在最坏的情况下，如果没有可共享的途径，则可以使用共享文件。另外，共享一个公共地址空间的多个进程不会拥有用户级线程的效率，这是因为内核还同其管理密切相关

1. 快速用户区互斥量

随着并行的增加，有效的同步和锁机制对性能而言非常重要。如果等待时间短的话，自旋锁会很快,但如果等待时间长，则会浪费CPU周期。如果有很多竞争，那么阻塞此进程，并仅当锁被释放的时候让内核解除阻塞会更加有效。然而，这却带来了相反的问题:它在竞争激烈的情况下效果不错，但如果一开始只有很小的竞争，那么不停地内核切换将花销很大。更糟的是，预测锁竞争的数量并不容易。

**futex(快速用户空间互斥)**：futex是Linux的一个特性,它实现了基本的锁(很像互斥锁)，但避免了陷入内核，除非它真的不得不这样做。因为来回切换到内核花销很大，所以这样做可观地改善了性能。一个futex包含两个部分:一个内核服务和一个用户库。内核服务提供一个等待队列，它允许多个进程在一个锁上等待。它们将不会运行，除非内核明确地对它们解除阻塞。将一个进程放到等待队列需要(代价很大的)系统调用，我们应该避免这种情况。因此，没有竞争时，futex完全在用户空间工作。特别地，这些进程共享通用的锁变量——一个对齐的32位整数锁的专业术语。假设锁初始值为1，即假设这意味着锁是释放状态。线程通过执行原子操作“减少并检验”来夺取锁(Linux的原子函数包含封装在C语言函数中的内联汇编并定义在头文件中)。接下来，这个线程检查结果，看锁是否被释放。如果未处于被锁状态，那么一切顺利，我们的线程成功夺取该锁。然而，如果该锁被另一个线程持有，那么线程必须等待。这种情况下，futex库不自旋，而是使用一个系统调用把这个线程放在内核的等待队列上。可以期望的是，切换到内核的开销已是合乎情理的了，因为无论如何线程被阻塞了。当一个线程使用完该锁，它通过原子操作“增加并检验”来释放锁，并检查结果，看是否仍有进程阻塞在内核等待队列上。如果有，它会通知内核可以对等待队列里的一个或多个进程解除阻塞。如果没有锁竞争,内核则不需要参与其中。

2. pthread中的互斥量：

Pthread提供许多可以用来同步线程的函数。其基本机制是使用一个可以被锁定和解锁的互斥量来保护每个临界区。一个线程如果想要进入临界区，它首先尝试锁住相关的互斥量。如果互斥量没有加锁,那么这个线程可以立即进入，并且该互斥量被自动锁定以防止其他线程进入。如果互斥量已经被加锁,则调用线程被阻塞，直到该互斥量被解锁。如果多个线程在等待同一个互斥量，当它被解锁时，这些等待的线程中只有一个被允许运行并将互斥量重新锁定。这些互斥锁不是强制性的，而是由程序员来保证线程正确地使用它们。

与互斥量相关的pthread调用↓：
|线程调用|描述|
|:-:|:-:|
|pthread_mutex_init|创建一个互斥量|
|pthread_mutex_destroy|撤销一个已存在的互斥量|
|pthread_mutex_lock|获得一个锁或阻塞|
|pthread_mutex_tyrlock|获得一个锁或失败|
|pthread_mutex_unlock|释放一个锁|

除互斥量之外，pthread提供了另一种同步机制:**条件变量**。互斥量在允许或阻塞对临界区的访问上是很有用的，条件变量则允许线程由于一些未达到的条件而阻塞。绝大部分情况下这两种方法是一起使用的。条件变量允许等待与阻塞原子性的进行。值得指出的是，条件变量(不像信号量)不会存在内存中。如果将一个信号量传递给一个没有线程在等待的条件变量，那么这个信号就会丢失。程序员必须小心使用避免丢失信号。

与条件变量相关的pthread调用↓：
|线程调用|描述|
|:-:|:-:|
|pthread_cond_init|创建一个条件变量|
|pthread_cond_destroy|撤销一个条件变量|
|pthread_cond_wait|阻塞以等待一个信号|
|pthread_cond_signal|向另一个线程发信号来唤醒它|
|pthread_cond_broadcast|向多个线程发信号来让他们全部唤醒|

利用线程解决生产者-消费者问题↓：
```C
#include <stdio.h>
#include <pthread.h>
#define MAX 10000	// 需要生产的数量
pthread_mutex_t the_mutex;	// 互斥量
pthread_cond_t condc, condp;	// 消费者/生产者信号量
int buffer = 0;	// 缓冲区数据

void *produce(void *ptr) {	// 生产者
	int i;

	for (int i = 1; i <= MAX; ++i) {
		pthread_mutex_lock(&the_mutex)	// 互斥使用缓冲区
		while (buffer != 0) // 缓冲区内已经有数据
			pthread_cond_wait(&condp, &the_mutex);
		buffer = i; // 将数据放入缓冲区
		pthread_cond_signal(&condc)	// 唤醒消费者
		pthread_mutex_unlock(&the_mutex);	// 释放缓冲区
	}
	pthread_exit(0);
}

void *consumer(void *ptr) {	// 消费者
	int i;

	for (int i = 1; i < MAX; ++i) {
		pthread_mutex_lock(&the_mutex)	// 互斥使用缓冲区
		while (buffer == 0) // 缓冲区内没有数据
			pthread_cond_wait(&condc, &the_mutex);
		buffer = 0; // 从缓冲区中取出数据并清空缓冲区
		pthread_cond_signal(&condp);	// 唤醒生产者
		pthread_mutex_unlock(&the_mutex);	// 释放缓冲区
	}
	pthread_exit(0);
}

int main(int argc, char **argv) {
	pthread_t pro, con;
	pthread_mutex_init(&the_mutex, 0);

	pthread_cond_init(&condc, 0);
	pthread_cond_init(&condp, 0);

	pthread_create(&con, 0, consumer, 0);
	pthread_create(&pro, 0, producer, 0);

	pthread_join(pro, 0);
	pthread_join(con, 0);

	pthread_cond_destroy(&condc);
	pthread_cond_destroy(&condp);
	pthread_mutex_destroy(&the_mutex);
}
```

使一个线程睡眠的语句应该总是要检查条件，以保证线程在继续执行前满足条件，因为线程可能已经因为一个UNIX信号或其他原因而被唤醒。

### 2.3.7 管程

**管程(monitor)**：一个管程是一个由过程、变量及数据结构等组成的一个集合,它们组成一个特殊的模块或软件包。进程可在任何需要的时候调用管程中的过程,但它们不能在管程之外声明的过程中直接访问管程内的数据结构。下列代码展示了用一种抽象的、类Pascal语言描述的管程。这里不能使用C语言,因为管程是语言概念而C语言并不支持它。

```pascal
monitor example
	integer i;
	condition c;

	procedure producer();
	...
	end;

	procedure consumer();
	...
	end;
end monitor;
```
管程有一个很重要的特性，即任意时刻管程中只能有一个活跃进程,这一特性使管程能有效地完成互斥。管程是编程语言的组成部分,编译器知道它们的特殊性,因此可以采用与其他过程调用不同的方法来处理对管程的调用。典型的处理方法是,当一个进程调用管程过程时,该过程中的前几条指令将检查在管程中是否有其他的活跃进程。如果有,调用进程将被挂起,直到另一个进程离开管程将其唤醒。如果设有活跃进程在使用管程,则该调用进程可以进入。

进入管程时的互斥由编译器负责,但通常的做法是用一个互斥量或二元信号量。因为是由编译器而非程序员来安排互斥,所以出错的可能性要小得多。在任一时刻,写管程的人无须关心编译器是如何实现互斥的。他只需知道将所有的临界区转换成管程过程即可,决不会有两个进程同时执行临界区中的代码。

尽管管程提供了一种实现互斥的简便途径，但还需要一种办法使得进程在无法继续运行时被阻塞。解决的方法是引入条件变量以及两个相关的操作:wait和signal。当一个管程过程发现它无法继续运行时,它会在某个条件变量上执行wait操作。该操作导致调用进程自身阻塞,并且还将另一个以前等在管程之外的进程调入管程。另一个进程,可以唤醒正在睡眠的伙伴进程,这可以通过对其伙伴正在等待的一个条件变量执行signal完成。为了避免管程中同时有两个活跃进程,我们需要一条规则来通知在signal之后该怎么办。一是让新唤醒的进程运行,而挂起另一个进程。二是执行signal的进程必须立即退出管程,即signal语句只可能作为一个管程过程的最后一条语句。三是让发信号者继续运行，并且只有在发信号者退出管程之后，才允许等待的进程开始运行以后将采用方法二，因为它在概念上更简单,并且更容易实现。如果在一个条件变量上有若干进程正在等待,则在对该条件变量执行signal操作后,系统调度程序只能在其中选择一个使其恢复运行。

条件变量不是计数器,条件变量也不能像信号量那样积累信号以便以后使用。所以,如果向一个条件变量发送信号,但是在该条件变量上并没有等待进程,则该信号会永远丢失。换句话说,wait操作必须在signal之前。这条

类Pascal语言，通过管程实现生产者-消费者问题↓：
```pascal
monitor ProducerConsumer
	condition full, empty;
	integer count;

	procedure insert(item: integer);
	begin
		if count = N then wait(full);
		insert_item(item);
		count := count + 1;
		if count = 1 then signal(empty)
	end;

	function remove: integer;
	begin
		if count = 0 then wait(empty);
		remove = remove_item;
		count := count - 1;
		if count = N - 1 then signal(full)
	end;

	count := 0
end monitor

procedure producer;
begin
	while true do
	begin
		item = produce_item;
		ProducerConsumer.insert(item)
	end
end;

procedure consumer;
begin
	while true do
	begin
		item = ProducerConsumer.remove;
		consume_item(item)
	end
end;
```

wait和signal操作看起来像前面提到的sleep和wakeup,而且已经看到后者存在严重的竞争条件。是的,它们确实很像,但是有个很关键的区别:sleep和wakeup之所以失败是因为当一个进程想睡眠时另一个进程试图去唤醒它。使用管程则不会发生这种情况。对管程过程的自动互斥保证了这一点:如果管程过程中的生产者发现缓冲区满,它将能够完成wait操作而不用担心调度程序可能会在wait完成之前切换到消费者。甚至,在wait执行完成而且把生产者标志为不可运行之前,根本不会允许消费者进入管程。

JAVA支持用户级线程,还允许将方法(过程)划分为类。只要将关键字synchronized加入到方法声明中,Java保证一旦某个线程执行该方法,就不允许其他线程执行该对象中的任何synchronized方法。没有关键字synchronized,就不能保证没有交错执行。

用JAVA语言实现的生产者-消费者问题的解法↓：
```JAVA
public class ProducerConsumer {
	static final int N = 100;	// 缓冲区大小
	static producer p = new producer();	// 初始化生产者线程
	static consumer c = new consumer();	// 初始化消费者线程
	static our_monitor mon = new our_monitor();	// 初始化管程

	public static void main(String args[]) {
		p.start();	// 开始生产者线程
		c.start();	// 开始消费者线程
	}

	static class producer extends Thread {	// 生产者
		public void run() {
			int item;
			while (true) {
				item = producer_item();
				mon.insert(item);
			}
		}

		private int produce_item() {...}	// 实际生产代码
	}

	static class consumer extends Thread {	// 消费者
		public void run() {
			int item;
			while (true) {
				item = mon.remove();
				consuem_item(item);
			}
		}

		private void consume_item(int item) {...}	// 实际消费代码
	}

	static class our_monitor {	// 管程
		private int buffer[] = new int[N];
		private int count = 0, lo = 0, hi = 0;	// 计数器和索引

		public synchronized void insert(int val) {
			if (count == N)
				go_to_sleep();	// 如果缓冲区满，则进入休眠
			buffer[hi] = val;	// 向缓冲区中插入一个新的数据项
			hi = (hi + 1) % N;	// 设置下一个数据项的槽
			count = count + 1;	// 缓冲区中的数据项数据加1
			if (count == 1)
				notify();	// 如果消费者在休眠，则将其唤醒
		}

		public synchronized int remove() {
			int val;
			if (count == 0)
				go_to_sleep();	// 如果缓冲区空，进入休眠
			val = buffer[lo];	// 从缓冲区中取出一个数据项
			lo = (lo + 1) % N;	// 设置待取数据项的槽
			count = count - 1;	// 缓冲区中的数据项数目减少1
			if (count == N - 1)
				notify()	// 如果生产者在休眠，则将其唤醒
			return val;
		}

		private void go_to_sleep() {
			try {
				wait();
			} catch(InterruptedException exc) {};
		}
	}
}
```

Java中的同步方法与其他经典管程有本质差别:Java没有内置的条件变量。反之,Java提供了两个过程wait和notify,分别与sleep和wakeup等价,不过,当它们在同步方法中使用时,它们不受竞争条件约束。理论上,方法wait可以被中断,它本身就是与中断有关的代码。Java需要显式表示异常处理。在本文的要求中,只要认为go_to_sleep就是去睡眠即可。

通过临界区互斥的自动化，管程比信号量更容易保证并行编程的正确性，但管程是一个编程语言概念，编译器必须要识别管程并用某种方式对其互斥作出安排。C、Pascal以及多数其他语言都没有管程。

### 2.3.8 消息传递

消息传递这种进程间通信的方法使用两条原语send和receive，它们像信号量而不像管程，是系统调用而不是语言成分。因此，可以很容易地将它们加入到库例程中去。例如：`send(destination, &message);`向一个给定的目标发送一条消息，`receive(source, &message>;`从一个给定的源(或任意源)接受一条消息。如果没有消息可用，则接受者可能被阻塞，直到一条消息到达，或者带着一个错误码立即返回

用N条消息实现的生产者-消费者问题↓：
```C
#define N 100	// 缓冲区中的槽数目

void producer(void) {
	int item;
	message m;	// 消息缓冲区

	while (TRUE) {
		item = produce_item();	// 产生放入缓冲区的一些数据
		receive(consumer, &m);	// 等待消费者发送空缓冲区
		build_message(&m, item);// 建立一个待发送的消息
		send(consumer, &m);		// 发送数据项给消费者
	}
}

void consumer(void) {
	int item, i;
	message m;
	for (i = 0; i < N; ++i)
		send(producer, &m);	// 发送N个空缓冲区
	while (TRUE) {
		receive(producer, &m);	// 接收包含数据项的消息
		item = extract_item(&m);// 将数据项从消息中提取出来
		send(producer, &m);		// 将空缓冲区发送回生产者
		consume_item(item);		// 处理数据项
	}
}
```

消息传递方式可以有许多变体,下面首先介绍如何对消息进行编址。一种方法是为每个进程分配一个唯一的地址,让消息按进程的地址编址。另一种方注是引入一种新的数据结构,称作**信箱**。信箱是一个用来对一定数量的消息进行缓冲的地方,信箱中消息数量的设置方法也有多种,典型的方法是在信箱创建时确定消息的数量。当使用信箱时,在send和receive调用中的地址参数就是信箱的地址,而不是进程的地址。当一个进程试图向一个满的信箱发消息时,它将被挂起,直到信箱内有消息被取走,从而为新消息腾出空间。当使用信箱时，缓冲机制的作用是很清楚的：目标信箱容纳那些已被发送但尚未被目标进程接收的消息

使用信箱的另一种极端方法是彻底取消缓冲。采用这种方法时,如果send在receive之前执行,则发送进程被阻塞,直到receive发生。在执行receive时,消息可以直接从发送者复制到接收者,不用任何中间缓冲。类似地,如果先执行receive,则接收者会被阻塞,目到send发生。这种方案常被称为**会合**。与带有缓冲的消息方案相比,该方案实现起来更容易一些,但却降低了灵活性,因为发送者和接收者一定要以步步紧接的方式运行。

### 2.3.9 屏障

最后一个同步机制是准备用于进程组而不是用于双进程的生产者一消费者类情形的。在有些应用中划分了若干阶段,并且规定,除非所有的进程都就绪准备着手下一个阶段,否则任何进程都不能进入下一个阶段。可以通过在每个阶段的结尾安置**屏障**(barrier)来实现这种行为。当一个进程到达屏障时,它就被屏障阻拦,直到所有进程都到达该屏障为止。屏障可用于一组进程同步

### 2.3.10 避免锁：读-复制-更新

读-复制-更新：将更新过程中的移除和再分配过程分离开来

## 2.4 调度

如果只有一个CPU可用，那么就必须选择下一个要运行的进程。在操作系统中，完成选择工作的这一部分称为**调度程序**，该程序使用的算法称为**调度算法**

### 2.4.1 调度简介

为了选取正确的进程运行,调度程序还要考虑CPU的利用率,因为进程切换的代价是比较高的。首先用户态必须切换到内核态;然后要保存当前进程的状态,包括在进程表中存储寄存器值以便以后重新装载。在许多系统中,内存映像(例如,页表内的内存访问位)也必须保存;接着,通过运行调度算法选定一个新进程;之后,应该将新进程的内存映像重新装入MMU;最后新进程开始运行。除此之外,进程切换还要使整个内存高速缓存失效,强迫缓存从内存中动态重新装入两次(进入内核一次,离开内核一次)。总之,如果每秒钟切换进程的次数太多,会耗费大量CPU时间

1. 进程行为

I/O活动：当一个进程等待外部设备完成工作而被阻塞时为I/O活动

计算密集型进程：具有较长时间的CPU集中使用和较小频度的I/O等待

I/O密集型进程：具有较短时间的CPU集中使用和频繁的I/O等待

2. 何时调度

有关调度处理的一个关键问题是何时进行调度决策。存在着需要调度处理的各种情形。第一,在创建一个新进程之后,需要决定是运行父进程还是运行子进程。第二,在一个进程退出时必须做出调度决策。第三,当一个进程阻塞在I/O和信号量上或由于其他原因阻塞时,必须选择另一个进程运行。第四,在一个I/O中断发生时,必须做出调度决策。

根据如何处理时钟中断，可以把调度算法分为两类：**非抢占式**调度算法挑选一个进程，然后让该进程运行直至被阻塞(阻塞在I/O上或等待另一个进程)，或者直到该进程自动释放CPU。这样做的结果是，在时钟中断发生时不会进行调度。在处理完时钟中断后，如果没有更高优先级的进程等待到时，则被中断的进程会继续执行。**抢占式**调度算法挑选一个进程，并且让该进程运行某个固定时段的最大值。如果在该时段结束时，该进程仍在运行，它就被挂起，而调度程序挑选另一个进程运行(如果存在一个就绪进程)。进行抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把CPU控制返回给调度程序。如果没有可用的时钟，那么非抢占式调度就是唯一的选择了

3. 调度算法分类

批处理系统在商业领域仍在广泛应用。在批处理系统中,不会有用户不耐烦地在终端旁等待一个短请求的快捷响应。因此,非抢占式算法,或对每个进程都有长时间周期的抢占式算法,通常都是可接受的。这种处理方式减少了进程的切换从而改善了性能。这些批处理算法实际上相当普及,经常可以应用在其他场合

在交互式用户环境中,为了避免一个进程霸占CPU拒绝为其他进程服务,抢占是必需的。即便没有进程想永远运行，但是，某个进程由于一个程序错误也可能无限期地排斥所有其他进程。为了避免这种现象发生，抢占也是必要的。服务器也归于此类，因为通常他们要服务多个突发的用户。

然而在有实时限制的系统中,抢占有时是不需要的,因为进程了解它们可能会长时间得不到运行,所以通常很快地完成各自的工作并阻塞。实时系统与交互式系统的差别是,实时系统只运行那些用来推进现有应用的程序,而交互式系统是通用的,它可以运行任意的非协作甚至是有恶意的程序。

4. 调度算法的目标

不同环境中调度算法的一些目标↓：

|所有系统||
|:-:|:-:|
|公平|给每个进程公平的CPU份额|
|策略强制执行|保证规定的策略被执行|
|平衡|保持系统的所有部分都忙碌|

|批处理系统||
|:-:|:-:|
|吞吐量|每小时最大作业数|
|周转时间|从提交到终止间的最小时间|
|CPU利用率|保持CPU始终忙碌|

|交互式系统||
|:-:|:-:|
|相应时间|快速相应请求|
|均衡性|满足用户的期望|
|实时系统||
|满足截止时间|避免丢失数据|
|可预测性|在多媒体系统中避免品质降低|

### 2.4.2 批处理系统中的调度

1. 非抢占式的先来先服务算法：进程按照他们请求CPU的顺序使用CPU。当正在运行的进程被阻塞时,就绪队列中的第一个进程接着运行。当在被阻塞的进程变为就绪时,就像一个新来到的作业一样,排到就绪队列的未尾,即排在所有进程最后。优点：易于理解并且便于在程序中运用

2. 非抢占式的最短作业优先：只有在所有的作业都可同时运行的情形下，最短作业优先算法才是最优化的

3. 抢占式的最短剩余时间优先：调度程序总是选择剩余运行时间最短的那个进程运行。当一个新的作业到达时，其整个时间同当前进程的剩余时间作比较。如果新的进程比当前运行进程需要更少的时间，当前进程就被挂起。这种方式可以使新的短作业获得良好的服务

### 2.4.3 交互式系统中的调度

1. 轮转调度：每个进程被分配一个时间段，称为**时间片**，即允许该进程在该时间段中运行。如果在时间片结束时该进程还在运行，则将剥夺CPU并分配给另一个进程。如果该进程在时间片结束前阻塞或者结束，则CPU立即进行切换。

时间片设得太短会导致过多的进程切换，降低了CPU效率；而设得太长有可能引起对短的交互请求的响应时间变长。将时间片设为20~50ms通常是一个比较合理的折中

2. 优先级调度：每个进程被赋予一个优先级，允许优先级最高的可运行进程先运行

为了防止高优先级进程无休止地运行下去,调度程序可能在每个时钟滴答(即每个时钟中断)降低当前进程的优先级。如果这一行为导致该进程的优先级低于次高优先级的进程,则进行进程切换。另一种方法是,给每个进程赋予一个允许运行的最大时间片,当用完这个时间片时,次高优先级的进程便获得运行机会

可以很方便地将一组进程按优先级分成若干类，并且在各类之间采用优先级调度，而在各类进程的内部采用轮转调度

3. 多级队列

设立优先级类，属于最高优先级类的进程运行一个时间片，属于次高优先级类的进程运行两个时间片，再次一级运行4个时间片，以此类推。当一个进程用完分配的时间片后，它被移到下一类

4. 最短进程优先

可以通过首先运行最短的作业来使响应时间最短

可以根据进程过去的行为进行推测并执行估计运行时间最短的那一个。把通过当前测量值和先前估计值进行加权平均而得到下一个估计值的技术称作**老化**(就是低通滤波)

1. 保证调度

一种完全不同的调度算注是向用户作出明确的性能保证,然后去实现它。一种很实际并很容易实现的保证是:若用户工作时有n个用户登录,则用户将获得CPU处理能力的1/n。类似地,在一个有n个进程运行的单用户系统中,若所有的进程都等价,则每个进程将获得1/n的CPU时间。看上去足够公平了。

为了实现所做的保证,系统必须跟踪各个进程自创建以来已使用了多少CPU时间。然后它计算各个进程应获得的CPU时间,即自创建以来的时间除以n。由于各个进程实际获得的CPU时间是已知的,所以很容易计算出真正获得的CPU时间和应获得的CPU时间之比。比率为0.5说明一个进程只获得了应得时间的一半,而比率为2.0则说明它获得了应得时间的2倍。于是该算法随后转向比率最低的进程,直到该进程的比率超过它的最接近竞争者为止。

6. 彩票调度

基本思想是为进程提供各种系统资源的彩票，一旦需要做出一项调度决策时，就随机抽出一张彩票，拥有该彩票的进程获得该资源

彩票调度是反应迅速的(新增进程可以立即抽奖)

7. 公平分享调度

某些系统在调度之前考虑谁拥有进程这一因素。在这种模式中，每个用户分配到CPU时间的一部分，而调度程序以一种强制的方式选择进程。这样，如果两个用户都得到获得50%CPU时间的保证，那么无论一个用户有多少进程存在，每个用户都会得到应有的CPU份额

### 2.4.4 实时系统中的调度

**硬实时**：必须满足绝对的截止时间。**软实时**：虽然不希望偶尔错失截止时间，但是可以容忍

实时性能都是通过把程序划分为一组进程而实现的,其中每个进程的行为是可预测和提前掌握的。这些进程一般寿命较短,并且极快地运行完成。在检测到一个外部信号时,调度程序的任务就是按照满足所有截止时间的要求调度进程。

**可调度的**实时系统：进程共同需要的CPU时间总和小于CPU能提供的时间。$\sum_{i=1}^m\frac{Ci}{Pi}\leq1$，其中m为周期时间数，事件i以周期Pi发生，并需要Ci秒CPU时间处理。这个计算中隐含了上下文切换的开销很小的假设

实时系统的调度算法可以是静态或动态的。前者在系统开始运行之前作出调度决策;后者在运行过程中进行调度决策。只有在可以提前掌握所完成的工作以及必须满足的截止时间等全部信息时,静态调度才能工作,而动态调度算法不需要这些限制。

### 2.4.5 策略和机制

当若干进程都有多个线程时,就存在两个层次的并行:进程和线程。在这样的系统中调度处理有本质差别,这取决于所支持的是用户级线程还是内核级线程(或两者都支持)。

首先考虑**用户级线程**。由于内核并不知道有线程存在,所以内核还是和以前一样地操作,选取一个进程,假设为A,并给予A以时间片控制。A中的线程调度程序决定哪个线程运行,假设为A1。由于多道线程并不存在时钟中断,所以这个线程可以按其意愿任意运行多长时间。如果该线程用完了进程的全部时间片,内核就会选择么一个进程运行。

在进程A终于又一次运行时,线程A1会接着运行。该线程会继续耗费A进程的所有时间,直到它完成工作。不过,该线程的这种不合群的行为不会影响到其他的进程。其他进程会得到调度程序所分配的合适份额,不会考虑进程A内部所发生的事。

现在考虑A线程每次CPU计算的工作比较少的情况,例如,在50ms的时间片中有5ms的计算工作。于是,每个线程运行一会儿,然后把CPU交回给线程调度程序。这样在内核切换到进程B之前,就会有序列A1,A2,A3,A1,A2,A3,A1,A2,A3,A11

从使用考虑，轮转调度和优先级调度更为常用。唯一的局限是，缺乏一个时钟中断运行过长的线程。但由于线程之间的合作关系，这通常也不是问题

现在考虑使用**内核级线程**的情形。内核选择一个特定的线程运行。它不用考虑该线程属于哪个进程,不过如果有必要的话,它可以这样做。对被选择的线程赋予一个时间片,而且如果超过了时间片,就会强制挂起该线程。一个线程在30ms的时间片内,5ms之后被阻塞,在30ms的时间段中,线程的顺序会是A1,B1,A2,B2,A3,B3,在这种参数和用户线程状态下,有些情形是不可能出现的。

用户级线程和内核级线程之间的**差别**在于性能。用户级线程的线程切换需要少量的机器指令,而内核级线程需要完整的上下文切换,修改内存映像,使高速缓存失效,这导致了若干数量级的延迟。另一方面,在使用内核级线程时,一旦线程阻塞在I/O上就不需要像在用户级线程中那样将整个进程挂起。

从进程A的一个线程切换到进程B的一个线程,其代价高于运行进程A的第2个线程(因为必须修改内存映像,清除内存高速缓存的内容),内核对此是了解的,并可运用这些信息做出决定。例如,给定两个在其他方面同等重要的线程,其中一个线程与刚好阻塞的线程属于同一个进程,而另一个线程属于其他的进程,那么应该倾向前者。

另一个重要因素是用户级线程可以使用专为应用程序定制的线程调度程序。而在内核级线程中,内核从来不了解每个线程的作用(虽然它们被赋予了不同的优先级)。不过,一般而言,应用定制的线程调度程序能够比内核更好地满足应用的需要。

## 2.5 经典的IPC问题

### 2.5.1 哲学家就餐问题

问题描述：五个哲学家围坐在一张圆桌周围,每个哲学家面前都有一盘通心粉。由于通心粉很滑,所以需要两把叉子才能夹住。相邻两个盘子之间放有一把叉子，总共五把叉子。哲学家的生活中有两种交替活动时段：吃饭和思考。当一个哲学家觉得饿了时，他就试图分两次去取左边和右边的叉子，每次拿一把，但不分次序。如果成功地得到了两把叉子，就开始吃饭，吃完后放下叉子继续思考。关键问题是：能为每一个哲学家写一段描述其行为的程序，且绝不会死锁吗？

**饥饿**：所有的程序都在不停地运行，但都无法取得进展

哲学家就餐问题的一个解法↓：
```C
#define N 5	// 哲学家数目
#define LEFT (i+N-1)%N	// i的左邻居编号
#define RIGHT (i+1)%N	// i的右邻居编号
#define THINKING 0	// 哲学家在思考
#define	HUNGRY 1	// 哲学家试图拿起叉子
#define EATING 2	// 哲学家进餐

typedef int semaphore;	// 信号量是一种特殊的整型数据
int state[N];	// 数组用来跟踪记录每位哲学家的状态
semaphore mutex = 1;	// 临界区的互斥
semaphore s[N];	// 每位哲学家一个信号量

void philosopher(int i) {
	// i: 哲学家编号
	while (TRUE)
		;
}

void take_forks(int i) {
	// i: 哲学家编号
	down(&mutex);	// 进入临界区
	state[i] = HUNGRY;	// 记录哲学家i处于饥饿状态
	test(i);	// 尝试获取两把叉子
	up(&mutex);	// 离开临界区
	down(&s[i]);// 如果得不到需要的叉子则阻塞
}

void put_forks(int i) {
	// i: 哲学家编号
	down(&mutex);	// 进入临界区
	state[i] = THINKING;	// 哲学家已经就餐完毕
	test(LEFT);	// 检查左边的邻居现在可以吃吗
	test(RIGHT);// 检查右边的邻居现在可以吃吗
	up(&mutex);	// 离开临界区
}

void test(int i) {
	// i: 哲学家编号
	if (state[i] == HUNGRY &&
		state[LEFT] != EATING &&
		state[RIGHT] != EATING) {

		state[i] = EATING;
		up(&s[i]);
	}
}
```

### 2.5.2 读者-写者问题

读者-写者问题的一种解法↓：
```C
typedef int semaphore;	// 信号量是一种特殊的整型数据
semaphore mutex = 1;	// 控制对rc的访问
semaphore db = 1;	// 控制对数据库的访问
int rc = 0;	// 正在读或者即将读的进程数目

void reader(void) {	// 读者
	while (TRUE) {
		down(&mutex);	// 获得对rc的互斥访问权
		rc = rc + 1;	// 读者数目加1
		if (rc == 1)	// 如果为第一个读者
			down(&db);	// 阻塞写者对数据库的访问
		up(&mutex);	// 释放对rc的互斥访问

		read_data_base();	// 访问数据

		down(&mutex);	// 获取对rc的互斥访问
		rc = rc - 1;	// 读者数目减1
		if (rc == 0)	// 如果为最后一个读者
			up(&db);	// 允许一个被阻塞的写者(如果存在的话)可以访问该数据库
		up(&mutex);	// 释放对rc的互斥访问

		use_data_read();// 非临界区
	}
}

void writer(void) {	// 写者
	while (TRUE) {
		think_up_data();	// 非临界区
		down(&db);	// 获取互斥访问
		write_data_base();	// 更新数据
		up(&db);	// 释放互斥访问
	}
}
```

## 2.7 小结

为了隐藏中断的影响,操作系统提供了一个并行执行串行进程的概念模型。进程可以动态地创建和终止,每个进程都有自己的地址空间。

对于某些应用而言,在一个进程中使用多个线程是有益的。这些线程被独立调度并且有独立的栈,但是在一个进程中的所有线程共享一个地址空间。线程可以在用户态实现,也可以在内核态实现。

进程之间通过进程间通信原语来交换信息,如信号量、管程和消息。这些原语用来确保不会有两个进程同时在临界区中,以避免出现混乱。一个进程可以处在运行、就绪或阻塞状态,当该进程或其他进程执行某个进程间通信原语时,可以改变其状态。线程间的通信也类似。

进程间通信原语可以用来解决诸如生产者-消费者问题、哲学家就餐问题、读者-写者问题和睡眠理发师问题等。但即便有了这些原语,也要仔细设计才能避免出错和死锁。

目前已经有大量成熟的调度算法。一些算法主要用于批处理系统中,如最短作业优先调度算法。其他算法在批处理系统和交互式系统中都很常见,如轮转调度、优先级调度、多级队列调度、有保证调度、彩票调度以及公平分享调度等。有些系统清晰地分离了调度策略和调度机制,使用户可以配置调度算法
