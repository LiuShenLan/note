- [12. 操作系统设计](#12-操作系统设计)
	- [12.1 设计问题的本质](#121-设计问题的本质)
		- [12.1.1 目标](#1211-目标)
		- [12.1.2 设计操作系统为什么困难](#1212-设计操作系统为什么困难)
	- [12.2 接口设计](#122-接口设计)
		- [12.2.1 指导原则](#1221-指导原则)
	- [12.3 实现](#123-实现)
	- [12.4 性能](#124-性能)
	- [12.5 项目管理](#125-项目管理)
		- [12.5.1 人月神话](#1251-人月神话)
	- [12.7 小结](#127-小结)

# 12. 操作系统设计

## 12.1 设计问题的本质

### 12.1.1 目标

通用操作系统的四个基本要素：定义抽象概念、提供基本操作、确保隔离、管理硬件

一个操作系统最重要但可能最困难的任务是定义正确的抽象概念

每一个抽象概念可以通过具体数据结构的形式来实例化。基本操作以系统调用的形式实现。从用户的观点来看，操作系统的核心是由抽象概念与其上的基本操作所构成的，而基本操作则可通过系统调用加以利用

由于某些计算机上的多个用户可以同时登录到一台计算机，操作系统需要提供机制将他们隔离。一个用户不可以干扰另一个用户。为了保护的目的，进程概念广泛地用于将资源集合在一起。文件和其他数据结构一般也是受保护的。另一个需要隔离的方面是虚拟化:管理程序必须确保虚拟机之间不会互相干扰。确保每个用户只能在授权的数据上执行授权的操作是系统设计的关键目标。然而用户还希望共享数据和资源，因此隔离必须是选择性的并且要在用户的控制之下。这就使问题更加复杂化了。即使只有一个用户，不同的进程也应该隔离开来。在一些系统中(比如Android)，同一个用户启动不同的进程时会分配不同的用户ID，以此来进行进程间隔离

与这一要点密切相关的是需要隔离故障。如果系统的某一部分崩溃(最为一般的是一个用户进程崩溃)，不应该使系统的其余部分随之崩溃。系统设计应该确保系统的不同部分良好地相互隔离。从理想的角度看，操作系统的各部分也应该相互隔离，以便使故障独立。操作系统也应该具有容错性和自我恢复的功能

操作系统必须管理硬件。特别地，它必须处理所有低级芯片，例如中断控制器和总线控制器。它还必须提供一个框架，从而使设备驱动程序得以管理更大型的I/O设备

### 12.1.2 设计操作系统为什么困难

设计一个操作系统比设计一个应用程序更加困难的原因

1. 操作系统已经成为极其庞大的程序。操作系统不是世界上最复杂的系统，但在操作系统中存在着耦合，文件系统经常以意外和无法预料的方式与内存系统相互作用

2. 操作系统必须处理并发。系统中往往存在多个用户和多个设备同时处于活动状念。管理并发自然要比管理单一的顺序活动复杂得多。竞争条件和死锁只是出现的众多问题中的两个

3. 操作系统必须处理可能有敌意的用户---想要干扰系统的用户或者做不允许做的事情的用户。操作系统需要采取措施阻止这些用户不正当的行为

4. 尽管事实上并非所有的用户都相信其他用户，但是许多用户确实希望与经过选择的其他用户共享他们的信息和资源。操作系统必须使其成为可能，但是要以确保怀有恶意的用户不能妨害的方式

5. 操作系统已经问世很长时间了。因此设计人员必须思考硬件和应用程序在遥远的未来可能会发生何种变化，并且考虑为这样的变化做怎样的准备。被锁定在一个特定视野中的系统通常会死亡

6. 操作系统设计人员对于他们的系统将怎样被人使用实际上并没有确切的概念，所以他们需要提供相当程度的通用性。

7. 现代操作系统一般被设计成可移植的，这意味着它们必须运行在多个硬件平台上。它们还必须支持上千个I/O设备，所有这些I/O设备都是独立设计的，彼此之间没有关系。这样的差异可能会导致问题

8. 操作系统经常需要与某个从前的操作系统保持向后兼容。以前的那个系统可能在字长、文件名或者其他方面有所限制，而在设计人员现在看来这些限制都是过时的，但是却必须坚持

## 12.2 接口设计

操作系统提供了一组抽象，主要是数据类型(例如文件)以及其上的操作(例如read)。它们合起来形成了对用户的接口。注意在这一上下文中操作系统的用户是指编写使用系统调用的代码的程序员,而不是运行应用程序的人员

除了主要的系统调用接口，大多数操作系统还具有另外的接口。例如某些程序员需要编写插入到操作系统中的设备驱动程序。这些驱动程序可以看到操作系统的某些功能特性并且能够发出某些过程调用。这些功能特性和调用也定义了接口，但是与应用程序员看到的接口完全不同。如果一个系统要取得成功，所有这些接口都必须仔细设计

### 12.2.1 指导原则

简单、完备、效率

## 12.3 实现

1. 系统结构

**分层系统**

**外内核**：基于端到端问题，如果某件事情必须由用户程序本身去完成，在一个较低的层次做同样的事情就是浪费

**介于微内核的客户-服务器系统**：在让操作系统做每件事情和让操作系统什么也不做之间的折衷是让操作系统做一点事情。这一设计导致微内核的出现，它让操作系统的大部分作为用户级的服务器进程而运行。在所有设计中这是最模块化和最灵活的。在灵活性上的极限是让每个设备驱动程序也作为一个用户进程而运行，从而完全保护内核和其他驱动程序，但是让设备驱动程序运行在内核会增加模块化程度

**可扩展的系统**：对于上面讨论的客户-服务器系统，思想是让尽可能多的东西脱离内核。相反的方法是将更多的模块放到内核中，但是以一种"受保护的"方式。当然，这里的关键字是受保护的。当然可扩展的系统自身并不是构造一个操作系统的方法。然而通过以一个只是包含保护机制的最小系统为开端，然后每次将受保护的模块添加到内核中，直到达到期望的功能，对于手边的应用而言一个最小的系统就建立起来了。按照这一观点，对于每一个应用，通过仅仅包含它所需要的部分，就可以拼装出一个新的操作系统

**内核线程**：此处另一个相关的问题是系统线程。无论选择哪种结构模型，允许存在与任何用户进程相隔离的内核线程是很方便的。这些线程可以在后台运行，将脏页面写入磁盘，在内存和磁盘之间交换进程，如此等等。实际上内核本身可以完全由这样的线程构成，所以当一个用户发出系统调用时，用户的线程并不是在内核模式中运行，而是阻塞并且将控制传给一个内核线程，该内核线程接管控制以完成工作。除了在后台运行的内核线程以外，大多数操作系统还要启动许多守护进程。虽然这些守护进程不是操作系统的组成部分，但是它们通常执行"系统"类型的活动。这些活动包括接收和发送电子邮件，并且对远程用户各种各样的请求进行服务，例如FTP和Web网页

2. 机制与策略

另一个有助于体系结构一致性的原理是机制与策略的分离，该原理同时还有助于使系统保持小型和良好的结构。通过将机制放入操作系统而将策略留给用户进程，即使存在改变策略的需妥，系统伞身也可以保持不变。即使策略模块必须保留在内核中，它也应该尽可能地与机制相隔离，这样策略模块甲的变化就不会影响机制模块

3. 正交性

良好的系统设计在于单独的概念可以独立地组合。独立地组合单独的概念的能力称为**正交性**，它是简单性和完整性原理的直接结果

4. 命名

操作系统大多数较长使用的数据结构都具有某种名字或标识符，通过这些名字或标识符就可以引用这些数据结构。显而易见的例子有注册名、文件名、设备名、进程ID等。在操作系统的设计与实现中，如何构造和管理这些名字是一个重要的问题

5. 绑定的时机

正如我们刚刚看到的，操作系统使用多种类型的名字来引用对象。有时在名字和对象之间的映射是固定的，但是有时不是。在后一种情况下，何时将名字与对象绑定可能是很重要的。一般而言，**早期绑定**是简单的，但是不灵活，而**晚期绑定**则比较复杂，但是通常更加灵活

程序设计语言对于变量通常支持多种绑定时机。编译器将全局变量绑定到特殊的虚拟地址，这是早期绑定的例子。过程的局部变量在过程被调用的时刻(在栈中)分配一个虚拟地址，这是中间绑定。存放在堆中的变量(这些变量由C中的malloc或Java中的new分配)仅仅在它们实际被使用的时候才分配虚拟地址,这便是晚期绑定

操作系统对大多数数据结构通常使用早期绑定，但是偶尔为了灵活性也使用晚期绑定。内存分配是一个相关的案例。在缺乏地址重定位硬件的机器上，早期的多道程序设计系统不得不在某个内存地址装载一个程序，并且对其重定位以便在此处运行。如果它曾经被交换出去，那么它就必须装回到相同的内存地址，否则就会出错。相反页式虚拟内存是晚期绑定的一种形式,在页面被访问并且实际装入内存之前，与一个给定的虚拟地址相对应的实际物理地址是不知道的

6. 静态与动态结构

操作系统设计人员经常被迫在静态与动态数据结构之间进行选择。静态结构总是简单易懂，更加容易编程并且用起来更快;动态结构则更加灵活

7. 自顶向下与自底向上的实现

虽然最好是自顶向下地设计系统，但是在理论上系统可以自顶向下或者自底向上地实现。在**自顶向下**的实现中，实现者以系统调用处理程序为开端，并且探究需要什么机制和数据结构来支持它们。接着编写这些过程等,直到触及硬件。这种方法的问题是，由于只有顶层过程可用，任何事情都难于测试。出于这样的原因，许多开发人员发现实际上**自底向上**地构建系统更加可行。这一方法需要首先编写隐藏底层硬件的代码,中断处理程序和时钟驱动程序也是早期就需要的

8. 实用技术

隐藏硬件、引用、可重用性、重入(代码同时被执行两次或多次的能力)、蛮力法(针对很少调用的活成或者具有很少数据的操作)、首先检查错误

## 12.4 性能

1. 操作系统为什么运行缓慢

许多操作系统运行缓慢在很大程度上是操作系统自身造成的，另一个重要因素是产品的市场销售

2. 什么应该优化

唯一的优化应该是那些显而易见要称谓不可避免的问题的事情

3. 空间-时间的权衡

使用宏来代替小的过程，消除通常与过程调用相关联的开销

4. 缓存

用于改进性能的一项众所周知的技术是缓存。在任何相同的结果可能需要被获取多次的情况下，缓存都是适用的。一般的方法是首先做完整的工作，然后将结果保存在缓存中。对于后来的获取结果的工作，首先要检查缓存。如果结果在缓存中，就使用它。否则，再做完整的工作

5. 线索

缓存项总是正确的。缓存搜索可能失败，但是如果找到了一项，那么这一项保证是正确的并且无需再费周折就可以使用。在某些系统中，包含**线索**的表是十分便利的。这些线索是关于答案的提示,但是它们并不保证是正确的。调用者必须自行对结果进行验证

众所周知的关于线索的例子是嵌在Web页上的URL。点击一个链接并不能保证被指向的Web页就在那里。事实上，被指向的网页可能10年前就被删除了。因此包含URL的网页上面的信息只是一个线索

线索还用于连接远程文件。信息是提示有关远程文件某些事项的线索，例如文件存放的位置。然而自该线索被记录以来，文件可能已经被移动或者删除了，所以为了明确线索是否正确，总是需要对其进行检查

6. 利用局部性

进程和程序的行为并不是随机的，它们在时间上和空间上展现出相当程度的局部性，并且可以以各种方式利用该信息来改进性能。空间局部性的一个常见例子是：进程并不是在其地址空间内部随机地到处跳转的。在一个给定的时间间隔内，它们倾向于使用数目比较少的页面。进程正在有效地使用的页面可以被标记为它的工作集，并且操作系统能够确保当进程被允许运行时，它的工作集在内存中，这样就减少了缺页的次数

局部化原理对于文件也是成立的。当一个进程选择了一个特定的工作目录时，很可能将来许多文件引用将指向该目录中的文件。通过在磁盘上将每个目录的所有i节点和文件就近放在一起，可能会获得性能的改善。这一原理正是Berkeley快速文件系统的基础

局部性起作用的另一个领域是多处理器系统中的线程调度。正如我们在第8章中看到的，在多处理器上一种调度线程的方法是试图在最后一次用过的CPU上运行每个线程，期望它的某些内存块依然还在内存的缓存中

7. 优化常见的情况

区分最常见的情况和最坏可能的情况并且分别处理它们,这通常是一个好主意。针对这两者的代码常常是相当不同的。重要的是要使常见的情况速度快。对于最坏的情况，如果它很少发生，使其正确就足够了

## 12.5 项目管理

### 12.5.1 人月神话

《人月神话》作者Brooks编写操作系统的工作量估计：1/3规划、1/6编码、1/4模块测试、1/4系统测试

Brooks的书的标题来自他的断言，即人与时间是不可互换的。不存在"人月"这样的单位。如果一个项目需要15个人花2年时间构建，很难想象360个人能够在1个月内构建它，甚至让60个人在6个月内做出它或许也是不可能的。产生这一效应有三个原因：1. 工作不可能完全并行化。直到完成规划并且确定了需要哪些模块以及它们的接口,甚至都不能开始编码。对于一个2年的项目，仅仅规划可能就要花费8个月

2. 为了完全利用数目众多的程序员，工作必须划分成数目众多的模块，这样每个人才能有事情做。由于每个模块可能潜在地与每个其他模块相互作用,需要将模块---模块相互作用的数目看成随着模块数目的平方而增长，也就是说，随着程序员数目的平方而增长。这一复杂性很快就会失去控制。对于大型项目而言，人与月之间的权衡远不是线性的

3. 调试工作是高度序列化的。对于一个问题，安排10名调试人员并不会加快10倍发现程序错误。事实上，10名调试人员或许比一名调试人员还要慢，因为他们在相互沟通上要浪费太多的时间

对于人员与时间的权衡，Brooks将他的经验总结在Brooks定律中：对于一个延期的软件项目,增加人力将使它延期更久。增加人员的问题在于他们必须在项目中获得培训，模块必须重新划分以便与现在可用的更多数目的程序员相匹配，需要开许多会议来协调各方面的努力等

## 12.7 小结

操作系统的设计开始于确定它应该做什么。接口应该是简单、完备且高效的。应该拥有一个清晰的用户界面范型、执行范型和数据范型

系统应该具有良好的结构，使用若干种已知技术中的一种，例如分层结构或客户-服务器结构。内部组件应该是相互正交的，并且要清楚地分离策略与机制。大量的精力应该投入到诸如静态与动态数据结构、命名、绑定时机以及模块实现次序这样的一些问题上

性能是重要的，但是优化应该仔细地选择，从而使优化不至于破坏系统的结构。空间-时间权衡、高速缓存、线索、利用局部性以及优化常见的情况等技术通常都值得尝试

两三个人编写一个系统与300个人生产一个大型系统是不同的。在后一种情况下，团队结构和项目管理对于项目的成败起着至关重要的作用

最后，操作系统正在进行变革以跟上新的趋势和迎接新的挑战。这些趋势和挑战包括基于管理程序的系统、多核系统、64位地址空间、掌上无线计算机、嵌入式系统。毫无疑问，对于操作系统设计人员来说今后几年将十分令人激动