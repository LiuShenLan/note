- [4. 文件系统](#4-文件系统)
	- [4.1 文件](#41-文件)
		- [4.1.1 文件命名](#411-文件命名)
		- [4.1.2 文件结构](#412-文件结构)
		- [4.1.3 文件类型](#413-文件类型)
		- [4.1.4 文件访问](#414-文件访问)
		- [4.1.5 文件属性](#415-文件属性)
		- [4.1.6 文件操作](#416-文件操作)
	- [4.2 目录](#42-目录)
		- [4.2.1 一级目录系统](#421-一级目录系统)
		- [4.2.2 层次目录系统](#422-层次目录系统)
		- [4.2.3 路径名](#423-路径名)
		- [4.2.4 目录操作](#424-目录操作)
	- [4.3 文件系统的实现](#43-文件系统的实现)
		- [4.3.1 文件系统布局](#431-文件系统布局)
		- [4.3.2 文件的实现](#432-文件的实现)
		- [4.3.3 目录的实现](#433-目录的实现)
		- [4.3.4 共享文件](#434-共享文件)
		- [4.3.5 日志结构文件系统](#435-日志结构文件系统)
		- [4.3.6 日志文件系统](#436-日志文件系统)
		- [4.3.7 虚拟文件系统](#437-虚拟文件系统)
	- [4.4 文件系统管理和优化](#44-文件系统管理和优化)
		- [4.4.1 磁盘空间管理](#441-磁盘空间管理)
		- [4.4.2 文件系统备份](#442-文件系统备份)
		- [4.4.3 文件系统的一致性](#443-文件系统的一致性)
		- [4.4.4 文件系统性能](#444-文件系统性能)
		- [4.4.5 磁盘碎片整理](#445-磁盘碎片整理)
	- [4.7 小结](#47-小结)

# 4. 文件系统

长期存储信息的三个基本要求：能够存储大量信息、使用信息的进程终止时，信息仍然存在、必须能使多个进程并发访问有关信息

在第5章会介绍更多有关磁盘的知识，目前可以先把磁盘当做一种大小固定的块的线性序列，并且支持如下两种操作：读块k和写块k。事实上磁盘支持更多的操作，但只要有了这两种操作，原则上就可以解决长期存储的问题

就像操作系统提取处理器的概念来建立进程的抽象,以及提取物理存储器的概念来建立进程(虚拟)地址空间的抽象那样,我们可以用一个新的抽象---文件来解决这个问题。进程(与线程)、地址空间和文件,这些抽象概念均是操作系统中最重要的概念

**文件**是进程创建的信息逻辑单元。一个磁盘一般含有几千甚至几百万个文件,每个文件是独立于其他文件的,唯一不同的是文件是对磁盘的建模,而非对RAM的建模

进程可以读取已经存在的文件,并在需要时建立新的文件。存储在文件中的信息必须是持久的,也就是说,不会因为进程的创建与终止而受到影响。一个文件只能在其所有者明确删除它的情况下才会消失。尽管读写文件是最常见的操作,但还有很多其他操作,其中一些将在下面加以介绍

文件是受操作系统管理的。有关文件的构造、命名、访问、使用、保护、实现和管理方法都是操作系统设计的主要内容。从总体上看,操作系统中处理文件的部分称为**文件系统**,这就是本章的论题

## 4.1 文件

### 4.1.1 文件命名

文件是一种抽象机制，它提供了一种在磁盘上保存信息而且方便以后读取的方法。这种方法可以使用户不必了解存储信息的方法、位置和实际磁盘工作方式等有关细节

有些文件系统区分大小写字母，如UNIX；有些则不区分大小写字母，如MS-DOS

许多操作系统支持文件名用圆点隔开分为两部分,圆点后面的部分称为**文件扩展名**,文件扩展名通常表示文件的一些信息

在某些系统中(如所有UNIX版本),文件扩展名只是一种约定,操作系统并不强迫采用它。与UNIX相反,Windows关注扩展名且对其赋予了含义。用户(或进程)可以在操作系统中注册扩展名,并且规定哪个程序"拥有"该扩展名。当用户双击某个文件名时,"拥有"该文件扩展名的程序就启动并运行该文件

### 4.1.2 文件结构

**字节序列**：文件是一种无结构的字节序列，事实上操作系统不知道也不关心文件内容是什么，操作系统所见到的就是字节，其文件内容的任何含义只在用户程序中解释。把文件看成字节序列为操作系统提供了最大的灵活性。用户程序可以向文件中加入任何内容，并以任何方便的形式命名。操作系统不提供任何帮助，但也不会构成障碍。对于想做特殊操作的用户来说，后者是非常重要的。所有UNIX版本(包括Linux和OS X)以及Windows都采用这用文件模型

**记录模型**：文件是具有固定长度记录的序列，每个记录都有其内部结构。把文件作为记录序列的中心思想是：读操作返回一个记录，而写操作重写或追加一个记录。现在已经没有使用这种文件系统的通用系统了

**树**：文件由一颗记录树构成，每个记录不必具有相同的长度，记录的固定位置上有一个**键**字段。这棵树按"键"字段进行排序，从而可以对特定"键"进行快速查找。虽然在这类结构中取"下一个"记录是可以的，但是基本操作并不是取"下一个"记录，而是获得具有特定键的记录，而不必关心记录在文件中的确切位置。用户可以在文件中添加新纪录，但是用户不能决定把记录添加在文件的什么位置，这是由操作系统决定的。这类文件结构与UNIX和Windows中采用的无结构字节流明显不同，但它在一些处理商业数据的大型计算机中获得广泛应用

### 4.1.3 文件类型

UNIX和Windows中都有普通文件和目录，Unix还有字符特殊文件和块特殊文件

**普通文件**:包含有用户信息的文件，一般分为**ASCII文件**和**二进制文件**；**目录**:管理文件系统结构的系统文件；**字符特殊文件**:和输入/输出有关，用于串行I/O类设备，如终端、打印机、网络等；**块特殊文件**:用于磁盘类设备

**ASCII文件**：由多行正文组成。根据系统不同每行结束时用回车符或换行符或同时采用回车符和换行符。文件中的各行的长度不一定相同。ASCII文件的最大优势时可以显示和打印，还可以用任何文本编辑器进行编辑。

**二进制文件**：通常二进制文件有一定的内部结构，使用该文件的程序才了解这种结构

### 4.1.4 文件访问

**顺序访问**：进程在这些系统中可从头按顺序读取文件的全部字节或记录,但不能跳过某一些内容,也不能不按顺序读取。顺序访问文件是可以返回到起点的,需要时可多次读取该文件。是早期操作系统的文件访问方式

**随机访问文件**：能够以任何次序读取其中字节或记录的文件。当用磁盘来存储文件时,可以不按顺序地读取文件中的字节或记录,或者按照关键字而不是位置来访问记录。有两种方法可以指示从何处开始读取文件。一种是每次read操作都给出开始读文件的位置。另一种是用一个特殊的seek操作设置当前位置,在seek操作后,从这个当前位置顺序地开始读文件。UNIX和Windows使用的是后一种方法

### 4.1.5 文件属性

文件都有文件名和数据。另外, 所有的操作系统还会保存其他与文件相关的信息,如文件创建的日期和时间、文件大小等。这些附加信息称为文件**属性**或**元数据**。文件的属性在不同系统中差别很大

### 4.1.6 文件操作

|文件操作|说明|
|:-:|:-:|
|create|创建不包含任何数据的文件。该调用的目的是表明文件即将建立,并设置文件的一些属性|
|delete|当不再需要某个文件时,必须删除该文件以释放磁盘空间。任何文件系统总有一个系统调用用来删除文件|
|open|在使用文件之前,必须先打开文件.目的是:把文件属性和磁盘地址表装入内存,便于后续调用的快速访问|
|close|访问结束后,不再需要文件属性和磁盘地址,这时应该关闭文件以释放内部表空间。很多系统限制进程打开文件的个数,以鼓励用户关闭不再使用的文件。磁盘以块为单位写入,关闭文件时,写入该文件的最后一块,即使这个块还没有满|
|read|在文件中读取数据。一般地,读取的数据来自文件的当前位置。调用者必须指明需要读取多少数据,并且提供存放这些数据的缓冲区|
|write|向文件写数据,写操作一般也是从文件当前位置开始。如果当前位置是文件未尾,文件长度增加。如果当前位置在文件中间,则现有数据被覆盖,并且永远丢失|
|append|此调用是write的限制形式,它只能在文件末尾添加数据。若系统只提供最小系统调用集合,则通常设有append。很多系统对同一操作提供了多种实现方法,这些系统中有时有append调用|
|seek|对于随机访问文件,要指定从何处开始获取数据,通常的方法是用seek系统调用把当前位置指针指向文件中特定位置。seek调用结束后,就可以从该位置开始读写数据了|
|get attributes|进程运行常需要读取文件属性。例如,UNIX中make程序通常用于管理由多个源文件组成的软件开发项目。在调用make时,它会检查全部源文件和目标文件的修改时间,实现最小编译,使得全部文件都为最新版本。为达到此目的,需要查找文件的某一些属性,即修改时间|
|set attributes|某些属性是可由用户设置的,甚至是在文件创建之后,实现该功能的是set attributes系统调用。保护模式信息是一个典型的例子,大多数标志也属于此类属性|
|rename|用户常常要改变已有文件的名字,rename系统调用用于这一目的。严格地说,rename系统调用不是必需的,因为先把文件复制到一个新文件中,然后删除原来的文件,就可以达到同样的目的|

## 4.2 目录

文件系统通常提供**目录**或**文件夹**用于记录文件的位置，在很多系统中目录本身也是文件

### 4.2.1 一级目录系统

目录系统的最简单形式是在一个目录中包含所有的文件，这有时称为**根目录**。优点在于简单，并且能够快速定位文件。这种目录系统经常用于简单的嵌入式装置中

### 4.2.2 层次目录系统

**层次目录结构**：即一个目录树。通过这种方式，可以用很多目录把文件以自然的方式分组。用户可以创建任意数量的子目录，这为用户组织其工作提供了强大的结构化工具。因此，几乎所有现代文件系统都是用这个方式组织的

### 4.2.3 路径名

**绝对路径名**：由从根目录到文件的路径组成。绝对路径名一定是从根目录开始，且是唯一的。如果路径名的第一个字符是分隔符，则这个路径就是绝对路径

**相对路径名**：常和**工作目录(也称作当前目录**)一起使用。用户可以指定一个目录作为当前工作目录。这时，所有的不从根目录开始的路径名都是相对于工作目录的

每个进程都有自己的工作目录,这样在进程改变工作目录并退出后,其他进程不会受到影响,文件系统中也不会有改变的痕迹。对进程而言,切换工作目录是安全的,所以只要需要,就可以改变当前工作目录。但是,如果改变了库过程的工作目录,并且工作完毕之后没有修改回去,则其他程序有可能无法正常运行,因为它们关于当前目录的假设已经失效。所以库过程很少改变工作目录,若非改不可,必须要在返回之前改回到原有的工作目录

### 4.2.4 目录操作

Unix目录操作示例

|目录操作|说明|
|:-:|:-:|
|create|创建目录。除了目录项"."和".."外,目录内容为空。目录项"."和".."是系统自动放在目录中的(有时通过mkdir程序完成)|
|delete|删除目录。只有空目录可删除。只包含目录项"."和".."的目录被认为是空目录,这两个目录项通常不能删除|
|opendir|目录内容可被读取。例如,为列出目录中全部文件,程序必须先打开该目录,然后读其中全部文件的文件名。与打开和读文件相同,在读目录前,必须打开目录|
|closedir|读目录结束后,应关闭目录以释放内部表空间|
|readdir|系统调用readdir返回打开目录的下一个目录项。以前也采用read系统调用来读目录,但这方法有一个缺点:程序员必须了解和处理目录的内部结构。相反,不论采用哪一种目录结构,readdir总是以标准格式返回一个目录项|
|rename|在很多方面目录和文件都相似。文件可换名,目录也可以|
|link|链接技术允许在多个目录中出现同一个文件。这个系统调用指定一个存在的文件和一个路径名,并建立从该文件到路径所指名字的链接。这样,可以在多个目录中出现同一个文件。这种类型的链接增加了该文件的i节点(i-node)计数器的计数(记录含有该文件的目录项数目),有时称为**硬链接**|
|unlink|删除目录项。如果被解除连接的文件只出现在一个目录中(通常情况),则将它从文件系统中删除。如果它出现在多个目录中,则只删除指定路径名的连接,依然保留其他路径名的连接。在UNIX中,用于删除文件的系统调用(前面已有论述)实际上就是unlink|

**符号链接**：不同于使用两个文件名指向同一个内部数据结构来代表一个文件,在符号链接中,一个文件名指向命名另一个文件的一个小文件。当使用这个小文件时,例如打开文件,文件系统沿着路径最终找到文件名,再用新名字启动查找文件的过程。符号链接的优点在于它能够跨越磁盘的界限,甚至可以命名在远程计算机上的文件,不过符号链接的实现并不如硬链接那样有效率

## 4.3 文件系统的实现

### 4.3.1 文件系统布局

磁盘由0号扇区(又称为**主引导记录(MBR)**)、分区表以及若干磁盘分区组成。磁盘分区的布局随着文件系统的不用而变化，一个磁盘分区一般包含引导块、超级块、空闲空间管理、i节点、根目录、文件和目录组成

计算机引导阶段：文件系统存放在磁盘上。多数磁盘划分为一个或多个分区,每个分区中有一个独立的文件系统。磁盘的0号扇区称为**主引导记录(MBR)**,用来引导计算机。在MBR的结尾是分区表。该表给出了每个分区的起始和结束地址。表中的一个分区被标记为活动分区。在计算机被引导时,BIOS读入并执行MBR。MBR做的第一件事是确定活动分区,读入它的第一个块,称为**引导块**,并执行之。引导块中的程序将装载该分区中的操作系统。为统一起见,每个分区都从一个引导块开始,即使它不含有一个可启动的操作系统。不过,未来这个分区也许会有一个操作系统的

除了从引导块开始之外,磁盘分区的布局是随着文件系统的不同而变化的。文件系统经常包含有引导块、超级块、空闲空间管理、i节点、根目录、文件和目录。第一个是**超级块**,超级块包含文件系统的所有关键参数,在计算机启动时,或者在该文件系统首次使用时,超级块会被读入内存。超级块中的典型信息包括:确定文件系统类型用的魔数、文件系统中块的数量以及其他重要的管理信息。接着是文件系统中空闲块的信息，例如可以用位图或指针列表的形式给出。后面也许跟随的是一组i节点,这是一个数据结构数组,每个文件一个,i节点说明了文件的方方面面。接着可能是根目录,它存放文件系统目录树的根部。最后,磁盘的其他部分存放了其他所有的目录和文件。

### 4.3.2 文件的实现

文件存储实现的关键问题是记录各个文件分别用到哪些磁盘块。不同操作系统采用不同的方法

1. 连续分配

把每个文件作为一连串连续数据块存储在磁盘上，每个文件会占用$\frac{文件大小}{块大小}$个块，并且每个文件都从一个新的块开始，因此每个文件的最后一块一般会浪费一些空间

优点：实现简单且具有高的性能1.实现简单，记录每个文件用到的磁盘块简化为只需记住两个数字即可：第一块的磁盘地址和文件块数。2.读操作性能好，因为在单个操作中就可以从磁盘上读出整个文件。只需要一次寻找(对第一个块)。之后不再需要寻道和旋转延迟，所以数据以磁盘全带宽的速率输入

缺点：随着时间的推移，磁盘会变得零碎。一个文件删除之后，它所占用的块就释放了，在磁盘上留下一堆空闲块。磁盘不会在这个位置挤压掉这个空洞，因为这样会设计复制空洞之后的所有文件，可能会有上百万的块。结果是，磁盘上最终既包括文件也有空洞

存在着一种情形,使得连续分配方案是可行的,而且,实际上这个办法在CD-ROM上被广泛使用。在这里所有文件的大小都事先知道,并且在CD-ROM文件系统的后续使用中,这些文件的大小也不再改变。DVD的情况有些复杂。原则上,一个90分钟的电影可以编码成一个独立的、大约4.5GB的文件。但是文件系统所使用的**UDF**格式,使用了一个30位的数来代表文件长度,从而把文件大小限制在1GB。其结果是,DVD电影一般存储在3个或4个1GB的连续文件中。这些构成一个逻辑文件(电影)的物理文件块被称作**extents**

2. 链表分配

为每个文件构造磁盘块链表。每个块内的第一个字作为指向下一块的指针，块的其他部分存放数据

优点：与连续分配方案不同,这一方法可以充分利用每个磁盘块。不会因为磁盘碎片(除了最后一块中的内部碎片)而浪费存储空间。同样在目录项中,只需要存放第一块的磁盘地址,文件的其他块就可以从这个首块地址查找到

缺点：1.尽管顺序读文件非常方便,但是随机访问却相当缓慢。要获得块n,操作系统每一次都必须从头开始,井且要先读前面的n-1块。显然,进行如此多的读操作太慢了。2.而且,由于指针占去了一些宇节,每个磁盘块存储数据的字节数不再是2的整数次幂。虽然这个问题并不是非常严重,但是怪异的大小确实降低了系统的运行效率,因为许多程序都是以长度为2的整数次幂来读写磁盘块的。由于每个块的前几个字节被指向下一个块的指针所占据,所以要读出完整的一个块大小的信息,就需要从两个磁盘块中获得和拼接信息,这就因复制引发了额外的开销

3. 采用内存中的表进行链表分配

**文件分配表(FAT)**：去除每个磁盘中指向下一块的指针，把它们放在内存的文件分配表中。可以解决链表的两个不足

优点：整个块都可以存放数据。进而,随机访问也容易得多。虽然仍要顺着链在文件中查找给定的偏移量,但是整个链都存放在内存中,所以不需要任何磁盘引用。与链表分配的方法相同，不管文件有多大，在目录项中只需记录一个整数(起始块号)，按照它就可以找到文件的全部块

缺点：必须把整个表都存放在内存中。FAT的管理方式不能较好地扩展并应用于大型磁盘中

4. i节点

给每个文件赋予一个称为**i节点**的数据结构，其中列出了文件属性和文件块的磁盘地址。给定i节点，就能找到文件的所有块。在Unix系统中，"."表示当前目录的i节点号，".."表示父目录的i节点号，".."在根目录中指向自身

优点：只有在对应文件打开时，其i节点才在内存中。打开多个文件而保留i节点的数组所占用的内存通常比文件分配表少。

缺点：每个i节点只能存储固定数量的磁盘地址，当一个文件所含的磁盘块的数目超出了i节点所能容纳的数目需要解决。1.i节点中的最后一个磁盘地址不指向数据块，而是指向一个包含额外磁盘块地址的块地址。2.可以有两个或更多个包含磁盘地址的块，或者指向其他存放地址的磁盘块的磁盘块

### 4.3.3 目录的实现

在读文件前,必须先打开文件。打开文件时,操作系统利用用户给出的路径名找到相应目录项。目录项中提供了查找文件磁盘块所需要的信息。因系统而异,这些信息有可能是整个文件的磁盘地址(对于连续分配方案)、第一个块的编号(对于两种链表分配方案)或者是i节点号。无论怎样,目录系统的主要功能是把ASCII文件名映射成定位文件数据所需的信息

与此密切相关的问题是在何处存放文件属性。每个文件系统维护诸如文件所有者以及创建时间等文件属性，他们必须存储在某个地方。1.把文件属性直接存放在目录项中。目录中有一个固定大小的目录项列表，每个文件对应一项，其中包含一个(固定长度)文件名、一个文件属性的结构体以及用以说明磁盘块位置的一个或多个磁盘地址(至某个最大值)2.对于采用i节点的系统，把文件属性存放在i节点中而不是目录项中。在这种情形下，目录项会更短：只有文件名和i节点号。与把属性存放到目录项中相比，这种方法更好

* 实现可变长度的文件名的方法：

1.放弃"所有目录项大小一样"的想法，每个目录项有一个固定部分，这个固定部分通常以目录项的长度开始，后面是固定格式的数据，通常包括所有者、创建时间、保护信息以及其他属性。这个固定长度的头的后面是一个任意长度的实际文件名。为了使每个目录项从字的边界开始，每个文件名被填充成整个字。缺点是当移走文件后，就引入了一个长度可变的空隙，而下一个进来的文件不一定正好适合这个空隙。这个问题与连续磁盘文件的问题是一样的，由于整个目录在内存中，所以之后对目录进行紧凑操作才可节省空间。另一个问题是，一个目录项可能会分布在多个页面上，在读取文件名时可能发生缺页中断

2.使目录项自身都有相同的固定长度，而将文件名放置在目录后面的堆中。优点是当一个文件目录项被移走后，另一个文件的目录项总是可以适合这个空隙。文件名不再需要从字的边界开始。缺点是需要对堆进行管理，并且在处理文件名时缺页中断仍旧会发生

加速查找文件名速度的一个方法是在目录中使用散列表+链表。优点是查找非常迅速，缺点是需要复杂的管理。只有在预计系统中的目录经常会有成百上千文件时，才把散列方案真正作为备用方案考虑

一种完全不同的加快大型目录查找速度的方法是,将查找结果存入高速缓存。在开始查找之前,先查看文件名是否在高速缓存中。如果是,该文件可以立即定位。当然,只有在查询目标集中在相对小范围的文件集合的时候,高速缓存的方案才有效果

### 4.3.4 共享文件

C的一个文件同时出现在B的目录下，此时B的目录与共享文件的联系称为一个**链接(link)**。这样文件系统本身就是一个**有向无环图(DAG**)而不是一棵树

共享文件带来的问题：如果目录中包含磁盘地址，则当链接文件时，必须把C目录中的磁盘地址复制到B目录中。如果B或C随后又往该文件中添加内容，则新的数据块将只列入进行添加工作的用户的目录中。其他的用户对此改变是不知道的

第一种解决方法是磁盘块不列入目录,而是列入一个与文件本身关联的小型数据结构中。目录将指向这个小型数据结构。这是UNIX系统中所采用的方法(小型数据结构即是i节点)。缺点是当B链接到共享文件时,i节点记录文件的所有者是C。建立一个链接并不改变所有关系,但它将i节点的链接计数加1,所以系统知道目前有多少目录项指向这个文件。如果以后C试图删除这个文件,系统将面临问题。如果系统删除文件并清除i节点,B则有一个目录项指向一个无效的i节点。如果该i节点以后分配给另一个文件,则B的链接指向一个错误的文件。系统通过i节点中的计数可知该文件仍然被引用,但是没有办法找到指向该文件的全部目录项以删除它们。指向目录的指针不能存储在i节点中,原因是有可能有无数个这样的目录。唯一能做的就是只删除C的目录项,但是将i节点保留下来,并将计数置为1。而现在的状况是,只有B有指向该文件的目录项,而该文件的所有者是C。如果系统进行记账或有配额,那么C将继续为该文件付账直到B决定删除它,如果真是这样,只有到计数变为0的时刻,才会删除该文件

第二种解决方法是通过让系统建立一个类型为LINK的新文件,并把该文件放在B的目录下,使得B与C的一个文件存在链接。新的文件中只包含了它所链接的文件的路径名。当B读该链接文件时,操作系统查看到要读的文件是LINK类型,则找到该文件所链接的文件的名字,并且去读那个文件。与传统(硬)链接相对比起来,这一方法称为**符号链接**。对于符号链接,第一种解决方案的问题不会发生,因为只有真正的文件所有者才有一个指向i节点的指针。链接到该文件上的用户只有路径名,没有指向i节点的指针。当文件所有者删除文件时,该文件被销毁。以后若试图通过符号链接访问该文件将导致失败,因为系统不能找到该文件。删除符号链接根本不影响该文件。符号链接的问题是需要额外的开销。必须读取包含路径的文件,然后要一个部分一个部分地扫描路径,直到找到i节点。这些操作也许需要很多次额外的磁盘访问。此外,每个符号链接都需要额外的i节点,以及额外的一个磁盘块用于存储路径,虽然如果路径名很短,作为一种优化,系统可以将其存储在i节点中。优点在于即只要简单地提供一个机器的网络地址以及文件在该机器上驻留的路径,就可以链接全球任何地方的机器上的文件

如果允许链接,文件有两个或多个路径。查找一指定目录及其子目录下的全部文件的程序将多次定位到被链接的同一个文件

### 4.3.5 日志结构文件系统

**日志结构文件系统(LFS)**

促使设计LFS的主要原因是,CPU的运行速度越来越快,RAM内存容量变得更大,同时磁盘高速缓存也迅速地增加。进而,不需要磁盘访问操作,就有可能满足直接来自文件系统高速缓存的很大一部分读请求。从上面的事实可以推出,未来多数的磁盘访问是写操作,这样,在一些文件系统中使用的提前读机制(需要读取数据之前预取磁盘块),并不能获得更好的性能。更为糟糕的情况是,在大多数文件系统中,写操作往往都是零碎的。一个50ns的磁盘写操作之前通常需要10ms的寻道时间和4ms的旋转延迟时间,可见零碎的磁盘写操作是极其没有效率的。根据这些参数,磁盘的利用率降低到1%以下

LFS基本思想是将整个磁盘结构化为一个日志。每隔一段时间，或是有特殊需要时，被缓冲在内存中的所有未决的写操作都被放到一个单独的段中，作为在日志末尾的一个邻接段写入磁盘。这个单独的段可能会包括i节点、目录块、数据块或者都有。每一个段的开始都是该段的摘要,说明该段中都包含哪些内容。如果所有的段平均在1MB左右,那么就几乎可以利用磁盘的完整带宽

### 4.3.6 日志文件系统

基于结构的文件系统与现有的文件系统不匹配，没有广泛使用，但是面对出错的鲁棒性可以借鉴

**日志文件系统**：保存一个用于记录系统下一步将要做什么的日志。这样当系统在完成他们即将完成的任务前崩溃时，重新启动后，可以通过查看日志，获取崩溃前计划完成的任务，并完成它们。微软的NTFS文件系统、Linux的ext3和ReiserFS文件系统都使用日志.OS X将日志文件系统作为可选项提供

以移除文件为例,需要三个操作:在目录中删除文件、释放i节点到空闲i节点池以及将所有磁盘块归还空闲磁盘块池。日志文件系统先写一个日志项,列出三个将要完成的动作。然后日志项被写入磁盘(并且为了良好地实施,可能从磁盘读回来验证它的完整性)。只有当日志项已经被写入,不同的操作才可以进行。当所有的操作成功完成后,擦除日志项。如果系统这时崩溃,系统恢复后,文件系统可以通过检查日志来查看是不是有未完成的操作。如果有,可以重新运行所有未完成的操作(这个过程在系统溃重复发生时执行多次),直到文件被正确地删除

为了让日志文件系统工作，被写入日志的操作必须是**幂等的**，即只要有必要，它们就可以重复执行很多次，并不会带来破坏。日志文件系统必须安排它们的数据结构和可写入日志的操作以使它们都是幂等的。在这些条件下，崩溃恢复可以被快速安全地实施

为了增加可靠性,一个文件系统可以引入数据库中**原子事务**的概念。使用这个概念,一组动作可以被界定在开始事务和结束事务操作之间。这样,文件系统就会知道它或者必须完成所有被界定的操作,或者什么也不做,而没有其他选择

### 4.3.7 虚拟文件系统

Windows通过指定不同的盘符来处理这些不同的文件系统，当一个进程打开一个文件，盘符是显式或者隐式存在的，所以Windows知道向哪个文件系统传递请求，不需要尝试将不同类型文件系统整合为统一的模式

绝大多数Unix操作系统都使用**虚拟文件系统(VFS**)概念尝试将多种文件系统统一成一个有序的结构。关键的思想就是抽象出所有文件系统都共有的部分，并且将这部分代码放在单独的一层，该层调用底层的实际文件系统来具体管理数据。以下的介绍是关于Unix下文件系统的描述

所有和文件相关的系统调用在最初的处理上都指向虚拟文件系统。这些来自用户进程的调用，都是标准的POSIX系统调用，比如open、write和lseek等。因此VFS对用户进程有一个"上层"接口，它就是著名的POSIX接口。VFS也有一个对于实际文件系统的下层"接口即**VFS接口**。这个接口包含许多功能调用,这样VFS可以使每一个文件系统完成任务。因此,当创造一个新的文件系统和VFS一起工作时,新文件系统的设计者就必须确定它提供VFS所需要的功能调用。关于这个功能的一个明显的例子就是从磁盘中读某个特定的块,把它放在文件系统的高速缓冲中,并且返回指向它的指针。因此,VFS有两个不同的接口:上层给用户进程的接口和下层给实际文件系统的接口

建立VFS最原始的动机是支持使用**NFS(网络文件系统**)协议的远程文件系统。VFS设计是只要实际的文件系统提供VFS需要的功能，VFS就不需知道或者关心数据具体存储在什么地方或者底层的文件系统是什么样的

大多数VFS应用本质上都是面向对象的，即便它们用C语言而不是C++编写。有几种通常支持的主要的对象类型，包括超块(描述文件系统)、v节点(描述文件)和目录(描述文件系统目录)。这些中的每一个都有实际文件系统必须支持的相关操作。另外VFS有一些供它自己使用的内部数据结构，包括用于跟踪用户进程中所有打开文件的装载表和文件描述符的数组。为了加入一个文件系统，设计者首先获得一个VFS期待的功能调用的列表，然后编写文件系统实现这些功能。或者，如果文件系统已经存在，它们必须提供VFS需要的包装功能，通常通过建造一个或者多个内在的指向实际文件系统的调用来实现

## 4.4 文件系统管理和优化

### 4.4.1 磁盘空间管理

存储一个有n个字节的文件可以有两种策略：分配n个字节的连续磁盘空间，或者把文件分成很多个连续(或者并不一定连续)的块。在存储管理系统中，分段处理和分页处理之间也要进行同样的权衡

按连续字节序列存储文件有一个明显问题,当文件扩大时,有可能需要在磁盘上移动文件。内存中分段也有同样的问题。不同的是,相对于把文件从磁盘的一个位置移动到另一个位置,内存中段的移动操作要快得多。因此,几乎所有的文件系统都把文件分割成固定大小的块来存储,各块之间不一定相邻

1. 块大小

一旦决定把文件按固定大小的块来存储，就会出现一个问题：块的大小应该是多少？在分页系统中，页面大小也是主要讨论的问题之一

块尺寸大的话，小的文件浪费了大量的磁盘空间。块尺寸小的话，大多数文件会跨越多个块，因此需要多次寻道和旋转延迟才能读出它们，从而浪费了时间。即如果分配的单元太大则浪费了空间；如果太小则浪费了时间

2. 记录空闲块

一旦选定了块大小，下一个问题就是怎样跟踪空闲块

第一种方法是采用磁盘块链表，链表的每个块中包含尽可能多的空闲磁盘号。通常情况下，采用空闲块存放空闲表，这样不会影响存储器。如果空闲块倾向于成为一个长的连续分块的话，则空闲列表系统可以改成记录连续分块而不是单个的块。一个8/16/32位的计数可以与每一个块相关联，来记录连续空闲块的数目。在最好的情况下，一个基本上空的磁盘可以用两个数表达:第一个空闲块的地址,以及空闲块的计数。另一方面,如果磁盘产生了很严重的碎片,记录连续分块会比记录单独的块效率要低,因为不仅要存储地址,而且还要存储计数。有一个问题在于当指针块几乎为空或者快满时，一系列短期的临时文件就会引起大量的磁盘I/O。一个可以避免过多磁盘I/O的替代策略是拆分满了的指针块：保持磁盘上的大多数指针块为满的状态(减少磁盘的使用)，但是在内存中保留一个半满的指针块。这样，它既可以处理文件的创建又同时处理文件的删除操作，而不会为空闲表进行磁盘I/O

第二种空闲磁盘空间管理的方法是采用位图。n个块的磁盘需要n位位图。在位图中，空闲块用1表示，已分配块用0表示(或者反之)。位图方法所需空间较少，因为每块只用一个二进制位标识，而在链表方法中，每一块要用到32位。只有在磁盘快满时(即几乎没有空闲块时)链表方案需要的块才比位图少。对于位图,在内存中只保留一个块是有可能的,只有在该块满了或空了的情形下,才到磁盘上取另一块。这样处理的附加好处是,通过在位图的单一块上进行所有的分配操作,磁盘块会较为紧密地聚集在一起,从而减少了磁盘臂的移动。由于位图是一种固定大小的数据结构,所以如果内核是(部分)分页的,就可以把位图放在虚拟内存内,在需要时将位图的页面调入

3. 磁盘配额

为了防止人们贪心而占有太多的磁盘空间，多用户操作系统常常提供一种强制性磁盘配额机制。其思想是系统管理员分给每个用户拥有文件和块的最大数量，操作系统确保每个用户不超过分给它们的配额。只要用户在退出系统前消除所超过的部分，他们就可以在一次终端会话期间超过其软限制，但无论什么情况下都不能超过硬限制

### 4.4.2 文件系统备份

为文件做备份既耗时间又费空间，所以需要做得又快又好。1.只备份特定目录及其下的全部文件，而不是备份整个系统；2.**增量转储**：最简单的增量转储形式就是周期性地(每周或每月)做全面的转储(备份)，而每天只对从上一次全面转储发生变化的数据做备份。也可以只备份自最近一次转储以来更改过的文件，这种做法极大的缩短了转储时间，但恢复起来却更复杂，因为最近的全面转储要全部恢复，随后按逆序进行增量转储；3.是否要对备份文件流进行压缩必须慎重考虑(对许多压缩算法而言，单个坏点就能破坏解压缩算法，并导致整个文件或磁带无法读取)；4.对活动文件系统做备份是很难的；5.做备份会给一个单位引入许多非技术性问题

磁盘转储到磁带上有两种方案：**物理转储**和**逻辑转储**

**物理转储**：从磁盘的第0块开始，将全部的磁盘块按序输出到磁带上，直到最后一块复制完毕。需要注意未使用的磁盘块无需备份，既然磁带上的第k块并不代表磁盘上的第k块，那么要想略过未使用的磁盘块就需要在每个磁盘块前边写下该磁盘块的号码(或其他等效数据)；其次需要关注坏块的转储，如果磁盘控制器将所有坏块重新映射,并对操作系统隐藏的话,物理转储工作还是能够顺利进行的.另一方面,如果这些坏块对操作系统可见并映射到一个或几个坏块文件或者位图中,那么在转储过程中,物理转储程序绝对有必要能访问这些信息,并避免转储之,从而防止在对坏块文件备份时的无止境磁盘读错误发生。物理转储优点是简单、极为快速(基本上是以磁盘的速度运行)，主要缺点是既不能跳过特定的目录，也无法增量存储，还不能满足回复个人文件的请求。因此绝大多数配置都使用逻辑转储

**逻辑转储**：从一个或几个指定的目录开始，递归地转储其自给定基准日期后有所更改的全部文件和目录。所以，在逻辑转储中，转储磁带上会有一连串精心标识的目录和文件，这样就很容易满足恢复特定文件或目录的请求。需要注意，1.空闲块列表并不是一个文件，在所有被转储的文件恢复完毕之后，就需要从零开始重新构造，全部空闲块的集合恰好是包含在全部文件中的块的集合的补集；2.如果一个文件被链接到两个或多个目录中，要注意在恢复时只对该文件恢复一次，然后所有指向该文件的目录重新指向该文件；3.UNIX文件实际上包含了许多"空洞"。打开文件,写几个字节,然后找到文件中一个偏移了一定距离的地址,又写入更多的字节,这么做是合法的。但两者之间的这些块并不属于文件本身,从而也不应该在其上实施转储和恢复操作。核心文件通常在数据段和堆栈段之间有一个数百兆字节的空洞。如果处理不得当,每个被恢复的核心文件会以"0"填充这些区域,这可能导致该文件与虚拟地址空间一样大；4.无论属于哪一个目录，特殊文案、命名管道以及类似的文件都不应该转储

### 4.4.3 文件系统的一致性

影响文件系统可靠性的另一个问题是文件系统的一致性。很多文件系统读取磁盘块,进行修改后,再写回磁盘。如果在修改过的磁盘块全部写回之前系统崩溃,则文件系统有可能处于不一致状态。如果一些未被写回的块是i节点块、目录块或者是包含有空闲表的块时,这个问题尤为严重

为了解决文件系统的不一致问题，很多计算机都带有一个实用程序以检验文件系统的一致性。例如Unix有fsck，而Windows用scandisk。系统启动时，特别是崩溃之后的重新启动，可以运行该实用程序。所有文件系统检验程序可以独立的检验每个文件系统(磁盘分区)的一致性。除检查每个磁盘块计数的正确性之外，文件系统检验程序还检查目录系统

### 4.4.4 文件系统性能

读每32位字，内存访问比磁盘访问快大约4倍(还没算寻道时间和等待所需扇面抵达磁头下)。如果只需要一个字，内存访问则比磁盘访问快百万数量级。考虑到访问时间的这个差异，许多文件系统采用了各种优化措施以改善性能

1. 高速缓存

最常用的减少磁盘访问次数技术是**块高速缓存**或者**缓冲区高速缓存**。在本书中,高速缓存指的是一系列的块,它们在逻辑上属于磁盘,但实际上基于性能的考虑被保存在内存中

管理高速缓存有不同的算法,常用的算法是:检查全部的读请求,查看在高速缓存中是否有所需要的块。如果存在,可执行读操作而无须访问磁盘。如果该块不在高速缓存中,首先要把它读到高速缓存,再复制到所需地方。之后,对同一个块的请求都通过高速缓存完成

由于在高速缓存中有许多块，所以需要有某种方法快速确定所需要的块是否存在。常用方法是将设备和磁盘地址进行散列操作，然后在散列表中查找结果。具有相同散列值的块在一个链表中连接在一起，这样就可以沿着冲突链查找其他块

如果高速缓存已满，此时需要调入新的块,则要把原来的某一块调出高速缓存(如果要调出的块在上次调入以后修改过,则要把它写回磁盘)。这种情况与分页非常相似,所有常用的页面置换算法在第3章中已经介绍,例如FIFO算法、第二次机会算法、LRU算法等,它们都适用于高速缓存。与分页相比,高速缓存的好处在于对高速缓存的引用不很频繁,所以按精确的LRU(最近最少使用算法)顺序在链表中记录全部的块是可行的

防止数据块在高速缓存中放很久之后再写入磁盘：Unix系统中有一个系统调用sync，它强制性地把全部修改过的块立即写回磁盘。系统启动时，在后台运行一个通常名为update的程序，它在无限循环中不断执行sync调用，每两次调用之间休眠30s。Windows的策略是只要被写入高速缓存，就把每个被修改的块写回磁盘。将高速缓存中所有被修改的块立即写回磁盘称为**通写高速缓存**。与非通写高速缓存相比，通写高速缓存需要更多的磁盘I/O

采用这两种不同的高速缓存策略的结果是:在UNIX系统中,若不调用sync就移动磁盘,往往会导致数据丢失,在被毁坏的文件系统中也经常如此。而在通写高速缓存中,就不会出现这类情况

2. 块提前读

第二个明显提高文件系统性能的技术是:在需要用到块之前,试图提前将其写入高速缓存,从而提高命中率。特别地,许多文件都是顺序读的。如果请求文件系统在某个文件中生成块k,文件系统执行相关操作且在完成之后,会在用户不察觉的情形下检查高速缓存,以便确定块K+1是否已经在高速缓存。如果还不在,文件系统会为块K+1安排一个预读,因为文件系统希望在需要用到该块时,它已经在高速缓存或者至少马上就要在高速缓存中了。

当然,块提前读策略只适用于实际顺序读取的文件。对随机访问文件,提前读丝毫不起作用。相反,它还会帮倒忙,因为读取无用的块以及从高速缓存中删除潜在有用的块将会占用固定的磁盘带宽(如果有"脏"块的话,还需要将它们写回磁盘,这就占用了更多的磁插带宽)。那么提前读策略是口值得采用呢?文件系统通过跟踪每一个打开文件的访问方式来确定这一点

3. 减少磁盘臂运动

高速缓存和块提前读并不是提高文件系统性能的唯一方法。另一种重要技术是把有可能顺序访问的块放在一起,当然最好是在同一个柱面上,从而减少磁盘臂的移动次数。当写一个输出文件时,文件系统就必须按照要求一次一次地分配磁盘块。如果用位图来记录空闲块,并且整个位图在内存中,那么选择与前一块最近的空闲块是很容易的。如果用空闲表,并且链表的一部分存在磁盘上,要分配紧邻着的空闲块就困难得多。

不过,即使采用空闲表,也可以使用块簇技术。这里用到一个小技巧,即不用块而用连续块簇来跟踪磁盘存储区。如果一个扇区有312个字节,有可能系统采用1KB的块(2个扇区),但却按每2块(4个扇区)一个单位来分配磁盘存储区。这和2KB的磁盘块并不相同,因为在高速缓存中它依然使用1KB的块,磁盘与内存数据之间传送也是以1IKB为单位进行,但在一个空闲的系统上顺序读取文件,寻道的次数可以减少一半,从而使文件系统的性能大大改善。若考虑旋转定位则可以得到这类方案的变体。在分配块时,系统尽量把一个文件中的连续块存放在同一柱面上。

在使用i节点或任何类似i节点的系统中,另一个性能瓶颈是,读取一个很短的文件也需要两次磁盘访问:一次是访问i节点,另一次是访问块。通常情况下,全部i节点都放在靠近磁盘开始位置,所以i节点和它指向的块之间的平均距离是柱面数的一半,这将需要较长的寻道时间。一个简单的改进方法是,在磁盘中部而不是开始处存放i节点,此时,在i节点和第一块之间的平均寻道时间减为原来的一半。另一种做法是:将磁盘分成多个柱面组,每个柱面组有自己的i节点、数据块和空闲表。在文件创建时,可选取任一i节点,但选定之后,首先在该i节点所在的柱面组上查找块。如果在该柱面组中没有空闲的块,就选用与之相邻的柱面组的一个块。

当然,仅当磁盘中装有磁盘臂的时候,讨论寻道时间和旋转时间才是有意义的。越来越多的电脑开始装配不带移动部件的**固态硬盘(SSD)**。对于这些硬盘,由于采用了和闪存同样的制造技术,使得随机访问与顺序访问在传输速度上已经较为相近,传统硬盘的许多问题就消失了。不幸的是,新的问题又随之出现。例如,固态硬盘在读取、写入和删除时表现出一些特性,尤其是每一块只可写入有限次数的特征,导致使用时需要十分小心以达到均匀分散磨损的目的

### 4.4.5 磁盘碎片整理

在初始安装操作系统后,从磁盘的开始位置,一个接一个地连续安装了程序与文件。所有的空闲磁盘空间放在一个单独的、与被安装的文件邻近的单元里。但随着时间的流逝,文件被不断地创建与删除,于是磁盘会产生很多碎片,文件与空穴到处都是。结果是,当创建一个新文件时,它使用的块会散布在整个磁盘上,造成性能的降低。磁盘性能可以通过如下方式恢复:移动文件使它们相邻,并把所有的(至少是大部分的)空闲空间放在一个或多个大的连续的区域内。

Windows有一个程序defrag就是从事这个工作的。Windows用户应该定期使用它,当然,SSD盘除外。磁盘碎片整理程序会在一个在分区末端的连续区域内有大量空闲空间的文件系统上很好地运行。这段空间会允许磁盘碎片整理程序选择在分区开始端的碎片文件,并复制它们所有的块放到空闲空间内。这个动作在磁盘开始处释放出一个连续的块空间,这样原始或其他的文件可以在其中相邻地存放。这个过程可以在下一大块的磁盘空间上重复,并继续下去。有些文件不能被移动,包括页文件、休眠文件以及日志,因为移动这些文件所需的管理成本要大于移动它们所获得的收益。在一些系统中,这些文件是固定大小的连续的区域,因此它们不需要进行碎片整理。这类文件缺乏灵活性会造成一些问题,一种情况是,它们恰好在分区的末端附近并且用户想减小分区的大小。解决这种问题的唯一的方法是把它们一起删除,改变分区的大小,然后再重新建立它们。

Linux文件系统(特别是ext2和ext3)由于其选择磁盘块的方式,在磁盘碎片整理上一般不会遭受像Windows那样的困难,因此很少需要手动的磁盘碎片整理。

固态硬盘并不受磁盘碎片的影响。事实上,在固态硬盘上做磁盘碎片整理反倒是多此一举,不仅没有提高性能,反而磨损了固态硬盘。所以碎片整理只会缩短固态硬盘的寿命

## 4.7 小结

从外部看,文件系统是一组文件和目录,以及对文件和目录的操作。文件可以被读写,目录可以被创建和删除,并可将文件从一个目录移到另一个目录中。大多数现代操作系统都支持层次目录系统,其中,目录中还有子目录,子目录中还可以有子目录,如此无限下去

而在内部看,文件系统又是另一番景象。文件系统的设计者必须考虑存储区是如何分配的,系统如何记录哪个块分给了哪个文件。可能的方案有连续文件、链表、文件分配表和i节点等。不同的系统有不同的目录结构。属性可以存在目录中或存在别处(比如,在i节点中)。磁盘空间可以通过位图的空闲表来管理。通过增量转储以及用程序修复故障文件系统的方法,可以提高文件系统的可靠性。文件系统的性能非常重要,可以通过多种途径提高性能,包括高速缓存、预读取以及尽可能仔细地将一个文件中的块紧密地放置在一起等方法。日志结构文件系统通过大块单元写入的操作也可以改善性能

文件系统的例子有ISO9660、MS-DOS以及UNIX。它们之间在怎样记录每个文件所使用的块、目录结构以及对空闲磁盘空间管理等方面都存在着差别
