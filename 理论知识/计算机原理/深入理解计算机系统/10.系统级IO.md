- [系统级I/O](#系统级io)
	- [10.1 Unix I/O](#101-unix-io)
	- [10.2 文件](#102-文件)
	- [10.3 打开和关闭文件](#103-打开和关闭文件)
	- [10.4 读和写文件](#104-读和写文件)
	- [10.5 用RIO包健壮地读写](#105-用rio包健壮地读写)
	- [10.6 读取文件元数据](#106-读取文件元数据)
	- [10.7 读取目录内容](#107-读取目录内容)
	- [10.8 共享文件](#108-共享文件)
	- [10.9 I/O重定向](#109-io重定向)
	- [10.10 标准I/O](#1010-标准io)
	- [10.11 应该使用哪些I/O函数？](#1011-应该使用哪些io函数)
	- [10.12 小结](#1012-小结)

# 系统级I/O

输入/输出(I/O)是在主存和外部设备(例如磁盘驱动器、终端和网络)之间复制数据的过程。输入操作是从I/O设备复制数据到主存，而输出操作是从主存复制数据到I/O设备。

所有语言的运行时系统都提供执行**I/O的较高级别的工具**。例如，ANSI C提供标准I/O库，包含像printf和scanf这样执行带缓冲区的I/О函数。C++语言用它的重载操作符<<(输入)和>>(输出)提供了类似的功能。在Linux系统中，是通过使用由内核提供的系统级Unix I/O函数来实现这些较高级别的I/O函数的。大多数时候，高级别I/O函数工作良好，没有必要直接使用Unix I/O。那么为什么还要麻烦地学习Unix I/O呢?

* **了解Unix I/O将帮助你理解其他的系统概念**。I/O是系统操作不可或缺的一部分，因此，我们经常遇到I/O和其他系统概念之间的循环依赖。例如，I/O在进程的创建和执行中扮演着关键的角色。反过来，进程创建又在不同进程间的文件共享中扮演着关键角色。因此，要真正理解I/O，你必须理解进程，反之亦然。在对存储器层次结构、链接和加载、进程以及虚拟内存的讨论中，我们已经接触了I/O的某些方面。既然你对这些概念有了比较好的理解，我们就能闭合这个循环，更加深入地研究I/O。

* **有时你除了使用Unix I/O以外别无选择**。在某些重要的情况中，使用高级I/0函数不太可能，或者不太合适。例如，标准I/O库没有提供读取文件元数据的方式，例如文件大小或文件创建时间。另外，I/O库还存在一些问题，使得用它来进行网络编程非常冒险。

这一章介绍Unix I/O和标准I/O的一般概念，并且向你展示在C程序中如何可靠地使用它们。除了作为一般性的介绍之外，这一章还为我们随后学习网络编程和并发性奠定坚实的基础。

## 10.1 Unix I/O

一个**Linux文件**就是一个m个字节的序列：$B_0, B_1, ..., B_k, ... B_{m-1}$。所有的I/О设备(例如网络、磁盘和终端)都被模型化为文件,而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为**Unix I/O**，这使得所有的输入和输出都能以一种统一且一致的方式来执行:

* **打开文件**。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。

* **Linux shell创建的每个进程开始时都有三个打开的文件**:标准输入(描述符为0)、标准输出(描述符为1)和标准错误(描述符为2)。头文件\<unistd.h\>定义了常量STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO，它们可用来代替显式的描述符值。

* **改变当前的文件位置**。对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。

* **读写文件**。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k≥m时执行读操作会触发一个称为end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置开始，然后更新k。

* **关闭文件**。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。

## 10.2 文件

每个Linux文件都有一个**类型**来表明它在系统中的角色：

* 普通文件包含任意数据。应用程序常常要区分文本文件和二进制文件，文本文件是只含有ASCII或Unicode字符的普通文件;二进制文件是所有其他的文件。对内核而言，文本文件和二进制文件没有区别。Linux文本文件包含了一个文本行序列，其中每一行都是一个字符序列，以一个新行符(“\n")结束。新行符与ASCII的换行符(LF)是一样的，其数字值为0x0a。

* 目录是包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录。每个目录至少含有两个条目:“.”是到该目录自身的链接，以及“..”是到目录层次结构中父目录的链接。你可以用mkdir命令创建一个目录，用ls查看其内容，用rmdir删除该目录。

* 套接字是用来与另一个进程进行跨网络通信的文件

* 其他文件类型包含命名通道、符号链接，以及字符和块设备等。

Linux内核将所有文件都组织成一个**目录层次结构**，由名为"/"的根目录确定。系统中的每个文件都是根目录的直接或间接的后代。

作为其上下文的一部分，每个进程都有一个当前工作目录来确定其在目录层次结构中的当前位置。你可以用cd命令来修改shell中的当前工作目录。

目录层次结构中的位置用**路径名**来指定。路径名是一个字符串，包括一个可选斜杠，其后紧跟一系列的文件名，文件名之间用斜杠分隔。路径名有两种形式:

* 绝对路径名以一个斜杠开始，表示从根节点开始的路径。

* 相对路径名(relative pathname)以文件名开始，表示从当前工作目录开始的路径。

## 10.3 打开和关闭文件

```C
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(char *filename，int flags，mode_t mode);
// 若成功则返回新文件描述符，若出错返回-1。
```

进程通过调用open函数来打开一个已存在的文件或者创建一个新文件。

**open函数**将filename 转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件:O_RDONLY:只读。O_WRONLY:只写。O_RDWR:可读可写。flags参数也可以是一个或者更多位掩码的或，为写提供给一些额外的指示:O_CREAT:如果文件不存在，就创建它的一个截断的空文件。O_TRUNC:如果文件已经存在，就截断它。O_APPEND:在每次写操作前，设置文件位置到文件的结尾处。

mode参数指定了新文件的访问权限位。作为上下文的一部分，每个进程都有一个umask，它是通过调用umask函数来设置的。当进程通过带某个mode参数的open函数调用来创建一个新文件时，文件的访问权限位被设置为mode & ~ umask。

```C
#include <unistd.h>

int close(int fd);	// 若成功则返回0，若出错则返回-1
```

进程通过调用**close函数**关闭一个打开的文件。

## 10.4 读和写文件

```C
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t n);
// 若成功则返回读的字节数，若EOF则返回0，若出错则返回-1。
ssize_t write(int fd,const void *buf, size_t n);
// 若成功则返回写的字节数,若出错则返回-1。
```

应用程序通过分别调用read和write函数来执行输入和输出的。

**read函数**从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。

**write函数**从内存位置buf复制至多n个字节到描述符fd的当前文件位置。

通过调用lseek函数，应用程序能够显式地修改当前文件的位置。

**read函数**有一个size_t的输入参数和一个ssize_t的返回值。在x86-64系统中，size_t被定义为unsigned long，而ssize_t(有符号的大小)被定义为long。read函数返回一个有符号的大小，而不是一个无符号大小，这是因为出错时它必须返回-1。有趣的是，返回一个-1的可能性使得read的最大值减小了一半。

在某些情况下，read和 write传送的字节比应用程序要求的要少。这些**不足值**不表示有错误。出现这样情况的原因有:

* 读时遇到EOF。假设我们准备读一个文件，该文件从当前文件位置开始只含有20多个字节，而我们以50个字节的片进行读取。这样一来，下一个read返回的不足值为20，此后的read将通过返回不足值0来发出EOF信号。

* 从终端读文本行。如果打开文件是与终端相关联的(如键盘和显示器)，那么每个read函数将一次传送一个文本行，返回的不足值等于文本行的大小。

* 读和写网络套接字。如果打开的文件对应于网络套接字(11.4节)，那么内部缓冲约束和较长的网络延迟会引起read和write返回不足值。对Linux管道调用read和 write时，也有可能出现不足值，这种进程间通信机制不在我们讨论的范围之内。

实际上，除了EOF，当你在读磁盘文件时，将不会遇到不足值，而且在写磁盘文件时，也不会遇到不足值。然而，如果你想创建健壮的(可靠的)诸如Web服务器这样的网络应用，就必须通过反复调用read和 write处理不足值，直到所有需要的字节都传送完毕。

## 10.5 用RIO包健壮地读写

专门为CSAPP编写的RIO(Robust I/O，健壮的I/O)包，会自动处理上文中所述的不足值。在像网络程序这样容易出现不足值的应用中，RIO包提供了方便、健壮和高效的I/O。RIO提供了两类不同的函数:

* 无缓冲的输入输出函数。这些函数直接在内存和文件之间传送数据，没有应用级缓冲。它们对将二进制数据读写到网络和从网络读写二进制数据尤其有用。

* **带缓冲的输入函数**。这些函数允许你高效地从文件中读取文本行和二进制数据，这些文件的内容缓存在应用级缓冲区内，类似于为printf这样的标准I/O函数提供的缓冲区。与(某文献中)带缓冲的I/O例程不同，带缓冲的RIO输入函数是线程安全的(12.7.1节)，它在同一个描述符上可以被交错地调用。例如，你可以从一个描述符中读一些文本行，然后读取一些二进制数据，接着再多读取一些文本行。

讲述RIO例程有两个原因。第一，在接下来的两章中,我们开发的网络应用中使用了它们;第二，通过学习这些例程的代码，你将从总体上对 Unix I/O有更深入的了解。

## 10.6 读取文件元数据

```C
#include <unistd.h>#include <sys/stat.h>

int stat(const char *filename,struct stat *buf);
int fstat(int fd, struct stat *buf);// 若成功则返回0，若出错则返回-1。
```

应用程序能够通过调用stat和fstat函数，检索到关于文件的信息(有时也称为文件的元数据(metadata))。

stat函数以一个文件名作为输入，并填写一个stat数据结构中的各个成员。fstat函数是相似的，只不过是以文件描述符而不是文件名作为输入。当我们在11.5节中讨论Web服务器时，会需要stat数据结构中的st_mode和st_size成员，其他成员则不在我们的讨论之列。

st_size成员包含了文件的字节数大小。st_mode成员则编码了文件访问许可位和文件类型。Linux在sys/stat.h中定义了宏谓词来确定st_mode成员的文件类型:S_ISREG(m):这是一个普通文件吗?S_ISDIR(m):这是一个目录文件吗?S_ISSOCK(m):这是一个网络套接字吗?

## 10.7 读取目录内容

应用程序可以用readdir系列函数来读取目录的内容。

```C
#include <sys/types.h>
#include <dirent.h>
DIR *opendir(const char *name);
// 若成功则返回处理的指针;若出错则返回NULL。
```

函数opendir以路径名为参数，返回指向目录流的指针。流是对条目有序列表的抽象，在这里是指目录项的列表。

```C
#include <dirent.h>

struct dirent *readdir(DIR *dirp);
// 若成功则返回指向下一个目录项的指针;若没有更多的目录项或出错则返回NULL

struct dirent{
	ino_t d_ino;
	/* inode number */
	char d_name[256];
	/* Filename */
};
```

每次对readdir的调用返回的都是指向流dirp中下一个目录项的指针，或者，如果没有更多目录项则返回NULL。每个目录项都是一个结构，其形式如下：

虽然有些Linux版本包含了其他的结构成员，但是只有这两个对所有系统来说都是标准的。成员d_name是文件名，d_ino是文件位置。

如果出错，则readdir返回NULL，并设置errno。可惜的是，唯一能区分错误和流结束情况的方法是检查自调用readdir依赖errno是否被修改过

```C
#include <dirent.h>

int closedir(DIR *dirp);
// 成功则返回0，错误则返回-1
```

函数closedir关闭流并释放其所有的资源。

## 10.8 共享文件

可以用许多不同的方式来共享Linux文件。除非你很清楚内核是如何表示打开的文件，否则文件共享的概念相当难懂。内核用三个相关的数据结构来表示打开的文件:

* **描述符表**。每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。

* **文件表**。打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项组成(针对我们的目的)包括当前的文件位置、引用计数(即当前指向该表项的描述符表项数)，以及一个指向v-node表中对应表项的指针。关闭一个描述符会减少相应的文件表表项中的引用计数。内核不会删除这个文件表表项,直到它的引用计数为零。

* **v-node表**。同文件表一样，所有的进程共享这张v-node表。每个表项包含stat 结构中的大多数信息，包括st_mode和st_size成员。

不同的描述符可以通过不同的打开文件表表项来引用不同的文件，没有共享文件，并且每个描述符对应一个不同的文件。

*多个描述符也可以通过不同的文件表项来引用同一个文件*。例如，如果以用一个filename调用open函数两次，就会发生这种情况。关键思想是每个描述符都有它自己的文件位置，所以对不同描述符的读操作可以从文件的不同位置获取数据。

我们也能理解父子进程是如何共享文件的。假设在调用fork之前，父进程有打开文件。调用fork后子进程有一个父进程描述符表的副本。父子进程共享相同的打开文件表集合，因此共享相同的文件位置。一个很重要的结果就是，在内核删除相应文件表表项之前，父子进程必须都关闭了它们的描述符。

## 10.9 I/O重定向

Linux shell提供了I/O重定向操作符，允许用户将磁盘文件和标准输入输出联系起来。

```C
#include <unistd.h>
int dup2(int oldfd，int newfd);	// 若成功则返回非负的描述符,若出错则返回-1。
```

dup2函数复制描述符表表项oldfd到描述符表表项newfd，覆盖描述符表表项new-fd以前的内容。如果newfd已经打开了，dup2会在复制oldfd之前关闭newfd。

## 10.10 标准I/O

C语言定义了一组高级输入输出函数，称为标准I/O库，为程序员提供了Unix I/O的较高级别的替代。这个库(libc)提供了打开和关闭文件的函数(fopen和 fclose)、读和写字节的函数(fread和 fwrite)、读和写字符串的函数( fgets和 fputs)，以及复杂的格式化的I/O函数(scanf和 printf)。

标准I/O库将一个打开的文件模型化为一个流。对于程序员而言，一个流就是一个指向FILE类型的结构的指针。每个 ANSI C程序开始时都有三个打开的流stdin、stdout和stderr，分别对应于标准输入、标准输出和标准错误:

```C
#include <stdio.h>
extern FILE *stdin;		/* Standard input (descriptor 0) */
extern FILE *stdout;	/* Standard output (descriptor 1) */
extern FILE *stderr;	/* Standard error (descriptor 2) */
```

类型为FILE的流是对文件描述符和流缓冲区的抽象。流缓冲区的目的和RIO读缓冲区的一样:就是使开销较高的Linux I/O系统调用的数量尽可能得小。例如，假设我们有一个程序，它反复调用标准I/O的getc函数，每次调用返回文件的下一个字符。当第一次调用getc时，库通过调用一次read函数来填充流缓冲区，然后将缓冲区中的第一个字节返回给应用程序。只要缓冲区中还有未读的字节，接下来对getc的调用就能直接从流缓冲区得到服务。

## 10.11 应该使用哪些I/O函数？

**Unix I/O模型是在操作系统内核中实现的**。应用程序可以通过诸如open、close、lseek、read、write和stat这样的函数来访问Unix I/O。**较高级别的RIO和标准I/O函数都是基于(使用)Unix I/O函数来实现的**。RIO函数是专为本书开发的read和write的健壮的包装函数。它们自动处理不足值，并且为读文本行提供一种高效的带缓冲的方法。标准I/О函数提供了Unix I/O函数的一个更加完整的带缓冲的替代品，包括格式化的I/O例程，如printf和scanf。

那么，在你的程序中该使用这些函数中的哪一个呢?下面是一些基本的指导原则:

1. **只要有可能就使用标准I/O**。对磁盘和终端设备I/O来说标准I/O函数是首选方法。大多数C程序员在其整个职业生涯中只使用标准I/O，从不受较低级的Unix I/O函数的困扰(可能stat除外，因为在标准I/O库中没有与它对应的函数)。只要可能，我们建议你也这样做。

2. **不要使用scanf或rio_readlineb来读二进制文件**。像scanf或rio_readlineb这样的函数是专门设计来读取文本文件的。学生通常会犯的一个错误就是用这些函数来读取二进制文件，这就使得他们的程序出现了诡异莫测的失败。比如,二进制文件可能散布着很多0xa字节，而这些字节又与终止文本行无关。

3. **对网络套接字的I/O使用RIO函数**。不幸的是，当我们试着将标准I/O用于网络的输入输出时，出现了一些令人讨厌的问题。如同我们将在11.4节所见，Linux对网络的抽象是一种称为套接字的文件类型。就像所有的Linux文件一样，套接字由文件描述符来引用，在这种情况下称为套接字描述符。应用程序进程通过读写套接字描述符来与运行在其他计算机的进程实现通信。

**标准I/O流**，从某种意义上而言是全双工的，因为程序能够在同一个流上执行输入和输出。然而，**对流的限制和对套接字的限制**，有时候会互相冲突，而又极少有文档描述这些现象:

限制一:**跟在输出函数之后的输入函数**。如果中间没有插入对fflush、fseek,fsetpos或者rewind的调用，一个输入函数不能跟随在一个输出函数之后。fflush函数清空与流相关的缓冲区。后三个函数使用Unix I/O iseek函数来重置当前的文件位置。

限制二:**跟在输入函数之后的输出函数**。如果中间没有插入对fseek、fsetpos或者rewind的调用，一个输出函数不能跟随在一个输入函数之后，除非该输入函数遇到了一个文件结束。

这些限制给网络应用带来了一个问题，因为对套接字使用lseek函数是非法的。对流I/O的第一个限制能够通过采用在每个输入操作前刷新缓冲区这样的规则来满足。然而，要满足第二个限制的唯一办法是，对同一个打开的套接字描述符打开两个流，一个用来读，一个用来写。但是这种方法也有问题，因为它要求应用程序在两个流上都要调用fclose，这样才能释放与每个流相关联的内存资源，避免内存泄漏。

两个试图关闭同一个底层的套接字描述符的操作，第二个close操作就会失败。对顺序的程序来说，这并不是问题，但是在一个线程化的程序中关闭一个已经关闭了的描述符是会导致灾难的。

因此，我们**建议**你在网络套接字上不要使用标准I/О函数来进行输入和输出，而要使用健壮的RIO函数。如果你需要格式化的输出，使用sprintf函数在内存中格式化一个字符串，然后用rio_writen把它发送到套接口。如果你需要格式化输入，使用rio_readlineb来读一个完整的文本行，然后用sscanf从文本行提取不同的字段。

## 10.12 小结

Linux提供了少量的基于Unix I/O模型的系统级函数，它们允许应用程序打开、关闭、读和写文件，提取文件的元数据，以及执行I/О重定向。Linux的读和写操作会出现不足值，应用程序必须能正确地预计和处理这种情况。应用程序不应直接调用Unix I/O函数，而应该使用RIO包，RIO包通过反复执行读写操作，直到传送完所有的请求数据，自动处理不足值。

Linux内核使用三个相关的数据结构来表示打开的文件。描述符表中的表项指向打开文件表中的表项，而打开文件表中的表项又指向v-node表中的表项。每个进程都有它自己单独的描述符表，而所有的进程共享同一个打开文件表和v-node表。理解这些结构的一般组成就能使我们清楚地理解文件共享和I/O重定向。

标准I/0库是基于Unix I/O实现的，并提供了一组强大的高级I/O例程。对于大多数应用程序而言，标准I/O更简单，是优于Unix I/O的选择。然而，因为对标准I/O和网络文件的一些相互不兼容的限制，Unix I/O比之标准I/O更该适用于网络应用程序。
