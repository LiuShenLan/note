- [异常流控制](#异常流控制)
  - [8.1 异常](#81-异常)
    - [8.1.1 异常处理](#811-异常处理)
    - [8.1.2 异常的类别](#812-异常的类别)
    - [8.1.3 Linux/x86-64系统中的异常](#813-linuxx86-64系统中的异常)
  - [8.2 异常](#82-异常)
    - [8.2.1 逻辑控制流](#821-逻辑控制流)
    - [8.2.2 并发流](#822-并发流)
    - [8.2.3 私有地址空间](#823-私有地址空间)
    - [8.2.4 用户模式和内核模式](#824-用户模式和内核模式)
    - [8.2.5 上下文切换](#825-上下文切换)
  - [8.3 系统调用错误处理](#83-系统调用错误处理)
  - [8.4 进程控制](#84-进程控制)
    - [8.4.1 获取进程PID](#841-获取进程pid)
    - [8.4.2 创建和终止进程](#842-创建和终止进程)
    - [8.4.3 回收子进程](#843-回收子进程)
    - [8.4.4 让进程休眠](#844-让进程休眠)
    - [8.4.5 加载并运行程序](#845-加载并运行程序)
  - [8.5 信号](#85-信号)
    - [8.5.1 信号术语](#851-信号术语)
    - [8.5.2 发送信号](#852-发送信号)
    - [8.5.3 接受信号](#853-接受信号)
    - [8.5.4 阻塞和解除阻塞信号](#854-阻塞和解除阻塞信号)
    - [8.5.5 编写信号处理程序](#855-编写信号处理程序)
    - [8.5.7 显式地等待信号](#857-显式地等待信号)
  - [8.6 非本地跳转](#86-非本地跳转)
  - [8.7 操作进程的工具](#87-操作进程的工具)
  - [8.8 小结](#88-小结)

# 异常流控制

从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列$a_0,a_1,...,a_{n-1}$，其中，每个$a_k$是某个相应的指令$I_k$的地址。每次从$a_k$到$a_{k+1}$的过渡称为**控制转移**。这样的控制转移序列叫做**处理器的控制流**。

最简单的一种控制流是一个“平滑的”序列，其中每个$I_k$和$I_{k+1}$,在内存中都是相邻的。这种平滑流的突变(也就是$I_{k+1}$与$I_k$不相邻)通常是由诸如跳转、调用和返回这样一些熟悉的程序指令造成的。这样一些指令都是必要的机制，使得程序能够对由程序变量表示的内部程序状态中的变化做出反应。

但是系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。当子进程终止时，创造这些子进程的父进程必须得到通知。

现代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为**异常控制流(ECF)**。异常控制流发生在计算机系统的各个层次。比如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。在应用层，一个进程可以发送信号到另一个进程，而接收者会将控制突然转移到它的一个信号处理程序。一个程序可以通过回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。

作为程序员，**理解ECF很重要**，这有很多原因:

* **理解ECF将帮助你理解重要的系统概念**。ECF 是操作系统用来实现I/O、进程和虚拟内存的基本机制。在能够真正理解这些重要概念之前，你必须理解ECF。理解ECF将帮助你理解应用程序是如何与操作系统交互的。应用程序通过使用一个叫做陷阱或者系统调用的ECF形式，向操作系统请求服务。比如，向磁盘写数据、从网络读取数据、创建一个新进程，以及终止当前进程，都是通过应用程序调用系统调用来实现的。理解基本的系统调用机制将帮助你理解这些服务是如何提供给应用的。

* **理解ECF将帮助你编写有趣的新应用程序**。操作系统为应用程序提供了强大的ECF机制，用来创建新进程、等待进程终止、通知其他进程系统中的异常事件，以及检测和响应这些事件。如果理解了这些ECF机制，那么你就能用它们来编写诸如Unix shell和Web服务器之类的有趣程序了。

* **理解ECF将帮助你理解并发**。ECF是计算机系统中实现并发的基本机制。在运行中的并发的例子有:中断应用程序执行的异常处理程序，在时间上重叠执行的进程和线程，以及中断应用程序执行的信号处理程序。理解ECF是理解并发的第一步。我们会在第12章中更详细地研究并发。

* **理解ECF将帮助你理解软件异常如何工作**。像C++和Java这样的语言通过try,catch以及throw语句来提供软件异常机制。软件异常允许程序进行非本地跳转(即违反通常的调用/返回栈规则的跳转)来响应错误情况。非本地跳转是一种应用层ECF，在C中是通过setjmp和 longjmp函数提供的。理解这些低级函数将帮助你理解高级软件异常如何得以实现。

对系统的学习，到目前为止你已经了解了应用是如何与硬件交互的。本章的重要性在于你将开始学习应用是如何与操作系统交互的。有趣的是，这些交互都是围绕着ECF的。我们将描述存在于一个计算机系统中所有层次上的各种形式的ECF。从异常开始，异常位于硬件和操作系统交界的部分。我们还会讨论系统调用，它们是为应用程序提供到操作系统的入口点的异常。然后，我们会提升抽象的层次，描述进程和信号，它们位于应用和操作系统的交界之处。最后讨论非本地跳转，这是ECF的一种应用层形式。

## 8.1 异常

**异常**是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。因为它们有一部分是由硬件实现的，所以具体细节将随系统的不同而有所不同。然而，对于每个系统而言，基本的思想都是相同的。

异常就是控制流中的突变，用来响应处理器状态中的某些变化。

当处理器状态中发生一个重要的变化时，处理器正在执行某个当前指令$I_{curr}$。在处理器中，状态被编码为不同的位和信号。状态变化称为事件。事件可能和当前指令的执行直接相关。比如，发生虚拟内存缺页、算术溢出，或者一条指令试图除以零。另一方面，事件也可能和当前指令的执行没有关系。比如，一个系统定时器产生信号或者一个I/O请求完成。

在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表的跳转表，进行一个间接过程调用(异常)，到一个专门设计用来处理这类事件的操作系统子程序(异常处理程序)。当**异常处理程序完成处理后**，根据引起异常的事件的类型,会发生以下3种情况中的一种:

1)处理程序将控制返回给当前指令$I_{curr}$，即当事件发生时正在执行的指令。

2)处理程序将控制返回给$I_{next}$，如果没有发生异常将会执行的下一条指令。

3）处理程序终止被中断的程序。

### 8.1.1 异常处理

系统中可能的每种类型的异常都分配了一个唯一的非负整数的**异常号**。其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核(操作系统常驻内存的部分)的设计者分配的。前者的示例包括被零除、缺页、内存访问违例、断点以及算术运算溢出。后者的示例包括系统调用和来自外部I/O设备的信号。

在系统启动时(当计算机重启或者加电时)，操作系统分配和初始化一张称为异常表的跳转表，使得表目k包含异常k的处理程序的地址。

在运行时(当系统在执行某个程序时)，处理器检测到发生了一个事件,并且确定了相应的异常号k。随后，处理器触发异常，方法是执行间接过程调用,通过异常表的表目k，转到相应的处理程序。异常号是到异常表中的索引，异常表的起始地址放在一个叫做异常表基址寄存器的特殊CPU寄存器里。

异常类似于过程调用，但是有一些重要的不同之处：

* 过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令(当事件发生时正在执行的指令)，要么是下一条指令(如果事件不发生,将会在当前指令后执行的指令)。

* 处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。比如，x86-64系统会将包含当前条件码的EFLAGS寄存器和其他内容压入栈中。

* 如果控制从用户程序转移到内核，所有这些项目都被压到内核栈中，而不是压到用户栈中。

* 异常处理程序运行在内核模式下(见8.2.4节)，这意味着它们对所有的系统资源都有完全的访问权限。

一旦硬件触发了异常，剩下的工作就是由异常处理程序在软件中完成。在处理程序处理完事件之后，它通过执行一-条特殊的“从中断返回”指令，可选地返回到被中断的程序，该指令将适当的状态弹回到处理器的控制和数据寄存器中，如果异常中断的是一个用户程序，就将状态恢复为用户模式(见8.2.4节)，然后将控制返回给被中断的程序。

### 8.1.2 异常的类别

异常可以分为四类：**中断、陷阱、故障和终止**。异步异常是由处理器外部的I/O设备中的事件产生的。同步异常是执行一条指令的直接产物。

|类别|原因|异步/同步|返回行为|
|:-:|:-:|:-:|:-:|
|中断|来自I/O设备的信号|异步|总是返回到下一条指令|
|陷阱|有意的异常|同步|总是返回到下一条指令|
|故障|潜在可恢复的错误|同步|可能返回到当前指令|
|终止|不可恢复的错误|同步|不会返回|

1. 中断

中断是**异步**发生的，是来自处理器外部的I/O设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序常常称为中断处理程序。

I/O设备，例如网络适配器、磁盘控制器和定时器芯片，通过向处理器芯片上的一个引脚发信号，并将异常号放到系统总线上，来触发中断，这个异常号标识了引起中断的设备。

在当前指令完成执行之后，处理器注意到中断引脚的电压变高了，就从系统总线读取异常号，然后调用适当的中断处理程序。当处理程序返回时，它就将控制返回给下一条指令(也即如果没有发生中断，在控制流中会在当前指令之后的那条指令)。结果是程序继续执行,就好像没有发生过中断一样。

**剩下的异常类型(陷阱、故障和终止)是同步发生的**，是执行当前指令的结果。我们把这类指令叫做故障指令。

2. 陷阱和系统调用

陷阱是**有意的异常**，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做**系统调用**。

用户程序经常需要向内核请求服务，比如读一个文件、创建一个新的进程、加载一个新的程序，或者终止当前进程。为了允许对这些内核服务的受控的访问，处理器提供了一条特殊的“syscall n”指令，当用户程序想要请求服务n时，可以执行这条指令。执行syscall指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。

从程序员的角度来看，系统调用和普通的函数调用是一样的。然而，它们的实现非常不同。普通的函数运行在用户模式中，用户模式限制了函数可以执行的指令的类型，而且它们只能访问与调用函数相同的栈。系统调用运行在内核模式中，内核模式允许系统调用执行特权指令，并访问定义在内核中的栈。8.2.4节会更详细地讨论用户模式和内核模式。

3. 故障

故障由**错误情况**引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的abort例程，abort例程会终止引起故障的应用程序。

一个经典的故障示例是缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障。就像我们将在第9章中看到的那样，一个页面就是虚拟内存的一个连续的块(典型的是4KB)。缺页处理程序从磁盘加载适当的页面，然后将控制返回给引起故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中了,指令就可以没有故障地运行完成了。

4. 终止

终止是**不可恢复的致命错误造成的结果**，通常是一些硬件错误，比如DRAM或者SRAM位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。

### 8.1.3 Linux/x86-64系统中的异常

为x86-64系统定义的异常有256种类型。0~31的号码对应的是由Intel架构师定义的异常，因此对任何x86-64系统都是一样的。32~255的号码对应的是操作系统定义的中断和陷阱。

**Linux/x86-64系统调用**：

Linux 提供几百种系统调用，当应用程序想要请求内核服务时可以使用，包括读文件、写文件或是创建一个新进程。图8-10给出了一些常见的Linux系统调用。每个系统调用都有一个唯一的整数号，对应于一个到内核中跳转表的偏移量(注意:这个跳转表和异常表不一样)。

在x86-64系统上，系统调用是通过一条称为syscall的陷阱指令来提供的。所有到Linux系统调用的参数都是通过通用寄存器而不是栈传递的。按照惯例，寄存器%rax包含系统调用号，寄存器%rdi、%rsi、%rdx、%r10、%r8和%r9包含最多6个参数。第一个参数在%rdi中，第二个在%rsi中，以此类推。从系统调用返回时，寄存器%rcx和%r11都会被破坏，%rax包含返回值。-4095到-1之间的负数返回值表明发生了错误，对应于负的error。

## 8.2 异常

**异常**是允许操作系统内核提供进程概念的基本构造块，进程是计算机科学中最深刻、最成功的概念之一。

在现代系统上运行一个程序时，我们会得到一个假象，就好像我们的程序是系统中当前运行的唯一的程序一样。我们的程序好像是独占地使用处理器和内存。处理器就好像是无间断地一条接一条地执行我们程序中的指令。最后，我们程序中的代码和数据好像是系统内存中唯一的对象。这些假象都是通过**进程**的概念提供给我们的。

**进程**的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。

每次用户通过向shell输入一个可执行目标文件的名字，运行程序时，shell就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，并且在这个新进程的上下文中运行它们自己的代码或其他应用程。

关于操作系统如何实现进程的细节的讨论超出了本书的范围。反之，我们将关注进程提供给应用程序的关键抽象:

* 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。

* 一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。

### 8.2.1 逻辑控制流

即使在系统中通常有许多其他程序在运行，进程也可以向每个程序提供一种假象，好像它在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器(PC)的值,这些值唯一地对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享对象中的指令。这个PC值的序列叫做**逻辑控制流**，或者简称**逻辑流**。

考虑一个运行着三个进程的系统,处理器的一个物理控制流被分成了三个逻辑流，每个进程一个，三个逻辑流的执行是交错的。进程A运行了一会儿，然后是进程B开始运行到完成。然后，进程C运行了一会儿，进程A接着运行直到完成。最后，进程C可以运行到结束了。

关键点在于进程是轮流使用处理器的。每个进程执行它的流的一部分，然后被抢占(暂时挂起)，然后轮到其他进程。对于一个运行在这些进程之一的上下文中的程序，它看上去就像是在独占地使用处理器。唯一的反面例证是，如果找们稍确地测量每条指令使用的时间，会发现在程序中一些指令的执行之间，CPU好像会周期性地停顿。然而，每次处理器停顿，它随后会继续执行我们的程序,并不改变程序内存位置或寄存器的内容。

### 8.2.2 并发流

计算机系统中逻辑流有许多不同的形式。异常处理程序、进程、信号处理程序、线程和Java进程都是逻辑流的例子。

一个逻辑流的执行在时间上与另一个流重叠，称为**并发流**，这两个流被称为并发地运行。更准确地说，流X和Y互相并发，当且仅当X在Y开始之后和Y结束之前开始，或者Y在X开始之后和X结束之前开始。

多个流并发地执行的一般现象被称为**并发**。一个进程和其他进程轮流运行的概念称为**多任务**。一个进程执行它的控制流的一部分的每一时间段叫做时间片。因此，多任务也叫做时间分片。

注意，**并发流的思想与流运行的处理器核数或者计算机数无关**。如果两个流在时间上重叠，那么它们就是并发的，即使它们是运行在同一个处理器上。不过，有时我们会发现确认并行流是很有帮助的，它是并发流的一个真子集。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为并行流，它们并行地运行，且并行地执行。

### 8.2.3 私有地址空间

进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。在一台n位地址的机器上，地址空间是2"个可能地址的集合，$0，1，…，2^n-1$。进程为每个程序提供它自己的**私有地址空间**。一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，从这个意义上说，这个地址空间是私有的。

尽管和每个私有地址空间相关联的内存的内容一般是不同的，但是每个这样的空间都有相同的**通用结构**。(结构与Linux x86-64运行时内存映像相同)地址空间底部是保留给用户程序的，包括通常的代码、数据、堆和栈段。代码段总是从地址0x400000开始。地址空间顶部保留给内核(操作系统常驻内存的部分)。地址空间的这个部分包含内核在代表进程执行指令时(比如当应用程序执行系统调用时)使用的代码、数据和栈。

|进程地址空间|备注|
|:-:|:-:|
|内核虚拟内存(代码、数据、堆、栈)|↑对用户代码不可见的内存|
||$2^{48}-1$|
|用户栈(运行时创建)↓||
||%esp(栈指针)|
|共享库的内存映射区域↑||
||←brk|
|运行时堆(由malloc创建)↑|
||读/写段(.data，.bss)|从可执行文件中加载|
|只读代码段(.init，.text，.rodata)|从可执行文件中加载|
||0x0040 0000|
||0|

### 8.2.4 用户模式和内核模式

为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。

处理器通常是用某个控制寄存器中的一个模式位来提供这种功能的，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在**内核模式**中(有时叫做**超级用户模式**)。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。没有设置模式位时，进程就运行在**用户模式**中。用户模式中的进程不允许执行特权指令，比如停止处理器、改变模式位，或者发起一个I/O操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。

运行应用程序代码的进程初始时是在用户模式中的。**进程从用户模式变为内核模式的唯一方法**是通过诸如中断、故障或者陷入系统调用这样的异常。当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。

Linux提供了一种聪明的机制，叫做 **/proc文件系统**，它允许用户模式进程访问内核数据结构的内容。/proc文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构。比如，你可以使用/proc文件系统找出一般的系统属性，比如CPU类型(/proc/cpuinfo)，或者某个特殊的进程使用的内存段(/proc/\<process-id\>/maps)。2.6版本的 Linux内核引入/sys文件系统，它输出关于系统总线和设备的额外的低层信息。

### 8.2.5 上下文切换

操作系统内核使用一种称为**上下文切换**的较高层形式的异常控制流来实现多任务。上下文切换机制是建立在8.1节中已经讨论过的那些较低层异常机制之上的。

内核为每个进程维持一个**上下文**。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。

在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做**调度**，是由内核中称为调度器的代码处理的。当内核选择一个新的进程运行时，我们说内核调度了这个进程。在内核调度一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程，**上下文切换步骤**为1)保存当前进程的上下文，2)恢复某个先前被抢占的进程被保存的上下文，3)将控制传递给这个新恢复的进程。

当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个事件发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。比，如果Tread系统调用需要访问磁盘，内核可以选择执行上下文切换，运行另外一个进程，而不是等待数据从磁盘到达。另一个示例是sleep系统调用，它显式地请求让调用进程休眠。

**中断也可能引发上下文切换**。比如，所有的系统都有某种产生周期性定时器中断的机制，通常为每1毫秒或每10毫秒。每次发生定时器中断时，内核就能判定当前进程已经运行了足够长的时间，并切换到一个新的进程。

## 8.3 系统调用错误处理

当Unix系统级函数遇到错误时，它们通常会返回-1，并设置全局整数变量errno来表示什么出错了。通过使用错误处理包装函数，我们可以简化代码，对于一个给定的基本函数foo，我们定义一个具有相同参数的包装函数Foo，但是第一个字母大写了。包装函数调用基本函数，检查错误，如果有任何问题就终止。

## 8.4 进程控制

Unix 提供了大量从C程序中操作进程的系统调用。这一节将描述这些重要的函数。

### 8.4.1 获取进程PID

每个进程都有一个唯一的正数(非零)进程ID(PID)。

```C
#include <sys/types.h>#include <unistd.h>

pid_t getpid(void);
// 返回调用进程的PIDpid_t getppid(void);
// 返回它的父进程的PID(创建调用进程的进程)
// 返回一个类型为pid_t的整数值，在Linux系统上它在types.h中被定义为int
```

### 8.4.2 创建和终止进程

从程序员的角度，我们可以认为进程总是处于下面三种状态之一:

* 运行。进程要么在CPU上执行，要么在等待被执行且最终会被内核调度。

* 停止。进程的执行被挂起，且不会被调度。当收到SIGSTOP、SIGT-STP、SIGTTIN或者SIGTTOU信号时，进程就停止，并且保持停止直到它收到一个SIGCONT信号，在这个时刻，进程再次开始运行(信号是一种软件中断的形式，将在8.5节中详细描述)。

* 终止。进程永远地停止了。进程会因为三种原因终止:1)收到一个信号，该信号的默认行为是终止进程，2)从主程序返回，3)调用exit函数。

```C
#include <stdlib.h>

void exit(int status);
// 以status退出状态来终止进程
// 另一种设置退出状态的方法是从主程序中返回一个整数值
```

父进程通过调用fork函数创建一个新的运行的子进程

```C
#include <sys/types.h>#include <unistd.h>

pid_t fork(void);
// 子进程返回0，父进程返回子进程的PID，如果出错则为-1
```

新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。

fork函数只被调用一次，却会返回两次:一次是在调用进程(父进程)中，一次是在新创建的子进程中。在父进程中，fork返回子进程的PID。在子进程中，fork返回0。因为子进程的PID总是为非零，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。

```C++
// eg:
int main() {
	pid_t pid;
	int x = 1;

	pid = Fork();
	if (pid == 0) {
		// 子进程
		printf("child: x = %d\n", ++x);
		exit(0);
	}

	// 父进程
	printf("parent: x = %d\n", --x);
	exit(0);
}
```

* 调用一次，返回两次。fork函数被父进程调用一次，但是却返回两次：一次是返回到父进程，一次是返回到新创建的子进程。对于只创建一个子进程的程序来说，这还是相当简单直接的。但是具有多个fork实例的程序可能就会令人迷惑，需要仔细地推敲了。

* 并发执行。父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行它们的逻辑控制流中的指令。在我们的系统上运行这个程序时，父进程先完成它的printf语句，然后是子进程。然而，在另一个系统上可能正好相反。一般而言，作为程序员，我们决不能对不同进程中指令的交替执行做任何假设。

* 相同但是独立的地址空间。如果能够在fork函数在父进程和子进程中返回后立即暂停这两个进程，我们会看到两个进程的地址空间都是相同的。每个进程有相同的用户栈、相同的本地变量值、相同的堆、相同的全局变量值，以及相同的代码。然而，因为父进程和子进程是独立的进程，它们都有自己的私有地址空间。后面，父进程和子进程对变量所做的任何改变都是独立的，不会反映在另一个进程的内存中。

* 共享文件。当运行这个示例程序时，我们注意到父进程和子进程都把它们的输出显示在屏幕上。原因是子进程继承了父进程所有的打开文件。当父进程调用fork时，stdout文件是打开的，并指向屏幕。子进程继承了这个文件，因此它的输出也是指向屏幕的。

**进程图**：进程图是刻画程序语句的偏序的一种简单的前趋图。每个顶点a对应于一条程序语句的执行。有向边a→b表示语句a发生在语句b之前。边上可以标记出一些信息，例如一个变量的当前值。对应于printf语句的顶点可以标记上printf的输出。每张图从一个顶点开始，对应于调用main的父进程。这个顶点没有入边，并且只有一个出边。每个进程的顶点序列结束于一个对应于exit调用的顶点。这个顶点只有一条入边，没有出边。

对于运行在单处理器上的程序，对应进程图中所有顶点的拓扑排序表示程序中语句的一个可行的全序排列。下面是一个理解拓扑排序概念的简单方法:给定进程图中顶点的一个排列，把顶点序列从左到右写成一行，然后画出每条有向边。排列是一个拓扑排序，当且仅当画出的每条边的方向都是从左往右的。

### 8.4.3 回收子进程

当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从此时开始，该进程就不存在了。一个终止了但还未被回收的进程称为**僵死进程**。

如果一个父进程终止了，内核会安排init进程成为它的孤儿进程的养父。init进程的PID为1，是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。如果父进程没有回收它的僵死子进程就终止了，那么内核会安排init进程去回收它们。不过，长时间运行的程序，比如 shell或者服务器，总是应该回收它们的僵死子进程。即使僵死子进程没有运行，它们仍然消耗系统的内存资源。

一个进程可以通过调用waitpid函数来等待它的子进程终止或者停止。

```C
#include <sys/types.h>#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *statusp, int options);
// 如果成功，则返回子进程PID，如果WNOHANG，则返回0，如果其他错误，则返回-1
```

默认情况下(当options=0时)，waitpid挂起调用进程的执行，直到它的等待集合中的一个子进程终止。如果等待集合中的一个进程在刚调用的时刻就已经终止了，那么waitpid就立即返回。在这两种情况中，waitpid返回导致waitpid返回的已终止子进程的PID。此时，已终止的子进程已经被回收，内核会从系统中删除掉它的所有痕迹。

1. **判定等待集合的成员**。等待集合的成员是由参数PID来确定的：

   * 如果pid>0，那么等待集合就是一个单独的子进程，它的进程ID等于pid。

   * 如果pid=-1，那么等待集合就是由父进程所有的子进程组成的。

   * waitpid函数还支持其他类型的等待集合，包括Unix进程组，对此我们将不做讨论。

2. **修改默认行为**。可以通过将options 设置为常量WNOHANG、WUNTRACED和WCONTINUED的各种组合来修改默认行为:

   * WNOHANG:如果等待集合中的任何子进程都还没有终止，那么就立即返回(返回值为0)。默认的行为是挂起调用进程，直到有子进程终止。在等待于进在终止的问时，如果还想做些有用的工作，这个选项会有用。

   * WUNTRACED:挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止。返回的PID为导致返回的已终止或被停止子进程的PID。默认的行为是只返回已终止的子进程。当你想要检查已终止和被停止的子进程时，这个选项会有用。

   * WCONTINUED:挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或等待集合中一个被停止的进程收到SIGCONT信号重新开始执行(8.5节会解释这些信号)。

* 可以用或运算把这些选项组合起来。例如:

   * WNOHANG | WUNTRACED:立即返回，如果等待集合中的子进程都没有被停止或终止，则返回值为0;如果有一个停止或终止，则返回值为该子进程的PID。

3. **检查已回收子进程的退出状态**。如果statusp参数是非空的，那么waitpid就会在status中放上关于导致返回的子进程的状态信息，status是statusp指向的值。wait.h 头文件定义了解释status参数的几个宏:

   * WIFEXITED(status):如果子进程通过调用exit或者一个返回(return)正常终止，就返回真。

   * WEXITSTATUS( status):返回一个正常终止的子进程的退出状态。只有在WIFEXITED()返回为真时，才会定义这个状态。

   * WIFSIGNALED(status):如果子进程是因为一个未被捕获的信号终止的，那么就返回真。

   * WTERMSIG(status):返回导致子进程终止的信号的编号。只有在 WIFSIG-NALED()返回为真时，才定义这个状态。

   * WIFSTOPPED(status):如果引起返回的子进程当前是停止的，那么就返回真。

   * WSTOPSIG(status):返回引起子进程停止的信号的编号。只有在WIFSTOPPED()返回为真时，才定义这个状态。

   * WIFCONTINUED(status):如果子进程收到SIGCONT信号重新启动，则返回真。

4. **错误条件**。如果调用进程没有子进程，那么waitpid返回-1，并且设置errno为ECHILD。如果waitpid函数被一个信号中断，那么它返回-1，并设置errno为EINTR。

5. **wait函数**

```C
#include <sys/types.h>#include <sys/wait.h>

pid_t wait(int *statusp);
// wait函数是waitpid函数的简单版本
// 调用wait(&status)等价于调用waitpid(-1, &status, 0)
// 如果成功，则返回子进程的PID，如果出错，则返回-1
```

注意，CSAPP示例中程序不会按照特定的顺序回收子进程。子进程回收的顺序是这台特定的计算机系统的属性。在另一个系统上，甚至在同一个系统上再执行一次，两个子进程都可能以相反的顺序被回收。这是非确定性行为的一个示例，这种非确定性行为使得对并发进行推理非常困难。两种可能的结果都同样是正确的，作为一个程序员，你绝不可以假设总是会出现某一个结果，无论多么不可能出现另一个结果。唯一正确的假设是每一个可能的结果都同样可能出现。

### 8.4.4 让进程休眠

```C
#include <unistd.h>

unsigned int sleep(unsigned int secs);	// 返回还要休眠的秒数

int pause(void);	// 总是返回-1
```

sleep函数将一个进程挂起一段指定的时间。如果请求的时间量已经到了，sleep返回0，否则返回还剩下的要休眠的秒数。后一种情况是可能的，如果因为sleep函数被一个信号中断而过早地返回。我们将在8.5节中详细讨论信号。

pause函数让调用函数休眠，直到该进程收到一个信号。

### 8.4.5 加载并运行程序

execve函数在当前进程的上下文中加载并运行一个新程序。

```C
#include <unistd.h>

int execve(const char *filename, const char *argv[], const char *envp[]);
// 如果成功，则不返回，如果错误，则返回-1
```

execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。只有当出现错误时，例如找不到filename，execve才会返回到调用程序。所以，与fork 一次调用返回两次不同，execve调用一次并从不返回。

参数列表argv变量指向一个以null结尾的指针数组，其中每个指针都指向一个参数字符串。按照惯例，argv\[0\]是可执行目标文件的名字。环境变量的列表是由一个类似的数据结构表示的，envp变量指向一个以null结尾的指针数组，其中每个指针指向一个环境变量字符串，每个串都是形如“name=value”的名字-值对。

* 程序与进程：程序是一堆代码和数据;程序可以作为目标文件存在于磁盘上，或者作为段存在于地址空间中。进程是执行中程序的一个具体的实例;程序总是运行在某个进程的上下文中。如果你想要理解fork和execve函数，理解这个差异是很重要的。fork函数在新的子进程中运行相同的程序，新的子进程是父进程的一个复制品。execve函数在当前进程的上下文中加载并运行一个新的程序。它会覆盖当前进程的地址空间，但并没有创建一个新进程。新的程序仍然有相同的PID，并且继承了调用execve函数时已打开的所有文件描述符。

## 8.5 信号

Linux信号是一种更高层的软件形式的异常，它允许进程和内核中断其它进程。一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。

每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。比如，如果一个进程试图除以0，那么内核就发送给它一个SIGFPE信号(号码8)。如果一个进程执行一条非法指令，那么内核就发送给它一个 SIGILL信号(号码4)。如果进程进行非法内存引用，内核就发送给它一个 SIGSEGV信号(号码11)。其他信号对应于内核或者其他用户进程中较高层的软件事件。比如，如果当进程在前台运行时，你键入Ctrl+C，那么内核就会发送一个SIGINT信号(号码2)给这个前台进程组中的每个进程。一个进程可以通过向另一个进程发送一个 SIGKILL信号(号码9)强制终止它。当一个子进程终止或者停止时，内核会发送一个 SIGCHLD信号(号码17)给父进程。

### 8.5.1 信号术语

**传送一个信号到目的进程**是由两个不同步骤组成的:

* 发送信号。内核通过更新目的进程上下文中的某个状态，发送(递送)一个信号给目的进程。发送信号可以有如下两种原因:1)内核检测到一个系统事件，比如除零错误或者子进程终止。2)一个进程调用了kill函数(在下一节中讨论)，显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。

* 接收信号。当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序的用户层函数捕获这个信号。

一个发出而没有被接收的信号叫做**待处理信号**。在任何时刻，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为k的待处理信号，那么任何接下来发送到这个进程的类型为k的信号都不会排队等待;它们只是被简单地丢弃。一个进程可以有选择性地阻塞接收某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。

**一个待处理信号最多只能被接收一次**。内核为每个进程在pending位向量中维护着待处理信号的集合，而在blocked位向量R中维护着被阻塞的信号集合。只要传送了一个类型为k的信号，内核就会设置pending中的第k位，而只要接收了一个类型为k的信号，内核就会清除pending中的第k位。

### 8.5.2 发送信号

Unix系统提供了大量向进程发送信号的机制。所有这些机制都是基于进程组这个概念的。

1. 进程组

每个进程都只属于一个进程组，进程组是由一个正整数进程组ID来标识的。

```C
#include <unistd.h>

pid_t getpgrp(void);	// 返回调用进程(当前进程)的进程组PID

int setpgid(pid_t pid, pid_t pgid);	// 若成功则返回0，若错误则返回-1
```

默认地，一个子进程和它的父进程同属于一个进程组。一个进程可以通过使用setpgid函数来改变自己或者其他进程的进程组。setpgid函数将进程pid的进程组改为pgid。如果pid是0，那么就使用当前进程的PID。如果pgid是0，那么就用pid指定的进程的PID作为进程组 ID。

2. 用/bin/kill程序发送信号

/bin/kill程序可以向另外的进程发送任意的信号。比如，命令`linux>/bin/kill -9 15213`发送信号9(SIGKILL)给进程15213。一个为负的PID会导致信号被发送到进程组PID中的每个进程。比如，命令`linux>/bin/kill -9 -15213`发送一个SIGKILL信号给进程组15213中的每个进程。

3. 从键盘发送信号

Unix shell使用作业(job)这个抽象概念来表示为对一条命令行求值而创建的进程。在任何时刻，至多只有一个前台作业和0个或多个后台作业。多个进程是通过Unix管道连接起来的。shell为每个作业创建一个独立的进程组。进程组ID通常取自作业中父进程中的一个。

4. 用kill函数发送信号

```C
#include <sys/types.h>#include <signal.h>

int kill(pid_t pid, int sig);	// 若成功则返回0，若错误则返回-1
```

进程通过调用kill函数发送信号给其他进程(包括它们自己)。如果pid大于零，那么kill函数发送信号号码sig给进程pid。如果pid等于零，那么kill发送信号sig给调用进程所在进程组中的每个进程，包括调用进程自己。如果pid小于零，kill发送信号sig给进程组|pid|(pid的绝对值)中的每个进程。

5. 用alarm函数发送信号

```C
#include <unistd.h>

unsigned int alarm(unsigned int secs);
// 返回前一次闹钟剩余的秒数，若以前没有设定闹钟，则返回0
```

进程可以通过调用alarm函数向它自己发送SIGALRM信号。alarm函数安排内核在secs秒后发送一个SIGALRM信号给调用进程。如果secs是零，那么不会调度安排新的闹钟(alarm)。在任何情况下，对alarm的调用都将取消任何待处理的(pending)闹钟，并且返回任何待处理的闹钟在被发送前还剩下的秒数(如果这次对alarm的调用没有取消它的话);如果没有任何待处理的闹钟，就返回零。

### 8.5.3 接受信号

当内核把进程p从内核模式切换到用户模式时(例如，从系统调用返回或是完成了一次上下文切换)，它会检查进程p的未被阻塞的待处理信号的集合(pending &~blocked)。如果这个集合为空(通常情况下)，那么内核将控制传递到p的逻辑控制流中的下一条指令($I_{next}$)。然而，如果集合是非空的，那么内核选择集合中的某个信号k(通常是最小的k)，并且强制p接收信号k。收到这个信号会触发进程采取某种行为。一旦进程完成了这个行为，那么控制就传递回p的逻辑控制流中的下一条指令($I_{next}$)。每个信号类型都有一个预定义的默认行为，是下面中的一种:进程终止；进程终止并转储内存(把代码和数据内存段的映像写到磁盘上)；进程停止(挂起)直到被SIGCONT信号重启；进程忽略该信号。

进程可以通过使用signal函数修改和信号相关联的默认行为。唯一的例外是SIGSTOP和SIGKILL，它们的默认行为是不能修改的。

```C
#include <signal.h>

typedef void (*sighandler_t)(int)

sighandler_t signal(int signum, sighandler_t handler);
// 若成功则返回指向前次处理程序的指针，若出错则返回SIG_ERR(不设置errno)
```

signal函数可以通过下列三种方法之一来改变和信号signum相关联的行为:

* 如果handler是SIG_IGN，那么忽略类型为signum的信号。

* 如果handler是SIG_DFL，那么类型为signum的信号行为恢复为默认行为。* 否则，handler就是用户定义的函数的地址，这个函数被称为信号处理程序，只要进程接收到一个类型为signum的信号，就会调用这个程序。

通过把处理程序的地址传递到signal函数从而改变默认行为，这叫做设置信号处理程序。调用信号处理程序被称为捕获信号。执行信号处理程序被称为处理信号。当一个进程捕获了一个类型为k的信号时，会调用为信号k设置的处理程序，一个整数参数被设置为k。这个参数允许同一个处理函数捕获不同类型的信号。

当处理程序执行它的return语句时，控制(通常)传递回控制流中进程被信号接收中断位置处的指令。我们说“通常”是因为在某些系统中，被中断的系统调用会立即返回一个错误。

### 8.5.4 阻塞和解除阻塞信号

Linux提供阻塞信号的隐式和显式的机制:* 隐式阻塞机制。内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。

* 显式阻塞机制。应用程序可以使用sigprocmask函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。

```C
#include <signal.h>

// 以下如果成功则返回0，若出错则返回-1
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
// 改变当前阻塞的信号集合(8.5.1中的blocked位向量)，具体的行为依赖于how的值
// SIG_BLOCK：把set中的信号添加到blocked中(blocked = blocked | set)
// SIG_UNBLOCKED：从blocked中删除set中的信号(blocked = blocked & ~set)
// SIG_SETMASK：blocked = set
// 若果oldset非空，那么blocked之前的值保存在oldset中。
int sigemptyset(sigset_t *set);
// 初始化set为空集合
int sigfillset(sigset_t *set);
// 把每个信号都添加到set中
int sigaddset(sigset_t *set, int signum);
// 把signum添加到set
int sigdelset(sigset_t *set, int signum);
// 从set中删除signum
int sigismember(const sigset_t *set, int signum);
// 若signum是set的成员则返回1，如果不是则返回0，若出错则返回-1
```

### 8.5.5 编写信号处理程序

信号处理是Linux系统编程最棘手的一个问题。处理程序有几个属性使得它们很难推理分析:1)处理程序与主程序并发运行，共享同样的全局变量，因此可能与主程序和其他处理程序互相干扰;2)如何以及何时接收信号的规则常常有违人的直觉;3)不同的系统有不同的信号处理语义。

在本节中，我们将讲述这些问题，介绍编写安全、正确和可移植的信号处理程序的一些基本规则。

1. **安全的信号处理**

信号处理程序很麻烦是因为它们和主程序以及其他信号处理程序并发地运行，如果处理程序和主程序并发地访问同样的全局数据结构，那么结果可能就不可预知，而且经常是致命的。

我们会在第12章详细讲述并发编程。这里是一些保守的编写处理程序的原则，使得这些处理程序能安全地并发运行。

G0. **处理程序要尽可能简单**。避免麻烦的最好方法是保持处理程序尽可能小和简单。例如，处理程序可能只是简单地设置全局标志并立即返回;所有与接收信号相关的处理都由主程序执行，它周期性地检查(并重置)这个标志。

G1. **在处理程序中只调用异步信号安全的函数**。所谓异步信号安全的函数(或简称安全的函数)能够被信号处理程序安全地调用，原因有二:要么它是可重入的(例如只访问局部变量，见12.7.2节)，要么它不能被信号处理程序中断。

信号处理程序中产生输出唯一安全的方法是使用write函数(见10.1节)。特别地，调用printf或sprintf是不安全的。为了绕开这个不幸的限制，我们开发一些安全的函数，称为SIO(安全的I/O)包，可以用来在信号处理程序中打印简单的消息。

G2. **保存和恢复errno**。许多Linux异步信号安全的函数都会在出错返回时设置errno。在处理程序中调用这样的函数可能会干扰主程序中其他依赖于errno的部分。解决方法是在进入处理程序时把errno保存在一个局部变量中，在处理程序返回前恢复它。注意，只有在处理程序要返回时才有此必要。如果处理程序调用_exit终止该进程，那么就不需要这样做了。

G3. **阻塞所有的信号，保护对共享全局数据结构的访问**。如果处理程序和主程序或其他处理程序共享一个全局数据结构，那么在访问(读或者写)该数据结构时，你的处理程序和主程序应该暂时阻塞所有的信号。这条规则的原因是从主程序访问一个数据结构d通常需要一系列的指令，如果指令序列被访问d的处理程序中断，那么处理程序可能会发现d的状态不一致，得到不可预知的结果。在访问d时暂时阻塞信号保证了处理程序不会中断该指令序列。

G4. **用volatile声明全局变量。考虑一个处理程序和一个main函数，它们共享一个全局变量g**。处理程序更新g，main周期性地读g。对于一个优化编译器而言，main中g的值看上去从来没有变化过，因此使用缓存在寄存器中g的副本来满足对g的每次引用是很安全的。如果这样，main函数可能永远都无法看到处理程序更新过的值。可以用volatile类型限定符来定义一个变量，告诉编译器不要缓存这个变量。例如：`volatile int g;`；volatile限定符强迫编译器每次在代码中引用g时，都要从内存中读取g的值。一般来说，和其他所有共享数据结构一样，应该暂时阻塞信号，保护每次对全局变量的访问。

G5. **用sig_atomic_t声明标志。在常见的处理程序设计中，处理程序会写全局标志来记录收到了信号**。主程序周期性地读这个标志，响应信号，再清除该标志。对于通过这种方式来共享的标志，C提供一种整型数据类型sig_atomic_t，对它的读和写保证会是原子的(不可中断的)，因为可以用一条指令来实现它们:`volatile sig_atomic_t flag;`因为它们是不可中断的，所以可以安全地读和写sig_atomic_t变量，而不需要暂时阻塞信号。注意，这里对原子性的保证只适用于单个的读和写，不适用于像`flag++`或`flag=flag+10`这样的更新，它们可能需要多条指令。

2. 正确的信号处理

信号的一个与直觉不符的方面是未处理的信号是不排队的。因为pending位向量中每种类型的信号只对应有一位，所以每种类型最多只能有一个未处理的信号。因此，如果两个类型k的信号发送给一个目的进程，而因为目的进程当前正在执行信号k的处理程序，所以信号k被阻塞了，那么第二个信号就简单地被丢弃了﹔它不会排队。关键思想是如果存在一个未处理的信号就表明至少有一个信号到达了。因此不可以用信号来对其他进程中发生的事件计数。

3. 可移植的信号处理

Unix信号处理的另一个缺陷在于不同的系统有不同的信号处理语义。例如:

signal函数的语义各有不同。有些老的Unix系统在信号k被处理程序捕获之后就把对信号k的反应恢复到默认值。在这些系统上，每次运行之后，处理程序必须调用signal函数，显式地重新设置它自己。

系统调用可以被中断。像read、write和 accept这样的系统调用潜在地会阻塞进程一段较长的时间，称为慢速系统调用。在某些较早版本的Unix系统中，当处理程序捕获到一个信号时，被中断的慢速系统调用在信号处理程序返回时不再继续，而是立即返回给用户一个错误条件，并将errno设置为EINTR。在这些系统上，程序员必须包括手动重启被中断的系统调用的代码。

### 8.5.7 显式地等待信号

```C
#include <signal.h>
int sigsuspend(const sigset_t*mask);	// 返回—1。
```

sigsuspend函数暂时用mask替换当前的阻塞集合，然后挂起该进程，直到收到一个信号，其行为要么是运行一个处理程序，要么是终止该进程。如果它的行为是终止，那么该进程不从sigsuspend返回就直接终止。如果它的行为是运行一个处理程序，那么sigsuspend从处理程序返回，恢复调用sigsuspend时原有的阻塞集合。

sigsuspend函数等价于下述代码的原子的(不可中断的)版本:

```C
sigprocmask(SIG_SETMASK，&mask，&prev);
pause();
sigprocmask (SIG_SETMASK，&prev，NULL);
```

原子属性保证对sigprocmask(第1行)和pause(第2行)的调用总是一起发生的，不会被中断。这样就消除了潜在的竞争，即在调用sigprocmask之后但在调用pause之前收到了一个信号。

## 8.6 非本地跳转

C语言提供了一种用户级异常控制流形式，称为非本地跳转，它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列。非本地跳转是通过setjmp和longjmp函数俩提供的。

```C
#include <setjmp.h>int setjmp(jmp_buf env);
// 返回0int sigsetjmp(sigjmp_buf env,int savesigs);
// 返回非零
```

setjmp函数在env缓冲区中保存当前调用环境，以供后面的longjmp使用，并返回0。调用环境包括程序计数器、栈指针和通用目的寄存器。setjmp返回的值不能被赋值给变量，不过它可以安全地用在switch或条件语句的测试中。

```C
#include <setjmp.h>
void longjmp(jmp_buf env，int retval);
void siglongjmp(sigjmp_buf env，int retval);
```

**longjmp函数**从env缓冲区中恢复调用环境，然后触发一个从最近一次初始化env的setjmp调用的返回。然后setjmp返回，并带有非零的返回值retval。

**setjmp和longjmp之间的相互关系**令人迷惑。setjmp函数只被调用一次，但返回多次:一次是当第一次调用setjmp，而调用环境保存在缓冲区env中时，一次是为每个相应的longjmp调用。另一方面，longjmp函数被调用一次，但从不返回。

**非本地跳转**的一个重要**应用**就是允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。如果在一个深层嵌套的函数调用中发现了一个错误情况，我们可以使用非本地跳转直接返回到一个普通的本地化的错误处理程序，而不是费力地解开调用栈。

longjmp允许它跳过所有中间调用的特性可能产生意外的后果。例如，如果中间函数调用中分配了某些数据结构，本来预期在函数结尾处释放它们，那么这些释放代码会被跳过，因而会产生内存泄漏。

**非本地跳转**的另一个重要**应用**是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令的位置。

## 8.7 操作进程的工具

Linux系统提供了大量的监控和操作进程的有用工具。

STRACE:打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。用-static编译你的程序，能得到一个更干净的、不带有大量与共享库相关的输出的轨迹。

PS:列出当前系统中的进程(包括僵死进程)。

TOP:打印出关于当前进程资源使用的信息。

PMAP:显示进程的内存映射。

/proc:一个虚拟文件系统，以ASCII文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容。比如，输入`cat/proc/loadavg`可以看到Linux系统上当前的平均负载。

## 8.8 小结

异常控制流(ECF)发生在计算机系统的各个层次，是计算机系统中提供并发的基本机制。

在硬件层，异常是由处理器中的事件触发的控制流中的突变。控制流传递给一个软件处理程序，该处理程序进行一些处理,然后返回控制给被中断的控制流。

有四种不同类型的异常:中断、故障、终止和陷阱。当一个外部I/O设备(例如定时器芯片或者磁盘控制器)设置了处理器芯片上的中断管脚时，(对于任意指令)中断会异步地发生。控制返回到故障指令后面的那条指令。一条指令的执行可能导致故障和终止同步发生。故障处理程序会重新启动故障指令，而终止处理程序从不将控制返回给被中断的流。最后，陷阱就像是用来实现向应用提供到操作系统代码的受控的入口点的系统调用的函数调用。

在操作系统层，内核用ECF提供进程的基本概念。进程提供给应用两个重要的抽象:1)逻辑控制流，它提供给每个程序一个假象，好像它是在独占地使用处理器，2)私有地址空间，它提供给每个程序一个假象，好像它是在独占地使用主存。

在操作系统和应用程序之间的接口处，应用程序可以创建子进程，等待它们的子进程停止或者终止，运行新的程序，以及捕获来自其他进程的信号。信号处理的语义是微妙的，并且随系统不同而不同。然而，在与Posix兼容的系统上存在着一些机制，允许程序清楚地指定期望的信号处理语义。

最后，在应用层，C程序可以使用非本地跳转来规避正常的调用/返回栈规则，并且直接从一个函数分支到另一个函数。
