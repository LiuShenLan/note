- [处理器体系结构](#处理器体系结构)
	- [4.1 Y86-64指令集体系结构](#41-y86-64指令集体系结构)
		- [4.1.1 程序员可见状态](#411-程序员可见状态)
	- [4.2 逻辑设计和硬件控制语言HCL](#42-逻辑设计和硬件控制语言hcl)
		- [4.2.2 组合电路和HCL布尔表达式](#422-组合电路和hcl布尔表达式)
		- [4.2.5 存储器和时钟](#425-存储器和时钟)
	- [4.3 Y86-64的顺序实现](#43-y86-64的顺序实现)
		- [4.3.1 将处理组织成阶段](#431-将处理组织成阶段)
		- [4.3.2 SEQ硬件结构](#432-seq硬件结构)
		- [4.3.3 SEQ的时序](#433-seq的时序)
		- [4.3.4 SEQ阶段的实现](#434-seq阶段的实现)
	- [4.4 流水线的通用原理](#44-流水线的通用原理)
		- [4.4.2 流水线操作的详细说明](#442-流水线操作的详细说明)
		- [4.4.3 流水线的局限性](#443-流水线的局限性)
		- [4.4.4 带反馈的流水线系统](#444-带反馈的流水线系统)
	- [4.5 Y86-64的流水线实现](#45-y86-64的流水线实现)
		- [4.5.1 SEQ+：重新安排计算阶段](#451-seq重新安排计算阶段)
		- [4.5.2 插入流水线寄存器](#452-插入流水线寄存器)
		- [4.5.3 对信号进行重新排列和标号](#453-对信号进行重新排列和标号)
		- [4.5.4 预测下一个PC](#454-预测下一个pc)
		- [4.5.5 流水线冒险](#455-流水线冒险)
		- [4.5.6 异常处理](#456-异常处理)
		- [4.5.8 流水线控制逻辑](#458-流水线控制逻辑)
		- [4.5.9 性能分析](#459-性能分析)
		- [4.5.10 未完成的工作](#4510-未完成的工作)
	- [4.6 小结](#46-小结)

# 处理器体系结构

一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构(ISA)。

## 4.1 Y86-64指令集体系结构

定义一个指令集体系结构包括定义各种状态单元、指令集和他们的编码、一组编程规范和异常事件处理。

### 4.1.1 程序员可见状态

Y86-64程序中的每条指令都会读取或修改处理器状态的某些部分。这称为**程序员可见状态**，这里的“程序员”既可以是用汇编代码写程序的人，也可以是产生机器级代码的编译器。在处理器实现中,只要我们保证机器级程序能够访问程序员可见状态，就不需要完全按照ISA暗示的方式来表示和组织这个处理器状态。

**内存**从概念上来说就是一个很大的字节数组，保存着程序和数据。Y86-64程序用虚拟地址来引用内存位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或物理地址，指明数据实际存在内存中哪个地方。第9章将更详细地研究虚拟内存。现在，我们只认为虚拟内存系统向Y86-64程序提供了一个单一的字节数组映像。

## 4.2 逻辑设计和硬件控制语言HCL

在硬件设计中，用电子电路来计算对位进行运算的函数，以及在各种存储器单元中存储位。大多数现代电路技术都是用信号线上的高电压或低电压来表示不同的位值。在当前的技术中，逻辑1是用1.О伏特左右的高电压表示的，而逻辑0是用0.0伏特左右的低电压表示的。要实现一个数字系统需要三个主要的组成部分：计算对位进行操作的函数的组合逻辑、存储位的存储器单元，以及控制存储器单元更新的时钟信号。

### 4.2.2 组合电路和HCL布尔表达式

将很多的逻辑门组合成一个网，就能构建计算块，称为组合电路。如何构建这些网有几个限制：

* 每个逻辑门的输入必须连接到下述选项之一：
	* 一个系统输入(称为主输入)
	* 某个存储器单元的输出
	* 某个逻辑门的输出。

* 两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障。

* 这个网必须是无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，这样的回路会导致该网络计算的函数有歧义。

HCL表达式很清楚地表明了组合逻辑电路和C语言中逻辑表达式的对应之处。它们都是用布尔操作来对输入进行计算的函数。值得注意的是，这两种表达计算的方法之间有以下**区别**：

* 因为组合电路是由一系列的逻辑门组成，它的属性是输出会持续地响应输入的变化。如果电路的输入变化了，在一定的延迟之后，输出也会相应地变化。相比之下，C表达式只会在程序执行过程中被遇到时才进行求值。* C的逻辑表达式允许参数是任意整数，0表示FALSE，其他任何值都表示TRUE。而逻辑门只对位值0和1进行操作。* C的逻辑表达式有个属性就是它们可能只被部分求值。如果一个AND 或OR操作的结果只用对第一个参数求值就能确定，那么就不会对第二个参数求值了。而组合逻辑没有部分求值这条规则，逻辑门只是简单地相应输入的变化。

### 4.2.5 存储器和时钟

组合电路从本质上讲，不存储任何信息。相反，它们只是简单地响应输入信号，产生等于输入的某个函数的输出。为了产生时序电路(sequential circuit)，也就是有状态并且在这个状态上进行计算的系统，我们必须引入按位存储信息的设备。存储设备都是由同一个时钟控制的，时钟是一个周期性信号，决定什么时候要把新值加载到设备中。考虑两类**存储器设备**：

* 时钟寄存器(简称寄存器)存储单个位或字。时钟信号控制寄存器加载输入值。

* 随机访问存储器(简称内存)存储多个字，用地址来选择该读或该写哪个字。随机访问存储器的例子包括：1)处理器的虚拟内存系统，硬件和操作系统软件结合起来使处理器可以在一个很大的地址空间内访问任意的字﹔2)寄存器文件，在此，寄存器标识符作为地址。在IA32或Y86-64处理器中，寄存器文件有15个程序寄存器(%rax～%r14)。

正如我们看到的那样，在说到硬件和机器级编程时，“**寄存器**”这个词是两个有细微差别的事情。在硬件中，寄存器直接将它的输入和输出线连接到电路的其他部分。在机器级编程中，寄存器代表的是CPU中为数不多的可寻址的字，这里的地址是寄存器ID。这些字通常都存在寄存器文件中，虽然我们会看到硬件有时可以直接将一个字从一个指令传送到另一个指令，以避免先写寄存器文件再读出来的延迟。需要避免歧义时，我们会分别称呼这两类寄存器为“硬件寄存器”和“程序寄存器”。

一个**硬件寄存器以及它是如何工作**的：大多数时候，寄存器都保持在稳定状态(用x表示)，产生的输出等于它的当前状态。信号沿着寄存器前面的组合逻辑传播，这时，产生了一个新的寄存器输入(用y表示)，但只要时钟是低电位的，寄存器的输出就仍然保持不变。当时钟变成高电位的时候，输入信号就加载到寄存器中，成为下一个状态y，直到下一个时钟上升沿，这个状态就一直是寄存器的新输出。关键是寄存器是作为电路不同部分中的组合逻辑之间的屏障。每当每个时钟到达上升沿时，值才会从寄存器的出入传送到输出。

**典型的寄存器文件**：寄存器文件有两个读端口(A和B)，还有一个写端口(W)。这样一个多端口随机访问存储器允许同时进行多个读和写操作。电路可以读两个程序寄存器的值，同时更新第三个寄存器的状态。每个端口都有一个地址输入，表明该选择哪个程序寄存器，另外还有一个数据输出或对应该程序寄存器的输入值。地址是用编码表示的寄存器标识符。两个读端口有地址输入srcA和srcB(“source A”和“source B"的缩写)和数据输出valA和 valB(“value A”和“value B”的缩写)。写端口有地址输入dstw(“destination W”的缩写)，以及数据输入valw(“value W"的缩写)。

虽然寄存器文件不是组合电路，因为它有内部存储。不过，在我们的实现中，从寄存器文件读数据就好像它是一个以地址为输入、数据为输出的一个组合逻辑块。当srcA或srcB被设成某个寄存器ID时，在一段延迟之后，存储在相应程序寄存器的值就会出现在valA或valB上。例如，将srcA设为3，就会读出程序寄存器%rbx的值，然后这个值就会出现在输出valA 上。

**向寄存器文件写入字**是由时钟信号控制的，控制方式类似于将值加载到时钟寄存器。每次时钟上升时，输入valw上的值会被写入输入dstw上的寄存器ID指示的程序寄存器。当dstw设为特殊的ID值0xF时，不会写任何程序寄存器。由于寄存器文件既可以读也可以写，一个很自然的问题就是“如果我们试图同时读和写同一个寄存器会发生什么?”答案简单明了：如果更新一个寄存器，同时在读端口上用同一个寄存器D，我们会看到一个从旧值到新值的变化。当我们把这个寄存器文件加入到处理器设计中，我们保证会考虑到这个属性的。

**随机访问存储器**：这个内存有一个地址输入，一个写的数据输入，以及一个读的数据输出。同寄存器文件一样，从内存中读的操作方式类似于组合逻辑：如果我们在输入address上提供一个地址,并将write控制信号设置为0，那么在经过一些延迟之后，存储在那个地址上的值会出现在输出data上。如果地址超出了范围，error信号会设置为1，否则就设置为0。写内存是由时钟控制的：我们将address设置为期望的地址，将data in设置为期望的值，write设置为1。然后当我们控制时钟时，只要地址是合法的，就会更新内存中指定的位置。对于读操作来说，如果地址是不合法的，error信号会被设置为1。这个信号是由组合逻辑产生的，因为所需要的边界检查纯粹就是地址输入的函数，不涉及保存任何状态。

## 4.3 Y86-64的顺序实现

现在已经有了实现Y86-64处理器所需要的部件。首先，我们描述一个称为SEQ(“sequential”顺序的)的处理器。每个时钟周期上，SEQ执行处理一条完整指令所需的所有步骤。不过，这需要一个很长的时钟周期时间，因此时钟周期频率会低到不可接受。我们开发SEQ的目标就是提供实现最终目的的第一步，我们的最终目的是实现一个高效的、流水线化的处理器。

### 4.3.1 将处理组织成阶段

通常，处理一条指令包括很多操作。将它们组织成某个特殊的阶段序列，即使指令的动作差异很大，但所有的指令都遵循统一的序列。每一步的具体处理取决于正在执行的指令。创建这样一个框架，我们就能够设计一个充分利用硬件的处理器。下面是关于**各个阶段以及各阶段内执行操作**的简略描述：

* 取指( fetch)：取指阶段从内存读取指令字节，地址为程序计数器(PC)的值。从指令中抽取出指令指示符字节的两个四位部分，称为icode(指令代码)和 ifun(指令功能)。它可能取出一个寄存器指示符字节，指明一个或两个寄存器操作数指示符rA和rB。它还可能取出一个四字节常数字valc。它按顺序方式计算当前指令的下一条指令的地址valP。也就是说，valP等于PC的值加上已取出指令的长度。

* 译码(decode)：译码阶段从寄存器文件读入最多两个操作数，得到值valA和/或valB。通常，它读入指令rA和rB字段指明的寄存器，不过有些指令是读寄存器%rsp的。

* 执行(execute)：在执行阶段，算术/逻辑单元(ALU)要么执行指令指明的操作(根据ifun的值)，计算内存引用的有效地址，要么增加或减少栈指针。得到的值我们称为valE。在此，也可能设置条件码。对一条条件传送指令来说，这个阶段会检验条件码和传送条件(由ifun给出)，如果条件成立，则更新目标寄存器。同样，对一条跳转指令来说，这个阶段会决定是不是应该选择分支。

* 访存(memory)：访存阶段可以将数据写入内存，或者从内存读出数据。读出的值为valM。

* 写回( write back)：写回阶段最多可以写两个结果到寄存器文件

* 更新PC(PC update)：将PC设置成下一条指令的地址。

处理器无限循环，执行这些阶段。在我们简化的实现中，发生任何异常时，处理器就会停止：它执行halt 指令或非法指令，或它试图读或者写非法地址。在更完整的设计中，处理器会进入异常处理模式，开始执行由异常的类型决定的特殊代码。

### 4.3.2 SEQ硬件结构

硬件单元与处理阶段的关联：

* 取指：将程序计数器寄存器作为地址，指令内存读取指令的字节。PC增加器(PC incrementer)计算valP，即增加了的程序计数器。

* 译码：寄存器文件有两个读端口A和B，从这两个端口同时读寄存器值valA和valB。

* 执行：执行阶段会根据指令的类型，将算术/逻辑单元(ALU)用于不同的目的。对整数操作，它要执行指令所指定的运算。对其他指令，它会作为一个加法器来计算增加或减少栈指针，或者计算有效地址，或者只是简单地加0，将一个输入传递到输出。

条件码寄存器(CC)有三个条件码位。ALU负责计算条件码的新值。当执行条件传送指令时，根据条件码和传送条件来计算决定是否更新目标寄存器。同样，当执行一条跳转指令时，会根据条件码和跳转类型来计算分支信号Cnd。

* 访存：在执行访存操作时，数据内存读出或写入一个内存字。指令和数据内存访问的是相同的内存位置,但是用于不同的目的。

* 写回：寄存器文件有两个写端口。端口E用来写ALU计算出来的值，而端口M用来写从数据内存中读出的值。

* PC更新：程序计数器的新值选择自：valP，下一条指令的地址；valc，调用指令或跳转指令指定的目标地址；valM，从内存读取的返回地址。

### 4.3.3 SEQ的时序

**SEQ的实现**包括组合逻辑和两种存储器设备:时钟寄存器(程序计数器和条件码寄存器)，随机访问存储器(寄存器文件、指令内存和数据内存)。组合逻辑不需要任何时序或控制，只要输入变化了，值就通过逻辑门网络传播。正如提到过的那样，我们也将读随机访问存储器看成和组合逻辑一样的操作，根据地址输入产生输出字。对于较小的存储器来说(例如寄存器文件)，这是一个合理的假设，而对于较大的电路来说，可以用特殊的时钟电路来模拟这个效果。由于指令内存只用来读指令，因此我们可以将这个单元看成是组合逻辑。

现在还剩四个硬件单元需要对它们的时序进行明确的控制——程序计数器、条件码寄存器、数据内存和寄存器文件。这些单元通过一个时钟信号来控制，它触发将新值装载到寄存器以及将值写到随机访问存储器。每个时钟周期，程序计数器都会装载新的指令地址。只有在执行整数运算指令时，才会装载条件码寄存器。只有在执行rmmovq、pushq或call指令时，才会写数据内存。寄存器文件的两个写端口允许每个时钟周期更新两个程序寄存器，不过我们可以用特殊的寄存器ID 0xF作为端口地址,来表明在此端口不应该执行写操作。

要控制处理器中活动的时序，只需要寄存器和内存的时钟控制。硬件获得了那些赋值顺序执行一样的效果，即使所有的状态更新实际上同时发生，且只在时钟上升开始下一个周期时。之所以能保持这样的等价性，是由于Y86-64指令集的本质，因为我们遵循以下原则组织计算:从不回读，处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。

### 4.3.4 SEQ阶段的实现

可以看到，通过将执行每条不同指令所需的步骤组织成一个统一的流程，就可以用很少量的各种硬件单元以及一个时钟来控制计算的顺序，从而实现整个处理器。不过这样一来，控制逻辑就必须要在这些单元之间路由信号，并根据指令类型和分支条件产生适当的控制信号。

SEQ唯一的问题就是它太慢了。时钟必须非常慢，以使信号能在一个周期内传播所有的阶段。如一条ret指令，在时钟周期起始时，从更新过的PC开始，要从指令内存中读出指令，从寄存器文件中读出栈指针，ALU将栈指针加8，为了得到程序计数器的下一个值，还要从内存中读出返回地址。所有这一切都必须在这个周期结束之前完成。

这种实现方法不能充分利用硬件单元，因为每个单元只在整个时钟周期的一部分时间内才被使用。我们会看到引入流水线能获得更好的性能。

## 4.4 流水线的通用原理

流水线化的一个重要特性就是提高了系统的吞吐量(throughput)，也就是单位时间内服务的顾客总数，不过它也会轻微地增加延迟(latency)，也就是服务一个用户所需要的时间。

### 4.4.2 流水线操作的详细说明

减缓时钟不会影响流水线的行为。信号传播到流水线寄存器的输入，但是直到时钟上升时才会改变寄存器的状态。另一方面，如果时钟运行得太快，就会有灾难性的后果。值可能会来不及通过组合逻辑，因此当时钟上升时，寄存器的输入还不是合法的值。

根据对SEQ处理器时序的讨论，我们看到这种在组合逻辑块之间采用时钟寄存器的简单机制，足够控制流水线中的指令流。随着时钟周而复始地上升和下降，不同的指令就会通过流水线的各个阶段，不会相互干扰。

### 4.4.3 流水线的局限性

1. 不一致的划分

由不一致的阶段延迟造成的流水线技术的局限性。系统的吞吐量受最慢阶段的速度所限制对硬件设计者来说，将系统计算设计划分成一组具有相同延迟的阶段是一个严峻的挑战。通常，处理器中的某些硬件单元，如ALU和内存，是不能被划分成多个延迟较小的单元的。这就使得创建一组平衡的阶段非常困难。

2. 流水线过深，收益反而下降

由开销造成的流水线技术的局限性。在组合逻辑被分成较小的块时，由流水线寄存器更新引起的延迟就成为了一个限制因素

### 4.4.4 带反馈的流水线系统

相邻指令之间很可能是相关的，包括数据相关或控制相关。在SEQ设计中，这些相关都是由反馈路径来解决的。这些反馈将更新了的寄存器值向下传送到寄存器文件

## 4.5 Y86-64的流水线实现

### 4.5.1 SEQ+：重新安排计算阶段

作为实现流水线化设计的一个过渡步骤，我们必须稍微调整一下SEQ中五个阶段的顺序，使得更新PC阶段在一个时钟周期开始时执行，而不是结束时才执行。只需要对整体硬件结构做最小的改动，对于流水线阶段中的活动的时序，它能工作得更好。我们称这种修改过的设计为“SEQ+”。

SEQ到SEQ+中对状态单元的改变是一种很通用的改进的例子，这种改进称为电路重定时(circuit retiming)。重定时改变了一个系统的状态表示，但是并不改变它的逻辑行为。通常用它来平衡一个流水线系统中各个阶段之间的延迟。

### 4.5.2 插入流水线寄存器

流水线寄存器按如下方式标号：

* F：保存程序计数器的预测值。

* D：位于取指和译码阶段之间。它保存关于最新取出的指令的信息，即将由译码阶段进行处理。

* E：位于译码和执行阶段之间。它保存关于最新译码的指令和从寄存器文件读出的值得信息，即将由执行阶段进行处理。

* M：位于执行和访存阶段之间。它曹村最新执行的指令的结果，即将由访存阶段进行处理。他还保存关于用于条件转移的分支条件和分支目标的信息。

* W：位于访存阶段和反馈路径之间，反馈路径将计算出来的值提供给寄存器文件写，而当完成ret指令时，它还要想PC选择逻辑提供返回地址。

### 4.5.3 对信号进行重新排列和标号

顺序实现SEQ和SEQ+在一个时刻只处理一条指令，因此诸如valc、srcA和valB这样的信号值有唯一的值。在流水线化的设计中，与各个指令相关联的这些值有多个版本，会随着指令一起流过系统。例如，在 PIPE-的详细结构中，有4个标号为“Stat”的白色方框，保存着4条不同指令的状态码。我们需要很小心以确保使用的是正确版本的信号，否则会有很严重的错误，例如将一条指令计算出的结果存放到了另一条指令指定的目的寄存器。我们采用的命名机制，通过在信号名前面加上大写的流水线寄存器名字作为前缀，存储在流水线寄存器中的信号可以唯一地被标识。例如，4个状态码可以被命名为D_stat、E_stat、M_stat和W_stat。我们还需要引用某些在一个阶段内刚刚计算出来的信号。它们的命名是在信号名前面加上小写的阶段名的第一个字母作为前缀。以状态码为例，可以看到在取指和访存阶段中标号为“Stat”的控制逻辑块。因而，这些块的输出被命名为f_stat和m_stat。我们还可以看到整个处理器的实际状态Stat是根据流水线寄存器W中的状态值,由写回阶段中的块计算出来的。

在命名系统中，大写的前缀“D”、“E”、“M”和“W”指的是流水线寄存器，所以M_stat指的是流水线寄存器M的状态码字段。小写的前缀“f”、“d”、“e”、“m”和“w”指的是流水线阶段，所以m_stat 指的是在访存阶段中由控制逻辑块产生出的状态信号。

### 4.5.4 预测下一个PC

在PIPE-设计中，我们采取了一些措施来正确处理控制相关。流水线化设计的目的就是每个时钟周期都发射一条新指令，也就是说每个时钟周期都有一条新指令进入执行阶段并最终完成。要是达到这个目的也就意味着吞吐量是每个时钟周期一条指令。要做到这一点，我们必须在取出当前指令之后，马上确定下一条指令的位置。不幸的是，如果取出的指令是条件分支指令，要到几个周期后，也就是指令通过执行阶段之后，我们才能知道是否要选择分支。类似地，如果取出的指令是ret，要到指令通过访存阶段，才能确定返回地址。

除了条件转移指令和ret以外，根据取指阶段中计算出的信息，我们能够确定下一条指令的地址。对于call和 jmp(无条件转移)来说，下一条指令的地址是指令中的常数字valc，而对于其他指令来说就是valP。因此，通过预测PC的下一个值，在大多数情况下，我们能达到每个时钟周期发射一条新指令的目的。对大多数指令类型来说，我们的预测是完全可靠的。对条件转移来说，我们既可以预测选择了分支，那么新PC值应为valc，也可以预测没有选择分支，那么新PC值应为valP。无论哪种情况，我们都必须以某种方式来处理预测错误的情况，因为此时已经取出并部分执行了错误的指令。我们会在4.5.8节中再讨论这个问题。

分支预测错误会极大地降低程序的性能，因此这就促使我们在可能的时候，要使用条件数据传送而不是条件控制转移。

### 4.5.5 流水线冒险

将流水线技术引入一个带反馈的系统，当相邻指令间存在相关时会导致出现问题。在完成我们的设计之前，必须解决这个问题。这些相关有两种形式:1)数据相关，下一条指令会用到这一条指令计算出的结果;2)控制相关，一条指令要确定下一条指令的位置，例如在执行跳转、调用或返回指令时。这些相关可能会导致流水线产生计算错误，称为冒险(hazard)。同相关一样，冒险也可以分为两类:数据冒险(data hazard)和控制冒险(control hazard)。

如果一条指令的操作数被它前面三条指令中的任意一条改变的话，都会出现**数据冒险**。之所以会出现这些冒险，是因为我们的流水线化的处理器是在译码阶段从寄存器文件中读取指令的操作数，而要到三个周期以后，指令经过写回阶段时，才会将指令的结果写到寄存器文件。

1. 用暂停来避免数据冒险

暂停是避免冒险的一种常用技术，暂停时，处理器会停止流水线中一条或多条指令，直到冒险条件不再满足。让一条指令停顿在译码阶段，直到产生它的源操作数的指令通过了写回阶段，这样我们的处理器就能避免数据冒险。将一条指令阻塞在译码阶段时，我们还必须将紧跟其后的下一条指令阻塞在取指阶段。通过将程序计数器保持不变就能做到这一点，这样一来，会不断地对halt 指令进行取指,直到暂停结束。虽然实现这一机制相当容易，但是得到的性能并不很好。一条指令更新一个寄存器，紧跟其后的指令就使用被更新的寄存器，这会导致流水线暂停长达三个周期，严重降低了整体的吞吐量。

1. 用转发来避免数据冒险

PIPE-的设计是在译码阶段从寄存器文件中读入源操作数，但是对这些源寄存器的写有可能要在写回阶段才能进行。与其暂停直到写完成，不如简单地将要写的值传到流水线寄存器E作为源操作数。

译码阶段逻辑发现，寄存器%rax是操作数valB的源寄存器，而在写端口E上还有一个对%rax的未进行的写。它只要简单地将提供到端口E的数据字(信号w_valE)作为操作数valB的值，就能避免暂停。这种将结果值直接从一个流水线阶段传到较早阶段的技术称为数据转发(data forwarding，或简称转发，有时称为旁路(bypassing))。数据转发需要在基本的硬件结构中增加一些额外的数据连接和控制逻辑。

3. 加载/使用数据冒险

有一类数据冒险不能单纯用转发来解决，因为内存读在流水线发生的比较晚。我们可以将暂停和转发结合起来，避免加载/使用数据冒险。这个需要修改控制逻辑，但是可以使用现有的旁路路径。当读取指令通过执行阶段时，流水线控制逻辑发现译码阶段中的指令需要从内存中读出的结果。它会将译码阶段中的指令暂停一个周期，导致执行阶段中插入一个气泡。从内存中读出的值可以从访存阶段转发到译码阶段中的addq指令。寄存器的值也可以从访存阶段转发到译码阶段。插入的气泡代替了正常情况下本来应该继续通过流水线的现在位于译码阶段的指令。

这种用暂停来处理加载/使用冒险的方法称为加载互锁(load interlock)。加载互锁和转发技术结合起来足以处理所有可能类型的数据冒险。因为只有加载互锁会降低流水线的吞吐量，我们几乎可以实现每个时钟周期发射一条新指令的吞吐量目标。

4. 避免控制冒险

当处理器无法根据处于取指阶段的当前指令来确定下一条指令的地址时，就会出现控制冒险。

指令时按照它们进入流水线的顺序列出的，而不是按照它们出现在程序中的顺序。因为预测跳转指令会选择分支，所以周期3中会取出位于跳转目标处的指令，而周期4中会取出该指令后的那条指令。在周期4，分支逻辑发现不应该选择分支之前，已经取出了两条指令，它们不应该继续执行下去了。幸运的是，这两条指令都没有导致程序员可见的状态发生改变。只有到指令到达执行阶段时才会发生那种情况，在执行阶段中，指令会改变条件码。我们只要在下一个周期往译码和执行阶段中插入气泡，并同时取出跳转指令后面的指令，这样就能取消(有时也称为指令排除(instruction squashing))那两条预测错误的指令。这样一来，两条预测错误的指令就会简单地从流水线中消失，因此不会对程序员可见的状态产生影响。唯一的缺点是两个时钟周期的指令处理能力被浪费了。

对控制冒险的讨论表明，通过慎重考虑流水线的控制逻辑，控制冒险是可以被处理的。在出现特殊情况时，暂停和往流水线中插入气泡的技术可以动态调整流水线的流程。如同我们将在4.5.8节中讨论的一样，对基本时钟寄存器设计的简单扩展就可以让我们暂停流水段，并向作为流水线控制逻辑一部分的流水线寄存器中插入气泡。

### 4.5.6 异常处理

正如第8章中将讨论的，处理器中很多事情都会导致异常控制流，此时，程序执行的正常流程被破坏掉。异常可以由程序执行从内部产生，也可以由某个外部信号从外部产生。我们的指令集体系结构包括三种不同的内部产生的异常:1)halt指令，2)有非法指令和功能码组合的指令，3)取指或数据读写试图访问一个非法地址。一个更完整的处理器设计应该也能处理外部异常，例如当处理器收到一个网络接口收到新包的信号，或是一个用户点击鼠标按钮的信号。正确处理异常是任何微处理器设计中很有挑战性的一方面。异常可能出现在不可预测的时间，需要明确地中断通过处理器流水线的指令流。我们对这三种内部异常的处理只是让你对正确发现和处理异常的真实复杂性略有了解。

我们把导致异常的指令称为异常指令。在使用非法指令地址的情况中，没有实际的异常指令，但是想象在非法地址处有一种“虚拟指令”会有所帮助。在简化的ISA模型中，我们希望当处理器遇到异常时，会停止，设置适当的状态码。在一个更完整的设计中，处理器会继续调用异常处理程序，这是操作系统的一部分。

在一个流水线化的系统中，异常处理包括一些**细节问题**。  * 首先，可能同时有多条指令会引起异常。例如，在一个流水线操作的周期内，取指阶段中有halt指令，而数据内存会报告访存阶段中的指令数据地址越界。我们必须确定处理器应该向操作系统报告哪个异常。基本原则是:由流水线中最深的指令引起的异常，优先级最高。在上面那个例子中，应该报告访存阶段中指令的地址越界。

  * 第二个细节问题是，当首先取出一条指令，开始执行时，导致了一个异常，而后来由于分支预测错误，取消了该指令。我们想要避免出现异常。

  * 第三个细节问题的产生是因为流水线化的处理器会在不同的阶段更新系统状态的不同部分。有可能会出现这样的情况，一条指令导致了一个异常，它后面的指令在异常指令完成之前改变了部分状态。

一般地，通过在流水线结构中加入异常处理逻辑，我们既能够从各个异常中做出正确的选择，也能够避免出现由于分支预测错误取出的指令造成的异常。这就是为什么我们会在每个流水线寄存器中包括一个状态码stat。如果一条指令在其处理中于某个阶段产生了一个异常，这个状态字段就被设置成指示异常的种类。异常状态和该指令的其他信息一起沿着流水线传播，直到它到达写回阶段。在此，流水线控制逻辑发现出现了异常，并停止执行。

为了避免异常指令之后的指令更新任何程序员可见的状态，当处于访存或写回阶段中的指令导致异常时，流水线控制逻辑必须禁止更新条件码寄存器或是数据内存。

让我们来看看这种处理异常的方法是**怎样解决刚才提到的那些细节问题**的。当流水线中有一个或多个阶段出现异常时，信息只是简单地存放在流水线寄存器的状态字段中。异常事件不会对流水线中的指令流有任何影响，除了会禁止流水线中后面的指令更新程序员可见的状态(条件码寄存器和内存)，直到异常指令到达最后的流水线阶段。因为指令到达写回阶段的顺序与它们在非流水线化的处理器中执行的顺序相同，所以我们可以保证第一条遇到异常的指令会第一个到达写回阶段,此时程序执行会停止,流水线寄存器W中的状态码会被记录为程序状态。如果取出了某条指令，过后又取消了，那么所有关于这条指令的异常状态信息也都会被取消。所有导致异常的指令后面的指令都不能改变程序员可见的状态。携带指令的异常状态以及所有其他信息通过流水线的简单原则是处理异常的简单而可靠的机制。

### 4.5.8 流水线控制逻辑

现在准备创建流水线控制逻辑，完成我们的PIPE设计。这个逻辑必须处理下面4种控制情况，这些情况是其他机制(例如数据转发和分支预测)不能处理的:

加载/使用冒险:在一条从内存中读出一个值的指令和一条使用该值的指令之间，流水线必须暂停一个周期。

处理ret:流水线必须暂停直到ret指令到达写回阶段。

预测错误的分支:在分支逻辑发现不应该选择分支之前，分支目标处的几条指令已经进入流水线了。必须取消这些指令，并从跳转指令后面的那条指令开始取指。

异常:当一条指令导致异常，我们想要禁止后面的指令更新程序员可见的状态，并且在异常指令到达写回阶段时，停止执行。

### 4.5.9 性能分析

我们可以看到，所有需要流水线控制逻辑进行特殊处理的条件，都会导致流水线不能够实现每个时钟周期发射一条新指令的目标。我们可以通过确定往流水线中插入气泡的频率，来衡量这种效率的损失，因为插入气泡会导致未使用的流水线周期。一条返回指令会产生三个气泡，一个加载/使用冒险会产生一个，而一个预测错误的分支会产生两个。我们可以通过计算PIPE执行一条指令所需要的平均时钟周期数的估计值，来量化这些处罚对整体性能的影响，这种衡量方法称为CPI(Cycles Per Instruction，每指令周期数)。这种衡量值是流水线平均吞吐量的倒数，不过时间单位是时钟周期，而不是微微秒。这是一个设计体系结构效率的很有用的衡量标准。

### 4.5.10 未完成的工作

1. 多周期指令

Y86-64指令集中的所有指令都包括一些简单的操作，例如数字加法。这些操作可以在执行阶段中一个周期内处理完。在一个更完整的指令集中，我们还将实现一些需要更为复杂操作的指令，例如，整数乘法和除法，以及浮点运算。

2. 与存储系统的接口

在对PIPE的描述中，我们假设取指单元和数据内存都可以在一个时钟周期内读或是写内存中任意的位置。我们还忽略了由自我修改代码造成的可能冒险，在自我修改代码中，一条指令对一个存储区域进行写，而后面又从这个区域中读取指令。进一步说，我们是以存储器位置的虚拟地址来引用它们的，这要求在执行实际的读或写操作之前，要将虚拟地址翻译成物理地址。显然，要在一个时钟周期内完成所有这些处理是不现实的。更糟糕的是，要访问的存储器的值可能位于磁盘上，这会需要上百万个时钟周期才能把数据读入到处理器内存中。

## 4.6 小结

我们已经看到，指令集体系结构，即ISA，在处理器行为(就指令集合及其编码而言)和如何实现处理器之间提供了一层抽象。ISA提供了程序执行的一种顺序说明，也就是一条指令执行完了，下一条指令才会开始。

从IA32指令开始，大大简化数据类型、地址模式和指令编码，我们定义了Y86-64指令集。得到的ISA既有RISC指令集的属性，也有CISC指令集的属性。然后，将不同指令组织放到五个阶段中处理，在此，根据被执行的指令的不同，每个阶段中的操作也不相同。据此，我们构造了SEQ处理器，其中每个时钟周期执行一条指令，它会通过所有五个阶段。

流水线化通过让不同的阶段并行操作，改进了系统的吞吐量性能。在任意一个给定的时刻，多条指令被不同的阶段处理。在引入这种并行性的过程中，我们必须非常小心，以提供与程序的顺序执行相同的程序级行为。通过重新调整SEQ各个部分的顺序，引入流水线，我们得到SEQ+，接着添加流水线寄存器，创建出PIPE一流水线。然后，添加了转发逻辑，加速了将结果从一条指令发送到另一条指令，从而提高了流水线的性能。有几种特殊情况需要额外的流水线控制逻辑来暂停或取消一些流水线阶段。

我们的设计中包括了一些基本的异常处理机制，在此，保证只有到异常指令之前的指令会影响程序员可见的状态。实现完整的异常处理远比此更具挑战性。在采用了更深流水线和更多并行性的系统中，要想正确处理异常就更加复杂了。

在本章中，我们学习了有关处理器设计的几个重要经验:

* 管理复杂性是首要问题。想要优化使用硬件资源，在最小的成本下获得最大的性能。为了实现这个目的，我们创建了一个非常简单而一致的框架，来处理所有不同的指令类型。有了这个框架，就能够在处理不同指令类型的逻辑中共享硬件单元。

* 我们不需要直接实现ISA。ISA的直接实现意味着一个顺序的设计。为了获得更高的性能，我们想运用硬件能力以同时执行许多操作，这就导致要使用流水线化的设计。通过仔细的设计和分析,我们能够处理各种流水线冒险，因此运行一个程序的整体效果，同用ISA模型获得的效果完全一致。

* 硬件设计人员必须非常谨慎小心。一旦芯片被制造出来，就几乎不可能改正任何错误了。一开始就使设计正确是非常重要的。这就意味着要仔细地分析各种指令类型和组合，甚至于那些看上去没有意义的情况，例如弹出值到栈指针。必须用系统的模拟测试程序彻底地测试设计。在开发PIPE的控制逻辑中，我们的设计有个细微的错误，只有通过对控制组合的仔细而系统的分析才能发现。
