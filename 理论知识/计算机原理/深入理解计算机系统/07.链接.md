- [链接](#链接)
	- [7.1 编译器驱动程序](#71-编译器驱动程序)
	- [7.2 静态链接](#72-静态链接)
	- [7.3 目标文件](#73-目标文件)
	- [7.4 可重定位目标文件](#74-可重定位目标文件)
	- [7.5 符号和符号表](#75-符号和符号表)
	- [7.6 符号解析](#76-符号解析)
		- [7.6.1 链接器如何解析多重定义的全局符号](#761-链接器如何解析多重定义的全局符号)
		- [7.6.2 与静态库链接](#762-与静态库链接)
		- [7.6.3 链接器如何使用静态库来解析引用](#763-链接器如何使用静态库来解析引用)
	- [7.7 重定位](#77-重定位)
		- [7.7.1 重定位条目](#771-重定位条目)
	- [7.8 可执行目标文件](#78-可执行目标文件)
	- [7.9 加载可执行目标文件](#79-加载可执行目标文件)
	- [7.10 动态链接共享库](#710-动态链接共享库)
	- [7.11 从应用程序中加载和链接共享库](#711-从应用程序中加载和链接共享库)
	- [7.12 位置无关代码](#712-位置无关代码)
	- [7.13 库打桩机制](#713-库打桩机制)
		- [7.13.1 编译时打桩](#7131-编译时打桩)
		- [7.13.2 链接时打桩](#7132-链接时打桩)
		- [7.13.3 运行时打桩](#7133-运行时打桩)
	- [7.14 处理目标文件的工具](#714-处理目标文件的工具)
	- [7.15 小结](#715-小结)

# 链接

**链接**是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载(复制)到内存并执行。链接可以执行于编译时，也就是在源代码被翻译成机器代码时;也可以执行于加载时，也就是在程序被加载器加载到内存并执行时;甚至执行于运行时，也就是由应用程序来执行。在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器的程序自动执行的。

**链接器**在软件开发中扮演着一个关键的角色，因为它们使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。

## 7.1 编译器驱动程序

大多数编译系统提供**编译器驱动程序**，它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。比如，要用GNU编译系统构造由main.c和sum.c构成的程序,我们就要通过在shell中输入下列命令来调用GCC驱动程序:`linux> gcc -Og -o prog main.c sum.c`

驱动程序首先运行C预处理器(cpp)，它将C的源程序main.c翻译成一个ASCII码的中间文件main.i。接下来，驱动程序运行C编译器(ccl)，它将main.i翻译成一个ASCII汇编语言文件main.s。然后，驱动程序运行汇编器(as)，它将main.s翻译成一个可重定位目标文件main.o。驱动程序经过相同的过程生成sum.o。最后，它运行链接器程序ld，将main.o和sum.o以及一些必要的系统目标文件组合起来，创建一个可执行目标文件prog。

要运行可执行文件prog，我们在Linux shell的命令行上输入它的名字：`linux> ./prog`shell调用操作系统中一个叫做加载器的函数，它将可执行文件prog中的代码和数据复制到内存，然后将控制转移到这个程序的开头。

## 7.2 静态链接

像Linux LD程序这样的**静态链接器**以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节组成，每一节都是一个连续的字节序列。指令在一节中，初始化了的全局变量在另一节中，而未初始化的变量又在另外一节中。

为了构造可执行文件，链接器必须完成两个主要任务:

* 符号解析(symbol resolution)。目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量(即C语言中任何以static属性声明的变量)。符号解析的目的是将每个符号引用正好和一个符号定义关联起来

* 重定位(relocation)。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条目的详细指令，不加甄别地执行这样的重定位

关于链接器的一些**基本事实**:目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些包含程序数据，而其他的则包含引导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置,并且修改代码和数据块中的各种位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。

## 7.3 目标文件

目标文件有三种形式:

* 可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。

* 共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。

* 可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行。

编译器和汇编器生成可重定位目标文件(包括共享目标文件)。链接器生成可执行目标文件。从技术上来说，一个目标模块就是一个字节序列，而一个目标文件就是一个以文件形式存放在磁盘中的目标模块。不过，我们会互换地使用这些术语。

**目标文件**是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。从贝尔实验室诞生的第一个Unix系统使用的是a.out格式(直到今天，可执行文件仍然称为a.out文件)。Windows使用可移植可执行(PE)格式。MacOS-X使用Mach-O格式。现代x86-64 Linux和Unix系统使用可执行可链接格式(ELF)。尽管我们的讨论集中在ELF上，但是不管是哪种格式，基本的概念是相似的。

## 7.4 可重定位目标文件

|典型的ELF可重定位目标文件|
|:-:|
|ELF头|
|.text|
|.rodata|
|.data|
|.bss|
|.symtab|
|.rel.text|
|.rel.data|
|.debug|
|.line|
|.strtab|
|节头部表|

ELF头以一个16字节的序列开始,这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型(如可重定位、可执行或者共享的)、机器类型(如x86-64)、节头部表的文件偏移，以及节头部表中条目的大小和数量。

不同节的位置和大小是由节头部表描述的,其中目标文件中每个节都有一个固定大小的条目。夹在ELF头和节头部表之间的都是节。一个典型的ELF可重定位目标文件包含下面几个节:

**.text**:已编译程序的机器代码。

**.rodata**:只读数据,比如printf语句中的格式串和开关语句的跳转表。

**.data**:已初始化的全局和静态C变量。局部C变量在运行时被保存在栈中，既不出现在.data节中,也不出现在.bss节中。

**.bss**:未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率:在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为0。

**.symtab**:一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过-g选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表(除非程序员特意用STRIP命令去掉它)。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的条目。

**.rel.text**:一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。

**.rel.data**:被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。

**.debug**:一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。只有以-g选项调用编译器驱动程序时，才会得到这张表。

**.line**:原始C源程序中的行号和.text节中机器指令之间的映射。只有以-g选项调用编译器驱动程序时,才会得到这张表。

**.strtab**:一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串的序列。

## 7.5 符号和符号表

每个可重定位目标模块m都有一个符号表，它包含m定义和引用的符号的信息。在链接器的上下文中,有三种不同的符号:

* 由模块m定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的C函数和全局变量。

* 由其他模块定义并被模块m引用的全局符号。这些符号称为外部符号，对应于在其他模块中定义的非静态C函数和全局变量。

* 只被模块m定义和引用的局部符号。它们对应于带static属性的C函数和全局变量。这些符号在模块m中任何位置都可见，但是不能被其他模块引用。

认识到**本地链接器符号和本地程序变量**不同是很重要的。.symtab中的符号表不包含对应于本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理，链接器对此类符号不感兴趣。

有趣的是，定义为带有C static属性的本地过程变量是不在栈中管理的。相反，编译器在.data或.bss中为每个定义分配空间，并在符号表中创建一个有唯一名字的本地链接器符号。

## 7.6 符号解析

**链接器解析符号引用的方法**是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块中的局部符号的引用，符号解析是非常简单明了的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。

不过，对**全局符号的引用解析**就棘手得多。当编译器遇到一个不是在当前模块中定义的符号(变量或函数名)时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条(通常很难阅读的)错误信息并终止。

对全局符号的符号解析很棘手，还因为**多个目标文件可能会定义相同名字的全局符号**。在这种情况中，链接器必须要么标志一个错误，要么以某种方法选出一个定义并抛弃其他定义。Linux系统采纳的方法涉及编译器、汇编器和链接器之间的协作，这样也可能给不警觉的程序员带来一些麻烦。

C++和Java都允许**重载方法**，这些方法在源代码中有相同的名字，却有不同的参数列表。那么链接器是如何区别这些不同的重载函数之间的差异呢?C++和Java中能使用重载函数，是因为编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。这种编码过程叫做**重整**，而相反的过程叫做**恢复**。

幸运的是，C++和Java使用**兼容的重整策略**。一个被重整的类名字是由名字中字符的整数数量，后面跟原始名字组成的。比如，类Foo被编码成3Foo。方法被编码为原始方法名，后面加上_，加上被重整的类名，再加上每个参数的单字母编码。重整全局变量和模板名字的策略是相似的。

### 7.6.1 链接器如何解析多重定义的全局符号

链接器的输入是一组可重定位目标模块。每个模块定义一组符号，有些是局部的(只对定义该符号的模块可见)，有些是全局的(对其他模块也可见)。如果多个模块定义同名的全局符号，会发生什么呢?下面是Linux编译系统采用的方法。

在编译时,编译器向汇编器输出每个全局符号，或者是强或者是弱，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号,未初始化的全局变量是弱符号。

根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名:

* 规则1:不允许有多个同名的强符号。

* 规则2:如果有一个强符号和多个弱符号同名，那么选择强符号。

* 规则3:如果有多个弱符号同名，那么从这些弱符号中任意选择一个。

### 7.6.2 与静态库链接

迄今为止，我们都是假设链接器读取一组可重定位目标文件，并把它们链接起来，形成一个输出的可执行文件。实际上，所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为**静态库**，它可以用做链接器的输入。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。

**静态库概念**被提出来，相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以通过在命令行上指定单独的文件名字来使用这些在库中定义的函数。比如，使用C标准库和数学库中函数的程序可以用形式如下的命令行来编译和链接:`linux> gcc main.c /usr/lib/libm.a /usr/lib/libc.a`

**在链接时**，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内存中的大小。另一方面，应用程序员只需要包含较少的库文件的名字(实际上，C编译器驱动程序总是传送libc.a给链接器，所以前面提到的对libc.a的引用是不必要的)。

在Linux系统中，静态库以一种称为存档的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀.a标识。

### 7.6.3 链接器如何使用静态库来解析引用

虽然静态库很有用，但是它们同时也是一个程序员迷惑的源头，原因在于Linux链接器使用它们解析外部引用的方式。在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件(驱动程序自动将命令行中所有的.c文件翻译为.o文件)。在这次扫描中，链接器维护一个可重定位目标文件的集合E(这个集合中的文件会被合并起来形成可执行文件)，一个未解析的符号(即引用了但是尚未定义的符号)集合U，以及一个在前面输入文件中已定义的符号集合D。初始时，E、U和D均为空。

* 对于命令行上的每个输入文件f，链接器会判断f是一个目标文件还是一个存档文件。如果f是一个目标文件，那么链接器把f添加到E，修改U和D来反映f中的符号定义和引用，并继续下一个输入文件。

* 如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员m，定义了一个符号来解析U中的一个引用，那么就将m加到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中所有的成员目标文件都依次进行这个过程，直到U和D都不再发生变化。此时，任何不包含在E中的成员目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件。

* 如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就会输出一个错误并终止。否则，它会合并和重定位E中的目标文件，构建输出的可执行文件。

不幸的是，这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文件的顺序非常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接会失败。

**关于库的一般准则**是将它们放在命令行的结尾。如果各个库的成员是相互独立的(也就是说没有成员引用另一个成员定义的符号)，那么这些库就可以以任何顺序放置在命令行的结尾处。另一方面，如果库不是相互独立的，那么必须对它们排序，使得对于每个被存档文件的成员外部引用的符号s，在命令行中至少有一个s的定义是在对s的引用之后的。比如，假设foo.c调用libx.a和 libz.a中的函数，而这两个库又调用liby.a中的函数。那么，在命令行中 libx.a和 libz.a必须处在liby.a之前:`linux> gcc foo.c libx.a libz.a liby.a`

如果需要满足依赖需求，可以在命令行上重复库。比如，假设foo.c调用libx.a中的函数，该库又调用liby.a中的函数，而liby.a又调用libx.a中的函数。那么libx.a必须在命令行上重复出现:`linux> gcc foo.c libx.a liby.a libx.a`

## 7.7 重定位

一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义(即它的一个输入目标模块中的一个符号表条目)关联起来。此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始**重定位**步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。重定位由两步组成:

* 重定位节和符号定义。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输入模块的.data节被全部合并成一个节，这个节成为输出的可执行目标文件的.data节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。

* 重定位节中的符号引用。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目的数据结构，

### 7.7.1 重定位条目

当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中。已初始化数据的重定位条目放在.rel.data中。

## 7.8 可执行目标文件

我们已经看到链接器如何将多个目标文件合并成一个可执行目标文件。我们的示例C程序，开始时是一组ASCII文本文件，现在已经被转化为一个二进制文件，且这个二进制文件包含加载程序到内存并运行它所需的所有信息。

可执行目标文件的格式类似于可重定位目标文件的格式。ELF头描述文件的总体格式。它还包括程序的入口点，也就是当程序运行时要执行的第一条指令的地址。.text、.rodata和.data节与可重定位目标文件中的节是相似的，除了这些节已经被重定位到它们最终的运行时内存地址以外。.init节定义了一个小函数，叫做_init，程序的初始化代码会调用它。因为可执行文件是完全链接的(已被重定位)，所以它不再需要.rel 节。

ELF可执行文件被设计得很容易加载到内存，可执行文件的连续的片被映射到连续的内存段。程序头部表描述了这种映射关系。

## 7.9 加载可执行目标文件

要运行可执行目标文件prog，我们可以在Linux shell 的命令行中输入它的名字:`linux> ./prog`

因为prog不是一个内置的shell命令，所以shell 会认为prog是一个可执行目标文件，通过调用某个驻留在存储器中称为加载器的操作系统代码来运行它。任何Linux程序都可以通过调用execve函数来调用加载器，我们将在8.4.6节中详细描述这个函数。加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序复制到内存并运行的过程叫做加载。

每个Linux程序都有一个运行时内存映像，如下表所示。在Linux x86-64系统中，代码段总是从地址0x400000处开始，后面是数据段。运行时堆在数据段之后，通过调用malloc库往上增长(我们将在9.9节中详细描述malloc和堆)。堆后面的区域是为共享模块保留的。用户栈总是从最大的合法用户地址($2^{48}-1$)开始，向较小内存地址增长。栈上的区域，从地址$2^{48}$开始，是为内核中的代码和数据保留的，所谓内核就是操作系统驻留在内存的部分。

|Linux x86-64运行时内存映像|备注|
|:-:|:-:|
|内核内存|↑对用户代码不可见的内存|
||$2^{48}-1$|
|用户栈(运行时创建)↓||
||%rsp(栈指针)|
|共享库的内存映射区域↑||
||←brk|
|运行时堆(由malloc创建)↑|
||读/写段(.data，.bss)(数据段)|从可执行文件中加载|
|只读代码段(.init，.text，.rodata)|从可执行文件中加载|
||0x40 0000|
||0|

为了简洁，我们把堆、数据和代码段画得彼此相邻，并且把栈顶放在了最大的合法用户地址处。实际上，由于.data段有对齐要求(见7.8节)，所以代码段和数据段之间是有间隙的。同时，在分配栈、共享库和堆段运行时地址的时候，链接器还会使用地址空同布局随机化(ASLR，参见3.10.4节)。虽然每次程序运行时这些区域的地址都会改变，它们的相对位置是不变的。

当加载器运行时，它创建类似于上表所示的内存映像。在程序头部表的引导下，加载器将可执行文件的片复制到代码段和数据段。接下来加载器跳转到程序的入口点，也就是_start函数的地址。这个函数是在系统目标文件ctrl.o中定义的，对所有的C程序都是一样的。_start函数调用系统启动函数__libc_start_main，该函数定义在libc.so中。它初始化执行环境，调用用户层的main函数，处理main函数的返回值，并且在需要的时候把控制返回给内核。

## 7.10 动态链接共享库

**静态库有一些明显的缺点**。静态库和所有的软件一样，需要定期维护和更新。如果应用程序员想要使用一个库的最新版本，他们必须以某种方式了解到该库的更新情况,然后显式地将他们的程序与更新了的库重新链接。

另一个问题是几乎每个C程序都使用标准I/O函数，比如printf和scanf。在运行时，这些函数的代码会被复制到每个运行进程的文本段中。在一个运行上百个进程的典型系统上，这将是对稀缺的内存系统资源的极大浪费(内存的一个有趣属性就是不论系统的内存有多大，它总是一种稀缺资源。磁盘空间和厨房的垃圾桶同样有这种属性)。

**共享库**是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接，是由一个叫做动态链接器的程序来执行的。共享库也称为共享目标，在 Linux系统中通常用.so后缀来表示。微软的操作系统大量地使用了共享库，它们称为DLL(动态链接库)。

**共享库是以两种不同的方式来“共享”的**。首先，在任何给定的文件系统中，对于一个库只有一个.so文件。所有引用该库的可执行目标文件共享这个.so文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行的文件中。其次，在内存中，一个共享库的.text 节的一个副本可以被不同的正在运行的进程共享。在第9章我们学习虚拟内存时将更加详细地讨论这个问题。

**基本的思路**就是当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程。此时，没有共享库的代码和数据节被复制到可执行文件。反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对共享库中代码和数据的引用。

当加载器加载和运行可执行文件时，它加载部分链接的可执行文件。接着，它注意到可执行文件包含一个.interp节，这一节包含动态链接器的路径名，动态链接器本身就是一个共享目标(如在Linux系统上的ld-linux.so)。加载器不会像它通常所做地那样将控制传递给应用，而是加载和运行这个动态链接器。然后，动态链接器通过执行下面的重定位完成链接任务:

* 重定位libc.so的文本和数据到某个内存段。

* 重定位libvector.so的文本和数据到另一个内存段。

* 重定位可执行文件中所有对由libc.so和libvector.so定义的符号的引用。

## 7.11 从应用程序中加载和链接共享库

到目前为止，我们已经讨论了在应用程序被加载后执行前时，动态链接器加载和链接共享库的情景。然而，应用程序还可能在它运行时要求动态链接器加载和链接某个共享库，而无需在编译时将那些库链接到应用中。

动态链接是一项强大有用的技术，比如分发软件和构建高性能Web服务器。

Linux系统为动态链接器提供了一个简单的接口，允许应用程序在运行时加载和链接共享库。
```C
#include <dlfcn.h>

void *dlopen(const char *filename, int flag);
// dlopen函数加载和链接共享库filename
// 返回：若成功则为指向句柄的指针，若出错则为NULL

void *dlsym(void *handle, char *symbol);
// dlsym函数的输入是一个指向前面已经打开了的共享库的句柄和一个symbol名字，
// 如果该符号存在,就返回符号的地址，否则返回NULL
// 返回：若成功则为指向符号的指针，若出错则为NULL

int dlclose(void *handle);
// 如果没有其他共享库还在使用这个共享库，
// dlclose函数就卸载该共享库
// 返回：若成功则为0，若出错则为-1

const char *dlerror(void);
// dlerror函数返回一个字符串，它描述的是调用dlopen、
// dlsym或者dlclose函数时发生的最近的错误，如果没有错误发生，就返回NULL
// 返回：如果前面对dlopen、dlsym或者dlclose的调用失败，则为错误消息
// 若果前面的调用成功，则为NULL
```

Java定义了一个标准调用规则，叫做Java本地接口(JNI)，它允许Java程序调用“本地的”C和C++函数。JNI的基本思想是将本地C函数(如foo)编译到一个共享库中(如foo.so)。当一个正在运行的Java程序试图调用函数foo时，Java解释器利用dlopen接口(或者与其类似的接口)动态链接和加载foo.so,然后再调用foo。

## 7.12 位置无关代码

共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码，因而节约宝贵的内存资源。那么，**多个进程是如何共享程序的一个副本的呢**?一种方法是给每个共享库分配一个事先预备的专用的地址空间片，然后要求加载器总是在这个地址加载共享库。虽然这种方法很简单，但是它也造成了一些严重的问题。它对地址空间的使用效率不高，因为即使一个进程不使用这个库，那部分空间还是会被分配出来。它也难以管理。我们必须保证没有片会重叠。每次当一个库修改了之后，我们必须确认已分配给它的片还适合它的大小。如果不适合了，必须找一个新的片。并且，如果创建了一个新的库，我们还必须为它寻找空间。随着时间的进展，假设在一个系统中有了成百个库和库的各个版本库，就很难避免地址空间分裂成大量小的、未使用而又不再能使用的小洞。更糟的是，对每个系统而言，库在内存中的分配都是不同的，这就引起了更多令人头痛的管理问题。

要避免这些问题，现代系统以这样一种方式编译共享模块的代码段，使得可以把它们加载到内存的任何位置而无需链接器修改。使用这种方法，无限多个进程可以共享一个共享模块的代码段的单一副本(当然，每个进程仍然会有它自己的读/写数据块)。

可以加载而无需重定位的代码称为**位置无关代码(PIC)**,用户对GCC使用-fpic选项指示GNU编译系统生成PIC代码。共享库的编译必须总是使用该选项。

1. PIC数据引用

编译器通过运用以下这个有趣的事实来生成对全局变量的PIC引用:无论我们在内存中的何处加载一个目标模块(包括共享目标模块)，数据段与代码段的距离总是保持不变。因此，代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量，与代码段和数据段的绝对内存位置是无关的。

想要生成对全局变量PIC引用的编译器利用了这个事实，它在数据段开始的地方创建了一个表，叫做全局偏移量表(GOT)。在GOT中，每个被这个目标模块引用的全局数据目标(过程或全局变量)都有一个8字节条目。编译器还为GOT中每个条目生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得它包含目标的正确的绝对地址。每个引用全局目标的目标模块都有自己的GOT。

2. PIC函数调用

假设程序调用一个由共享库定义的函数。编译器没有办法预测这个函数的运行时地址,因为定义它的共享模块在运行时可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。不过，这种方法并不是PIC，因为它需要链接器修改调用模块的代码段，GNU编译系统使用了**延迟绑定**来解决这个问题，将过程地址的绑定推迟到第一次调用该过程时。

**使用延迟绑定的动机**是对于一个像libc.so这样的共享库输出的成百上千个函数中，一个典型的应用程序只会使用其中很少的一部分。把函数地址的解析推迟到它实际被调用的地方，能避免动态链接器在加载时进行成百上千个其实并不需要的重定位。第一次调用过程的运行时开销很大，但是其后的每次调用都只会花费一条指令和一个间接的内存引用。

**延迟绑定**是通过两个数据结构之间简洁但又有些复杂的交互来实现的，这两个数据结构是:全局偏移量表(GOT)和过程链接表(PLT)。如果一个目标模块调用定义在共享库中的任何函数，那么它就有自己的GOT和PLT。GOT是数据段的一部分，而PLT是代码段的一部分。

* 过程链接表(PLT)。PLT是一个数组，其中每个条目是16字节代码。PLT\[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。PLT\[1]调用系统启动函数(__libc_start_main)，它初始化执行环境，调用main函数并处理其返回值。从 PLT\[2]开始的条目调用用户代码调用的函数。在例子中，PLT\[2]调用addvec，PLT\[3]调用printf。

* 全局偏移量表(GOT)。GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT\[0]和 GOT\[1]包含动态链接器在解析函数地址时会使用的信息。GOT\[2]是动态链接器在ld-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。例如，GOT\[4]和PLT\[2]对应于addvec。初始时，每个GOT条目都指向对应PLT条目的第二条指令。

GOT和PLT的协同工作过程，在addvec被第一次调用时，**延迟解析它的运行时地址**：

* 第1步。不直接调用addvec，程序调用进入PLT\[2]，这是addvec的PLT条目。

* 第2步。第一条PLT指令通过GOT\[4]进行间接跳转。因为每个GOT条目初始时都指向它对应的PLT条目的第二条指令，这个间接跳转只是简单地把控制传送回PLT\[2]中的下一条指令。

* 第3步。在把addvec的ID(0x1)压入栈中之后，PLT\[2]跳转到PLT\[0]。

* 第4步。PLT\[0]通过GOT\[1]间接地把动态链接器的一个参数压入栈中，然后通过GOT\[2]间接跳转进动态链接器中。动态链接器使用两个栈条目来确定addvec的运行时位置，用这个地址重写GOT\[4]，再把控制传递给addvec。

后续再调用addvec时的控制流;

* 第1步。和前面一样，控制传递到PLT\[2]。

* 第2步。不过这次通过GOT\[4]的间接跳转会将控制直接转移到addvec。

## 7.13 库打桩机制

Linux链接器支持一个很强大的技术，称为**库打桩**，它允许你截获对共享库函数的调用，取而代之执行自己的代码。使用打桩机制，你可以追踪对某个特殊库函数的调用次数，验证和追踪它的输入和输出值，或者甚至把它替换成一个完全不同的实现。

下面是它的**基本思想**:给定一个需要打桩的目标函数，创建一个包装函数，它的原型与目标函数完全一样。使用某种特殊的打桩机制，你就可以欺骗系统调用包装函数而不是目标函数了。包装函数通常会执行它自己的逻辑，然后调用目标函数，再将目标函数的返回值传递给调用者。

打桩可以发生在编译时、链接时或当程序被加载和执行的运行时。

### 7.13.1 编译时打桩

Linux终端中使用-I参数

### 7.13.2 链接时打桩

Linux静态链接器支持用--wrap f标志进行链接时打桩。这个标志告诉链接器，把对符号f的引用解析成__wrap_f，还要把对符号__real_f的引用解析为f。

### 7.13.3 运行时打桩

编译时打桩需要能够访问程序的源代码，链接时打桩需要能够访问程序的可重定位对象文件。不过，有一种机制能够在运行时打桩，它只需要能够访问可执行目标文件。这个很厉害的机制基于动态链接器的LD_ PRELOAD环境变量。

如果 LD_PRELOAD环境变量被设置为一个共享库路径名的列表(以空格或分号分隔)，那么当你加载和执行一个程序，需要解析未定义的引用时，动态链接器(LD-LINUX.so)会先搜索LD PRELOAD库，然后才搜索任何其他的库。有了这个机制，当你加载和执行任意可执行文件时，可以对任何共享库中的任何函数打桩，包括libc.so。

## 7.14 处理目标文件的工具

在 Linux系统中有大量可用的工具可以帮助理解和处理目标文件。特别地，GNUbinutils包尤其有帮助，而且可以运行在每个Linux平台上。

* AR:创建静态库,插入、删除、列出和提取成员。

* STRINGS:列出一个目标文件中所有可打印的字符串。

* STRIP:从目标文件中删除符号表信息。

* NM:列出一个目标文件的符号表中定义的符号。

* SIZE:列出目标文件中节的名字和大小。

* READELF:显示一个目标文件的完整结构，包括ELF头中编码的所有信息。包含SIZE和NM的功能。

* OBJDUMP:所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编.text节中的二进制指令。

Linux系统为操作共享库还提供了LDD程序:LDD:列出一个可执行文件在运行时所需要的共享库。

## 7.15 小结

链接可以在编译时由静态编译器来完成，也可以在加载时和运行时由动态链接器来完成。链接器处理称为目标文件的二进制文件，它有3种不同的形式:可重定位的、可执行的和共享的。可重定位的目标文件由静态链接器合并成一个可执行的目标文件，它可以加载到内存中并执行。共享目标文件(共享库)是在运行时由动态链接器链接和加载的，或者隐含地在调用程序被加载和开始执行时，或者根据需要在程序调用dlopen库的函数时。

链接器的两个主要任务是符号解析和重定位，符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义，而重定位确定每个符号的最终内存地址，并修改对那些目标的引用。

静态链接器是由像GCC这样的编译驱动程序调用的。它们将多个可重定位目标文件合并成一个单独的可执行目标文件。多个目标文件可以定义相同的符号，而链接器用来悄悄地解析这些多重定义的规则可能在用户程序中引入微妙的错误。

多个目标文件可以被连接到一个单独的静态库中。链接器用库来解析其他目标模块中的符号引用。许多链接器通过从左到右的顺序扫描来解析符号引用，这是另一个引起令人迷惑的链接时错误的来源。

加载器将可执行文件的内容映射到内存，并运行这个程序。链接器还可能生成部分链接的可执行目标文件，这样的文件中有对定义在共享库中的例程和数据的未解析的引用。在加载时，加载器将部分链接的可执行文件映射到内存，然后调用动态链接器，它通过加载共享库和重定位程序中的引用来完成链接任务。

被编译为位置无关代码的共享库可以加载到任何地方，也可以在运行时被多个进程共享。为了加载、链接和访问共享库的函数和数据，应用程序也可以在运行时使用动态链接器。
