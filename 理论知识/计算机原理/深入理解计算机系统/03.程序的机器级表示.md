- [程序的机器级表示](#程序的机器级表示)
	- [3.2 程序编码](#32-程序编码)
		- [3.2.1 机器级代码](#321-机器级代码)
		- [3.2.2 代码示例](#322-代码示例)
		- [3.2.3 关于格式的注解](#323-关于格式的注解)
	- [3.3 数据格式](#33-数据格式)
	- [3.4 访问信息](#34-访问信息)
		- [3.4.1 操作数指示符](#341-操作数指示符)
		- [3.4.2 数据传送指令](#342-数据传送指令)
		- [3.4.4 压入和弹出栈数据](#344-压入和弹出栈数据)
	- [3.5 算数和逻辑操作](#35-算数和逻辑操作)
		- [3.5.1 加载有效地址](#351-加载有效地址)
		- [3.5.2 一元和二元操作数](#352-一元和二元操作数)
		- [3.5.3 移位操作](#353-移位操作)
		- [3.5.4 讨论](#354-讨论)
		- [3.5.5 特殊的算数操作](#355-特殊的算数操作)
	- [3.6 控制](#36-控制)
		- [3.6.1 条件码](#361-条件码)
		- [3.6.2 访问条件码](#362-访问条件码)
		- [3.6.3 跳转指令](#363-跳转指令)
		- [3.6.4 跳转指令的编码](#364-跳转指令的编码)
		- [3.6.5 用条件控制来实现条件分支](#365-用条件控制来实现条件分支)
		- [3.6.6 用条件传送来实现条件分支](#366-用条件传送来实现条件分支)
		- [3.6.7 循环](#367-循环)
		- [3.6.8 switch语句](#368-switch语句)
	- [3.7 过程](#37-过程)
		- [3.7.1 运行时栈](#371-运行时栈)
		- [3.7.2 转移控制](#372-转移控制)
		- [3.7.3 数据传送](#373-数据传送)
		- [3.7.4 栈上的局部存储](#374-栈上的局部存储)
		- [3.7.5 寄存器中的局部存储空间](#375-寄存器中的局部存储空间)
		- [3.7.6 递归过程](#376-递归过程)
	- [3.8 数组分配和访问](#38-数组分配和访问)
		- [3.8.1 基本原则](#381-基本原则)
		- [3.8.2 指针运算](#382-指针运算)
		- [3.8.3 嵌套的数组](#383-嵌套的数组)
		- [3.8.4 定长数组](#384-定长数组)
		- [3.8.5 变长数组](#385-变长数组)
	- [3.9 异质的数据结构](#39-异质的数据结构)
		- [3.9.1 结构](#391-结构)
		- [3.9.2 联合](#392-联合)
		- [3.9.3 数据对齐](#393-数据对齐)
	- [3.10 在机器级程序中将控制与数据结合起来](#310-在机器级程序中将控制与数据结合起来)
		- [3.10.1 理解指针](#3101-理解指针)
		- [3.10.2 应用：使用GDB调试器](#3102-应用使用gdb调试器)
		- [3.10.3 内存越界引用和缓冲区溢出](#3103-内存越界引用和缓冲区溢出)
		- [3.10.4 对抗缓冲区溢出攻击](#3104-对抗缓冲区溢出攻击)
		- [3.10.5 支持变长栈帧](#3105-支持变长栈帧)
	- [3.11 浮点代码](#311-浮点代码)
		- [3.11.1 浮点传送和转换操作](#3111-浮点传送和转换操作)
		- [3.11.2 过程中的浮点代码](#3112-过程中的浮点代码)
		- [3.11.3 浮点运算操作](#3113-浮点运算操作)
		- [定义和使用浮点常数](#定义和使用浮点常数)
		- [3.11.5 在浮点代码中使用位级操作](#3115-在浮点代码中使用位级操作)
		- [3.11.6 浮点比较操作](#3116-浮点比较操作)
		- [3.11.7 对浮点代码的观察结论](#3117-对浮点代码的观察结论)
	- [3.12 小结](#312-小结)

# 程序的机器级表示

## 3.2 程序编码

**用Unix命令行编译代码**p1.c和p2.c:`gcc -0g -o p p1.c p2.c`，编译选项-0g指定编译器使用会生成符合原始C代码整体结构的机器代码的优化等级。使用较高级别优化(如-01或-02)产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解。

gcc命令调用了一整套的程序，**将源代码转化成可执行代码**。首先，C预处理器扩展源代码，插入所有用#include命令指定的文件，并扩展所有用#define声明指定的宏。其次，编译器产生两个源文件的汇编代码，名字分别为p1.s和p2.s。接下来，汇编器会将汇编代码转化成二进制目标代码文件p1.o和p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。最后，链接器将两个目标代码文件与实现库函数(例如printf)的代码合并，并产生最终的可执行代码文件p(由命令行指示符-o p指定的)。可执行代码是我们要考虑的机器代码的第二种形式，也就是处理器执行的代码格式。我们会在第7章更详细地介绍这些不同形式的机器代码之间的关系以及链接的过程。

### 3.2.1 机器级代码

机器级编程中重要的抽象：

* 指令集体系结构或指令集架构(ISA)：定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数ISA(包括x86-64)将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行的行为完全一致。

* 机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。

处理器状态：

* 程序计数器(通常称为"PC"，在x86-64中用%rip表示)给出将要执行的下一条指令在内存中的地址。

* 整数寄存器文件包含16个命名的位置,分别存储64位的值。这些寄存器可以存储地址(对应于C语言的指针)或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。

* 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现if和while语句。

* 一组向量寄存器可以存放一个或多个整数或浮点数值。

程序内存包含:程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块(比如说用malloc库函数分配的)。

程序内存用**虚拟地址**来寻址。在任意给定的时刻，只有有限的一部分虚拟地址被认为是合法的。例如，x86-64的虚拟地址是由64位的字来表示的。在目前的实现中，这些地址的高16位必须设置为0，所以一个地址实际上能够指定的是$2^{48}$或64TB范围内的一个字节。操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。

### 3.2.2 代码示例

关于机器代码和它的反汇编表示的特性：

* x86-64的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。

* 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。

* 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。

* 反汇编器使用的指令命名规则与GCC生成的汇编代码使用的有些细微的差别。在示例中，它省略了很多指令结尾的‘q'。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给call和ret指令添加了‘q'后缀，同样，省略这些后缀也没有问题。

### 3.2.3 关于格式的注解

所有以'.'开头的行都是指导汇编器和链接器工作的伪指令。我们通常可以忽略这些行。

## 3.3 数据格式

由于是从16位体系结构扩展成32位的，Intel用术语"字(word)"表示16位数据类型。称32位数为"双字(double words)"，称64位数为"四字(quad words)"。

C语言基本数据类型对应的x86-64表示中，标准int值存储为双字(32位)。指针(在此用char*表示)存储为8字节的四字，64位机器本来就预期如此。x86-64中，数据类型long实现为64位，允许表示的值范围较大。

|C声明|Intel数据类型|汇编代码后缀|大小(字节)|
|:-:|:-:|:-:|:-:|
|char|字节|b|1|
|short|字|w|2|
|int|双字|l|4|
|long|四字|q|8|
|char*|四字|q|8|
|float|单精度|s|4|
|double|双精度|l|8|

后缀'l'用来表示双字，因为32位数被看成是"长字(long word)"。注意，汇编代码也使用后缀'l'来表示4字节整数和8字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。

## 3.4 访问信息

一个x86-64的中央处理单元(CPU)包含一组16个存储64位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。指令可以对这16个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节，16位操作可以访问最低的2个字节，32位操作可以访问最低的4个字节，而64位操作可以访问整个寄存器。当指令以寄存器作为目标时，对于生成小于8字节结果的指令，寄存器中剩下的字节会怎么样，对此有两条规则:生成1字节和2字节数字的指令会保持剩下的字节不变;生成4字节数字的指令会把高位4个字节置为0。

|寄存器名称(64位)|寄存器用途|32位寄存器名称|16位寄存器名称|8位寄存器名称|
|:-:|:-:|:-:|:-:|:-:|
|%rax|返回值|%eax|%ax|%al|
|%rbx|被调用者保存|%ebx|%bx|%bl|
|%rcx|第4个参数|%ecx|%cx|%cl|
|%rdx|第3个参数|%edx|%dx|%dl|
|%rsi|第2个参数|%esi|%si|%sil|
|%rdi|第1个参数|%edi|%di|%dil|
|%rbp|被调用者保存|%ebp|%bp|%bpl|
|%rsp|栈指针 用来指明运行时栈的结束位置|%esp|%sp|%spl|
|%r8|第5个参数|%r8d|%r8w|%r8b|
|%r9|第6个参数|%r9d|%r9w|%r9b|
|%r10|调用者保存|%r10d|%r10w|%r10b|
|%r11|调用者保存|%r11d|%r11w|%r11b|
|%r12|被调用者保存|%r12d|%r12w|%r12b|
|%r13|被调用者保存|%r13d|%r1w|%r13b|
|%r14|被调用者保存|%r14d|%r14w|%r14b|
|%r15|被调用者保存|%r15d|%r15w|%r15b|

### 3.4.1 操作数指示符

操作数格式：
|类型|格式|操作数值|名称|
|:-:|:-:|:-:|:-:|
|立即数|$Imm|Imm|立即数寻址|
|寄存器|$r_a$|R[$r_a$\]|寄存器寻址|
|存储器|Imm|M[Imm\]|绝对寻址|
|存储器|($r_a$)|M[R[$r_a$\]\]|间接寻址|
|存储器|Imm($r_b$)|M[Imm+R[$r_b$\]|(基址+偏移量)寻址|
|存储器|($r_b$,$r_i$)|M[R[$r_b$\]+R[$r_i$]\]|变址寻址|
|存储器|Imm($r_b$,$r_i$)|M[Imm+R[$r_b$\]+R[$r_i$]\]|变址寻址|
|存储器|(,$r_i$,s)|M[R[$r_i$\]*s\]|比例变址寻址|
|存储器|Imm(,$r_i$,s)|M[Imm+R[$r_i$\]*s\]|比例变址寻址|
|存储器|($r_b$,$r_i$,s)|M[R[$r_b$\]+R[$r_i$\]*s\]|比例变址寻址|
|存储器|Imm($r_b$,$r_i$,s)|M[Imm+R[$r_b$\]+R[$r_i$\]*s\]|比例变址寻址|

* Imm为标准C表示法表示的整数

* $r_a$表示任意寄存器，R[$r_a$\]表示寄存器的值

* 用$M_b$[Addr\]表示对存储在内存中从Addr开始的b个字节值的引用。为了简便，通常省去下标b

* 上表Imm($r_b$,$r_i$,s)中，基址寄存器$r_b$和变址寄存器$r_i$都必须是64位寄存器，比例因子s必须是1、2、4或者8。

### 3.4.2 数据传送指令

1. 简单的数据传输指令：

|指令|效果|描述|
|:-:|:-:|:-:|
|MOV S, D|S → D|传送|
|movb||传送字节|
|movw||传送字|
|movl||传送双字|
|movq||传送四字|
|movabsq I, R|I → R|传送绝对的四字|

源操作数S指定的值是一个立即数或者存储在寄存器中或者内存中。目的操作数D指定一个位置，一个寄存器地址或者一个内存地址。

x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令：第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。

这些指令的寄存器操作数可以是16个寄存器有标号部分中的任意一个，寄存器部分的大小必须与指令最后一个字符('b'，'w'，'l'或'q')指定的大小匹配。

大多数情况中，MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0。造成这个例外的原因是x86-64采用的惯例，即任何为寄存器生成32位值的指令都会把该寄存器的高位部分置成0。

常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展得到64位的值，放到目的位置。movabsq指令能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。

2. 以下两类数据移动指令，在将较小的源值复制到较大的目的时使用。

所有这些指令都把数据从源(在寄存器或内存中)复制到目的寄存器。MOVZ类中的指令把目的中剩余的字节填充为0，而MOVS类中的指令通过符号扩展来填充，把源操作的最高位进行复制。可以观察到，每条指令名字的最后两个字符都是大小指示符:第一个字符指定源的大小，而第二个指明目的的大小。这两个类中每个都有三条指令，包括了所有的源大小为1个和2个字节、目的大小为2个和4个的情况，当然只考虑目的大于源的情况。

* 零扩展数据传送指令(以寄存器或内存地址作为源，以寄存器作为目的)

|指令|效果|描述|
|:-:|:-:|:-:|
|MOVZ S, R|零扩展(S) → R|以零扩展进行传送|
|movzbw||将做了零扩展的 字节 传送到 字|
|movzbl||将做了零扩展的 字节 传送到 双字|
|movzwl||将做了零扩展的 字 传送到 双字|
|movzbq||将做了零扩展的 字节 传送到 四字|
|movzwq||将做了零扩展的 字 传送到 字节|

* 符号扩展数据传送指令(MOVS指令以寄存器或内存地址作为源，以寄存器作为目的)cltq指令只作用于寄存器%eax和%rax

|指令|效果|描述|
|:-:|:-:|:-:|
|MOVS S, R|符号扩展(S) → R|传送符号扩展的字节|
|movsbw||将做了符号扩展的 字节 传送到 字|
|movsbl||将做了符号扩展的 字节 传送到 双字|
|movswl||将做了符号扩展的 字 传送到 双字|
|movsbq||将做了符号扩展的 字节 传送到 四字|
|movswq||将做了符号扩展的 字 传送到 四字|
|movslq||将做了符号扩展的 双字 传送到 四字|
|cltq|符号扩展(%eax) → %rax|将%eax符号扩展到%rax|

cltq指令没有操作数：总是以寄存器%eax作为源，%rax作为符号扩展结果的目的。它的效果与指令movslq %eax, %rax完全一致，不过编码更紧凑。

当执行强制类型转换既涉及大小变换又涉及C语言中符号变化时，操作应该先改变大小。

### 3.4.4 压入和弹出栈数据

在x86-64中，程序栈存放在内存中某个区域。栈向下增长，栈顶元素的地址是所有栈中元素地址中最低的。栈指针%rsp保存着栈顶元素的地址。

|指令|效果|描述|
|:-:|:-:|:-:|
|pushq S|R[%rsp\]-8 → R[%rsp\] ； S → M[R[%rsp\]\]|将四字压入栈|
|popq D|M[R[%rsp\]\] → D ； R[%rsp\]+8 → R[%rsp\]|将四字弹出栈|

pushq %rbp <==> sub $8, %rsp 和 movq %rbp, (%rsp)

popq %rax <==> movq (%rsp), %rax 和 addq $8, %rsp

## 3.5 算数和逻辑操作

x86-64的大多数操作都分成了指令类，这些指令类有各种带不同大小操作数的变种(只有leaq没有其他大小的变种)。例如，指令类ADD由四条加法指令组成: addb、addw、addl和 addq,分别是字节加法、字加法、双字加法和四字加法。事实上，给出的每个指令类都有对这四种不同大小数据的指令。

|指令|效果|描述|
|:-:|:-:|:-:|
|加载有效地址|||
|leaq S, D|&S → D|加载有效地址|
|一元操作|||
|INC D|D+1 → D|加1|
|DEC D|D-1 → D|减1|
|NEG D|-D → D|取负|
|NOT D|~D → D|取补|
|二元操作|||
|ADD S, D|D+S → D|加|
|SUB S, D|D-S → D|减|
|IMUL S, D|D*S → D|乘|
|XOR S, D|D^S → D|异或|
|OR S, D|D\|S → D|或|
|AND S, D|D&S → D|与|
|移位操作|||
|SAL k, D|D<<k → D|左移|
|SHL k, D|D<<k → D|左移(等同于SAL)|
|SAR k, D|D>>$_A$k → D|算数右移(填上符号位)|
|SHR k, D|D>>$_L$k → D|逻辑右移(填上0)|

### 3.5.1 加载有效地址

加载有效地址指令leaq实际上是movq指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。

这条指令可以为后面的内存引用产生指针。另外，它还可以简洁地描述普通的算术操作。leaq例如，如果寄存器%rdx的值为x，那么指令leaq 7(%rdx, %rdx, 4)，%rax将设置寄存器%rax的值为5x+7。目的操作数必须是一个寄存器。

### 3.5.2 一元和二元操作数

一元操作的操作数可以是一个寄存器也可以是一个内存位置。

二元操作的第一个操作数可以是立即数、寄存器或内存位置。第二个操作数可以是寄存器或内存位置。

### 3.5.3 移位操作

移位操作第一个操作数是一移位量，可以是一个立即数或者放在单字节寄存器%cl中(移位指令只允许以这个特定的寄存器作为操作数)。第二个操作数是目的操作数，可以是一个寄存器或是一个内存位置。

x86-64中，移位操作对w位长的数据值进行操作，移位量是由%cl寄存器低m位决定的，这里$2^m=w$，高位会被忽略。所以,例如当寄存器%cl的十六进制值为0xFF时，指令salb会移7位，salw会移15位，sall会移31位,而salg会移63位。

### 3.5.4 讨论

大多数指令，既可以用于无符号运算，也可以用于补码运算。只有右移操作要求区分有符号和无符号数。这个特性使得补码运算成为实现有符号整数运算的一种比较好的方法的原因之一。

将寄存器%rdx设置为0的各种代码需要的字节数
* 设置全部字节：
  * movq $0, %rdx：需要7个字节
  * xorq %rdx, %rdx：需要3个字节
* 更新低4字节(指令会把高位字节设置为0)：
  * movl $0, %edx：需要5个字节
  * xorl %edx, %edx：需要2个字节

### 3.5.5 特殊的算数操作

两个64位有符号或无符号整数相乘得到的乘积需要128位来表示。x86-64指令集对128位(16字节)数的操作提供有限的支持。延续字(2字节)、双字(4字节)和四字(8字节)的命名惯例，Intel把16字节的数称为八字(oct word)。

以下是支持产生两个64位数字的全128位乘积以及整数除法的指令。

|指令|效果|描述|
|:-:|:-:|:-:|
|乘法|||
|imulq S|S*R[%rax\] → R[%rdx\]:R[%rax\]|有符号全乘法|
|mulq S|S*R[%rax\] → R[%rdx\]:R[%rax\]|无符号全乘法|
|转换|||
|clto|符号扩展(R[%rax\]) → R[%rdx\]:R[%rax\]|转换为八字|
|除法|||
|idivq S|R[%rdx\]:R[%rax\] mod S → R[%rdx\]|有符号除法|
|...|R[%rdx\]:R[%rax\] / S → R[%rax\]||
|divq S|R[%rdx\]:R[%rax\] mod S → R[%rdx\]|无符号除法|
|...|R[%rdx\]:R[%rax\] / S → R[%rax\]||

**乘法imulq指令有两种不同的形式**：其中一种，是IMUL指令类中的一种。这种形式的imulq指令是一个"双操作数"乘法指令。它从两个64位操作数产生一个64位乘积，实现了第二章中描述的操作乘法操作(当将乘积截取到64位时，无符号乘和补码乘的位级行为是一样的)。

此外，x86-64指令集还提供了两条不同的**“单操作数”乘法指令**，以计算两个64位值的全128位乘积—。一个是无符号数乘法(mulq)，而另一个是补码乘法(imulq)。这两条指令都要求一个参数必须在寄存器%rax中，而另一个作为指令的源操作数给出。然后乘积存放在寄存器%rdx(高64位)和%rax(低64位)中。

虽然imulq这个名字可以用于两个不同的乘法操作，但是汇编器能够通过计算操作数的数目，分辨出想用哪条指令。

转换指令cqto读出%rax的符号位，并将它复制到%rdx的所有位。

**有符号除法指令idivq**：将寄存器&rdx(高64位)和%rax(低64位)中的128位数作为被除数，而除数作为指令的操作数给出。指令将余数存储在寄存器%rdx中，将商存储在寄存器%rax中。

对于大多数64位除法应用来说，除数也常常是一个64位的值。这个值应该存放在%rax中，%rdx的位应该设置为全0(无符号运算)或者8rax的符号位(有符号运算)。后面这个操作可以用指令cqto来完成。

无符号除法divq指令中，通常寄存器%rdx会事先设置为0。

## 3.6 控制

### 3.6.1 条件码

条件码寄存器：描述了最近的算数或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。
* CF:进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。
* ZF:零标志。最近的操作得出的结果为0。
* SF:符号标志。最近的操作得到的结果为负数。
* 0F:溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出。

leaq指令不改变任何条件码，因为它是用来进行地址计算的。除此之外所有整数算数操作的所有指令都会设置条件码。对于逻辑操作，进位标志CF和溢出标志0F会这设置成0。对于移位操作，进位标志CF将设置为最后一个被移出的位，而溢出标志0F设置为0。INC(加1)和DEC(减1)指令会设置溢出标志0F和零标志ZF，
但不会改变进位标志CF。

比较和测试指令(不修改任何寄存器的值，只设置条件码)
|指令|基于|描述|
|:-:|:-:|:-:|
|CMP S1, S2|S2 - S1|比较|
|cmpb||比较字节|
|cmpw||比较字|
|cmpl||比较双字|
|cmpq||比较四字|
|TEST  S1, S2|S1 & S2|测试|
|testb||测试字节|
|testw||测试字|
|testl||测试双字|
|testq||测试四字|

CMP指令根据两个操作数之差来设置条件码。除了只设置条件码而不更新目的寄存器之外，CMP指令与SUB指令的行为是样的。如果两个操作数相等，指令会将零标志ZF设置为1，而其他的标志可以用来确定两个操作数之间的大小关系。

TEST指令的行为与AND指令一样，除了它们只设置条件码而不改变目的寄存器的值。

### 3.6.2 访问条件码

条件码通常不会直接读取，常用的使用方法有三种:
1. 可以根据条件码的某种组合，将一个字节设置为0或者1
2. 可以条件跳转到程序的某个其他的部分
3. 可以有条件地传送数据。

对于第一种情况，将这一整类指令称为SET指令；它们之间的区别就在于它们考虑的条件码的组合是什么，这些指令名字的不同后缀指明了它们所考虑的条件码的组合，表示不同的条件而不是操作数大小。

|指令|同义名|效果|设置条件|
|:-:|:-:|:-:|:-:|
|||||
|sete D|setz|ZF → D|相等/零|
|setne D|setnz|~ZF → D|不等/非零|
|||||
|sets D||SF → D|负数|
|setns D||~SF → D|非负数|
|||||
|setg D|setnle|~(SF ^ OF) & ~ZF → D|有符号>|
|setge D|setnl|~(SF ^ OF) → D|有符号>=|
|setl D|setnge|SF ^ OF → D|有符号<|
|setle D|setng|(SF ^ OF) \| ZF → D|有符号<=|
|||||
|seta D|setnbe|~CF & ~ZF → D|无符号>|
|setae D|setnb|~CF → D|无符号>=|
|setb D|setnae|CF → D|无符号<|
|setbe D|setna|CF \| ZF → D|无符号<=|

一条SET指令的目的操作数是低位单字节寄存器(3.4表所列)元素之一，或是一个字节的内存位置，指令会将这个字节设置成0或者1。为了得到一个32位或64位结果，我们必须对高位清零。

虽然所有的算术和逻辑操作都会设置条件码，但是各个SET命令的描述都适用的情况是：执行比较指令，根据计算t=a-b设置条件码。更具体地说，假设a、b和t分别是变量a、b和t的补码形式表示的整数，因此$t=a-^t_wb$,这里w取决于a和b的大小。

对于有符号比较的测试：setl，即“当小于时设置(set when less)” 指令，测试一个有符号比较。

当没有发生溢出时(OF设置为0就表明无溢出)，我们有当$a-^t_wb<0$时$a<b$，将SF设置为1即指明这一点；而当$a-^t_wb \geqslant 0$时$a \geqslant b$,由SF设置为0指明。

另一方面，当发生溢出时，我们有当$a-^t_wb>0$(负溢出)时$a<b$,而当$a-^t_wb<0$(正溢出)时$a>b$。当a=b时，不会有溢出。因此，当OF被设置为1时，当且仅当SF被设置为0，有$a<b$。将这些情况组合起来，溢出和符号位的异或提供了$a<b$是否为真的测试。其他的有符号比较测试基于SF^OF和ZF的其他组合。

对于无符号比较的测试，现在设a和b是变量a和b的无符号形式表示的整数。在执行计算t=a-b中，当a-b<0时，CMP指令会设置进位标志，因而无符号比较使用的是进位标志和零标志的组合。

### 3.6.3 跳转指令

正常执行的情况下，指令按照它们出现的顺序一条-条地执行。跳转(jump)指令会导致执行切换到程序中一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个标号(label)指明。

|指令|同义名|跳转条件|描述|
|:-:|:-:|:-:|:-:|
|jmp Label||1|直接跳转|
|jmp *Operand||1|间接跳转|
|||||
|je Label|jz|ZF|相等/零|
|jne Label|jnz|~ZF|不等/非零|
|||||
|js Label||SF|负数|
|jns Label||~SF|非负数|
|||||
|jg Label|jnle|~(SF ^ OF) & ~ZF|有符号>|
|jge Label|jnl|~(SF ^ OF)|有符号>=|
|jl Label|jnge|SF ^ OF|有符号<|
|jle Label|jng|(SF ^ OF) \| ZF|有符号<=|
|||||
|ja Label|jnbe|~CF & ~ZF|无符号>|
|jae Label|jnb|~CF|无符号>=|
|jb Label|jnae|CF|无符号<|
|jbe Label|jna|CF \| ZF|无符号<=|

jmp指令是无条件跳转。它可以是直接跳转，即跳转目标是作为指令的一部分编码的；也可以是间接跳转，即跳转目标是从寄存器或内存位置中读出的。汇编语言中，直接跳转是给出一个标号作为跳转目标的。间接跳转的写法是'*'后面跟一个操作数指示符。

表中所示的其他跳转指令都是有条件的，它们根据条件码的某种组合，或者跳转，或者继续执行代码序列中下一条指令。这些指令的名字和跳转条件与SET指令的名字和设置条件是相匹配的。同SET指令一样，一些底层的机器指令有多个名字。条件跳转只能是直接跳转。

### 3.6.4 跳转指令的编码

在汇编代码中，跳转目标用符号标号书写。汇编器，以及后来的链接器，会产生跳转目标的适当编码。跳转指令有几种不同的编码，但是最常用都是PC相对的(PC-relative)。也就是，它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这些地址偏移量可以编码为1、2或4个字节。第二种编码方法是给出“绝对”地址，用4个字节直接指定目标。汇编器和链接器会选择适当的跳转目的编码。

### 3.6.5 用条件控制来实现条件分支

C语言中的if-else语句的通用模板形式如下:
```C
if (test-expr)
  then-statement
else
  else-tatement
```
对于这种通用形式,汇编实现如下
(用C语法来描述控制流)
```C
    t = test-expr;
    if (!t)
        goto false;
    then-statement
    goto done;
false:
    else-statement
done:
```

### 3.6.6 用条件传送来实现条件分支

用条件控制来实现条件分支在现代处理器上可能会非常低效。一种替代的策略是使用数据的条件转移。这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。只有在一些受限制的情况中，这种策略才可行，但是如果可行，就可以用一条简单的条件传送指令来实现它，条件传送指令更符合现代处理器的性能特性。

条件传送指令：

|指令|同义名|跳转条件|描述|
|:-:|:-:|:-:|:-:|
|cmove S, R|cmovz|ZF|相等/零|
|cmovne S, R|cmovnz|~ZF|不等/非零|
|||||
|cmovs S, R||SF|负数|
|cmovns S, R||~SF|非负数|
|||||
|cmovg S, R|cmovnle|~(SF ^ OF) & ~ZF|有符号>|
|cmovge S, R|cmovnl|~(SF ^ OF)|有符号>=|
|cmovl S, R|cmovnge|SF ^ OF|有符号<|
|cmovle S, R|cmovng|(SF ^ OF) \| ZF|有符号<=|
|||||
|cmova S, R|cmovnbe|~CF & ~ZF|无符号>|
|cmovae S, R|cmovnb|~CF|无符号>=|
|cmovb S, R|cmovnae|CF|无符号<|
|cmovbe S, R|cmovna|CF \| ZF|无符号<=|

每条指令都有两个操作数：源寄存器或者内存地址S，和目的寄存器R。与SET和跳转指令一样，这些指令的结果取决于条件码的值。源值可以从内存或者源寄存器中读取，但是只有在制定的条件满足时，才会被复制到目的寄存器中。

源和目的的值可以是16位、32位或64位长。不支持单字节的条件传送。无条件指令的操作数的长度显式地编码在指令名中(例如movw和movl)，汇编器可以从目标寄存器的名字推断出条件传送指令的操作数长度，所以对所有的操作数长度，都可以使用同一个的指令名字。

C语言中条件表达式和赋值的通用形式：
`v = test-expr ? then-expr : else-expr;`

用条件控制转移的标准方法来编译这个表达式：

```C
    if (!test-expr)
        goto false
    v = tnen-expr;
    goto down;
false:
    v = else-expr;
done:
```

用条件数据传送的标准方法来编译这个表达式：

```C
v = then-expr;
ve = else-expr;
t = test-expr;
if(!t)
    v = ve;
```

### 3.6.7 循环

1. do-while循环

do-while循环的通用形式如下：

```C
do
    body-statement
    while (test-expr);
```

body-statement至少会执行一次

翻译成条件和goto语句：

```C
loop:
    body-statement
    t = test-expr;
    if (t)
        goto loop;
```

2. while循环

while循环的通用形式如下：

```C
while (test-expr);
    body-statement
```

翻译成条件和goto语句：

```C
// jump to middle方法
    goto test;
loop:
    body-statement
test:
    t = test-expr;
    if (t)
        goto loop;

// guarded-do方法
// 实现利用条件分支将代码变换为do-while循环
t = test-expr;
if (!t)
    goto done;
loop:
    body-statement
    t = test-expr;
    if (t)
          goto loop;
done:
```

3. for循环

for循环的通用形式如下：

```C
for (init-expr; test-expr; update-expr)
    body-statement
```

翻译成条件和goto语句：

```C
// jump to middle方法
    init-expr;
    goto test;
loop:
    body-statement
    update-expr;
test:
    t = test-expr;
    if (t)
        goto loop;

// guarded-do方法
// 实现利用条件分支将代码变换为do-while循环
init-expr;
t = test-expr;
if (!t)
    goto done;
loop:
    body-statement
    update-expr;
    t = test-expr;
    if (t)
          goto loop;
done:
```

### 3.6.8 switch语句

switch(开关)语句可以根据一个整数索引值进行多重分支。在处理具有多种可能结果的测试时，这种语句特别有用。它们不仅提高了C代码的可读性，而且通过使用跳转表这种数据结构使得实现更加高效。

**跳转表**是一个数组，表项i是一个代码段的地址，这个代码段实现当开关索引值等于i时程序应该采取的动作。程序代码用开关索引值来执行一个跳转表内的数组引用，确定跳转指令的目标。

和使用一组很长的if-else语句相比，**使用跳转表的优点**是执行开关语句的时间与开关情况的数量无关。GCC根据开关情况的数量和开关情况值的稀疏程度来翻译开关语句。当开关情况数量比较多(例如4个以上)，并且值的范围跨度比较小时，就会使用跳转表。

switch的示例形式如下：

```C
switch(n) {
    case 100:
        val *=13;
        break;
    case 102:
        val += 10;
    case 103:
        val += 11;
        break
    case 104:
    case 106:
        val *= val;
        break;
    default:
        val = 0;
}
*dest = val;
```

翻译成条件和goto语句：

```C
static void *jt[7] = {
    &&loc_A,  // case 100
    &&loc_def,// case 101
    &&loc_B,  // case 102
    &&loc_C,  // case 103
    &&loc_D,  // case 104
    &&loc_def,// case 105
    &&loc_D,  // case 106
}
unsigned long index = n - 100;
long val;

if (index > 6)  // default
    goto loc_def;
goto *jt[index]

loc_A:
    val = x * 13;
    goto done;
loc_B:
    x = x + 10;
loc_C:
    val = x + 11;
    goto done;
loc_D:
    val = x * x;
    got done;
loc_def:
    val = 0;
done:
    *dest = val;
```

汇编语言中对跳转表的声明：

```x86asm
    .section    .rodata
    .align   8    ;Align的地址是8的倍数
.L4:
    .quad   .L3  ;case 100: loc_A
    .quad   .L8  ;case 101: loc_def
    .quad   .L5  ;case 102: loc_B
    .quad   .L6  ;case 103: loc_C
    .quad   .L7  ;case 104: loc_D
    .quad   .L8  ;case 105: loc_def
    .quad   .L7  ;case 106: loc_D
```

这些声明表明，在叫做".rodata"(只读数据)的目标代码文件的段中，应该有一组7个"四"字(8个字节)，每个字的值都是与指定的汇编代码标号(例如.L3)相关联的指令地址。标号.L4标记出这个分配地址的起始。与这个标号相对应的地址会作为间接跳转的基地址。

## 3.7 过程

过程是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。然后，可以在程序中不同的地方调用这个函数。不同编程语言中，过程的形式多样：函数(function)、方法(method)、子历程(subroutine)、处理函数(handler)等。

要提供对过程的机器级支持，必须要处理许多不同的属性。为了讨论方便，假设过程P调用过程Q，Q执行后返回到P。这些动作包括下面一个或多个机制：
* 传递控制。在进入过程Q的时候，程序计数器必须被设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。
* 传递数据。P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值。
* 分配和释放内存。在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。

### 3.7.1 运行时栈

C语言过程调用机制的一个关键特性(大多数其他语言也是如此)在于使用了**栈数据结构提供的后进先出的内存管理原则**。在过程P调用过程Q的例子中，可以看到当Q在执行时，P以及所有在向上追溯到P的调用链中的过程，都是暂时被挂起的。当Q运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。另一方面，当Q返回时，任何它所分配的局部存储空间都可以被释放。因此，程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。当P调用Q时，控制和数据信息添加到栈尾。当P返回时，这些信息会释放掉。

当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个过程称为**过程的栈帧(stack fram)**。当前正在执行的过程的帧总是在栈顶。当过程P调用过程Q时，会把返回地址压入栈中，指明当Q返回时，要从P程序的哪个位置继续执行。我们把这个返回地址当做P的栈帧的一部分，因为它存放的是与P相关的状态。Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。大多数过程的栈帧都是定长的，在过程的开始就分配好了。但是有些过程需要变长的栈帧。通过寄存器，过程P可以传递最多6个整数值(也就是指针和整数)，但是如果Q需要更多的参数，P可以在调用Q之前在自己的栈帧里存储好这些参数。

为了提高空间和时间效率，x86-64过程值分配自己所需要的栈帧部分。例如，许多过程有6个或者更少的参数，那么所有的参数都可以通过寄存器传递。实际上，许多函数甚至根本不需要栈帧。当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数(有时称之为叶子过程，此时把过程调用看做树结构)时，就可以这样处理。

### 3.7.2 转移控制

将控制从函数P转移到函数Q只需要简单地把程序计数器(PC)设置为Q的代码的起始位置。不过当稍后从Q返回的时候，处理器必须记录好它需要继续P的执行的代码位置。在x86-64机器中，这个信息是用指令call Q调用过程Q来记录的。该指令会把地址A压入栈中，并将PC设置为Q的起始位置。压入的地址A被称为返回地址，是紧跟在call指令后面的那条指令的地址。对应的指令ret会从栈中弹出地址A，并把PC设置为A。

|指令|描述|
|:-:|:-:|
|call Label|过程调用|
|call *Operand|过程调用|
|ret|从过程调用中返回|

这两条指令可以添加后缀'q'，只是为了强调这些是x86-64版本的调用和返回，而不是IA32的。在x86-64汇编代码中，这两种版本可以互换。

### 3.7.3 数据传送

当调用一个过程时，除了要把控制传递给它并在过程返回时在传递回来之外，过程调用还可能包括把数据作为参数传递，而从过程返回还有可能包括返回一个值。x86-64中，大部分过程间的数据传送是通过寄存器实现的。当过程P调用过程Q时，P的代码必须首先把参数复制到适当的寄存器中。类似地，当Q返回到P时，P的代码可以访问寄存器%rax中的返回值。

x86-64中，可以通过寄存器最多传递6个整型(例如整数和指针)参数。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递数据类型的大小。会根据参数在参数列表中的顺序为它们分配寄存器。可以通过64位寄存器适当的部分访问小于64位的参数。

|操作数大小(位)\参数数量|1|2|3|4|5|6|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|64|%rdi|%rsi|%rdx|%rcx|%r8|%r9|
|32|%edi|%esi|%edx|%ecx|%r8d|%r9d|
|16|%di|%si|%dx|%cx|%r8w|%r9w|
|8|%dil|%sil|%dl|%cl|%r8b|%r9b|

如果有一个函数有大于6个整型参数，超出6个的部分就要通过栈来传递。假设过程P调用过程Q，有n个整型参数，且n>6。那么P的代码分配的栈帧必须要能容纳7到n号参数的存储空间。要把参数1~6复制到对应的寄存器，把参数7~n放到栈上，而参数7位于栈顶。通过栈传递参数时，所有的数据大小都向8的倍数对齐。参数到位后，程序就可以执行call指令将控制转移到过程Q了。过程Q可以通过寄存器访问参数，有必要的话也可以通过栈访问。相应地，如果Q也调用了某个有超过6个参数的函数，它也需要在自己的栈帧中为超出6个部分的参数分配空间。

### 3.7.4 栈上的局部存储

有些时候，局部数据必须存放在内存中，常见的情况包括：
* 寄存器不足够存放所有的本地数据
* 对一个局部变量使用地址运算符'&'，因此必须能够为它产生一个地址。
* 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。

一般来说，过程通过减小栈指针在栈上分配空间。分配的结果作为栈帧的一部分，标号为"局部变量"。

### 3.7.5 寄存器中的局部存储空间

寄存器是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程(调用者)调用另一个过程(被调用者)时，被调用者不会覆盖调用者稍后会使用的寄存器值。为此，x86-64采用了统一的寄存器使用惯例，所有的过程(包括程序库)都必须遵循。

寄存器%rbx、%rbp和%r12~%r15被划分为**被调用者保存寄存器**。当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样的。过程Q保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压入寄存器的值会在栈帧中创建标号为"保存的寄存器"的一部分。有了这条惯例，P的代码就能安全地把值存在被调用者保存寄存器中(当然，要先把之前的值保存到栈上)，调用Q，然后继续使用寄存器中的值，不用担心值被破坏。

所有其他寄存器，除了栈指针%rsp，都分类为**调用者保存寄存器**。这就意味着任何函数都能修改它们。可以这样来理解"调用者保存"这个名字：过程P在某个此类寄存器中有局部数据，然后调用过程Q。因为Q可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是P(调用者)的责任。

### 3.7.6 递归过程

递归调用一个函数本身与调用其他函数是一样的。栈规则提供了一种机制，每次函数调用都有它自己私有的状态信息(保存的返回位置和被调用者保存寄存器的值)存储空间。如果需要，他还可以提供局部变量的存储。栈分配和释放的规则很自然地与函数调用-返回的顺序匹配。这种实现函数调用和返回的方法甚至对更复杂的情况也使用，包括相互递归调用。

## 3.8 数组分配和访问

### 3.8.1 基本原则

对于数据类型T和整型常数N，声明如下：`T A[N];`起始位置表示为$x_A$。这个声明有两个效果。首先，它在内存中分配一个L\*N字节的连续区域，这里L是数据类型T的大小(单位为字节)。其次，它引入了标识符A，可以用A来作为指向数组开头的指针，这个指针的值就是$x_A$。可以用0~N-1的整数索引来访问该数组元素。数组元素i会被存放在地址为$x_A+L*i$的地方。

x86-64的内存引用指令可以用来简化数组访问。例如，假设E是一个int型的数组，而我们想计算E[i]，在此，E的地址存放在寄存器%rdx中，而i存放在寄存器%rcx中。然后，指令`movl (%rdx , %rcx,4) ,%eax`会执行地址计算%x_E+4i%，读这个内存位置的值，并将结果存放到寄存器%eax中。允许的伸缩因子1、2、4和8覆盖了所有基本简单数据类型的大小。

### 3.8.2 指针运算

C语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。也就是说，如果p是一个指向类型为T的数据的指针，p的值为$x_p$，那么表达式p+i的值为$x_p+L*i$，这里L是数据类型T的大小。

单操作数操作符'&'和'\*'可以产生指针和间接引用指针。也就是，对于一个表示某个对象的表达式Expr，&Expr是给出该对象地址的一个指针。对于一个表示地址的表达式AExpr，\*AExpr给出该地址处的值。因此，表达式Expr与*&Expr是等价的。可以对数组和指针应用数组下标操作。数组引用A[i]等同于表达式*(A+i)。它计算第i个数组元素的地址,然后访问这个内存位置。

### 3.8.3 嵌套的数组

当我们创建数组的数组时，数组分配和引用的一般原则也是成立的。例如，声明`int A[5][3];`等价于下面的声明
```
typedef int row3_t[3];
row3_t A[5];
```
数据类型row3_t被定义为一个3个整数的数组。数组A包含5个这样的元素，每个元素需要12个字节来存储3个整数。整个数组的大小就是4×5×3=60字节。

数组A还可以被看成一个5行3列的二维数组，用A[0\][0\]到A[4\][2\]来引用。数组元素在内存中按照“行优先”的顺序排列，意味着第0行的所有元素，可以写作A[0]，后面跟着第1行的所有元素(A[1])，以此类推。

要访问多维数组的元素，编译器会以数组起始为基地址,(可能需要经过伸缩的)偏移量为索引，产生计算期望的元素的偏移量，然后使用某种MOV指令。通常来说，对于一个声明如下的数组:`T D[R][C];`它的数组元素D[i][j]的内存地址为$\&D[i][j]= x_D+L(C·i+j)$这里，L是数据类型T以字节为单位的大小。

### 3.8.4 定长数组

C语言编译器能够优化定长多维数组上的操作代码。这里我们展示优化等级设置为-01时GCC采用的一些优化。假设我们用如下方式将数据类型fix_matrix声明为16×16的整型数组:
```
#define N 16
typedef int fix_matrix[N] [N];
```
(这个例子说明了一个很好的编码习惯。当程序要用一个常数作为数组的维度或者缓冲区的大小时，最好通过# define声明将这个常数与一个名字联系起来，然后在后面一直使用这个名字代替常数的数值。这样一来，如果需要修改这个值，只用简单地修改这个#define声明就可以了。

### 3.8.5 变长数组

在变长数组的C版本中，我们可以将一个数组声明如下:`int A[expr1] [expr2]`它可以作为一个局部变量，也可以作为一个函数的参数，然后在遇到这个声明的时候，通过对表达式expr1和 expr2求值来确定数组的维度。

可以看到，如果允许使用优化，GCC能够识别出程序访问多维数组的元素的步长。然后生成的代码会避免直接计算数组下标会导致的乘法。不论生成基于指针的代码还是基于数组的代码，这些优化都能显著提高程序的性能。

## 3.9 异质的数据结构

### 3.9.1 结构

C语言的struct声明创建一个数据类型，将可能不同类型的对象聚合到一个对象中。用名字来引用结构的各个组成部分。类似于数组的实现，结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段(field)的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。

要产生一个指向结构内部对象的指针，我们只需将结构的地址加上该字段的偏移量。

结构的各个字段的选取完全是在编译时处理的。机器代码不包含关于字段声明或字段名字的信息。

### 3.9.2 联合

联合提供了一种方式，能够规避C语言的类型系统，允许以多种类型来引用一个对象。联合声明的语法与结构的语法一样，只不过语义相差比较大。它们是用不同的字段来引用相同的内存块。

在如下声明中：
```C
struct S3 {
    char c;
    int i[2];
    double v;
};

uniou U3 {
    char c;
    int i[2];
    double v;
};
```
在x86-64Linux机器上编译时，字段的偏移量、数据类型S3和U3的完整大小如下：(i的偏移量为4是因为数据对齐，double v数据的地址需要为8的倍数)

|类型|c|i|v|大小|
|:-:|:-:|:-:|:-:|:-:|
|S3|0|4|16|24|
|U3|0|0|0|8|

对于类型`union U3 * `的指针`p`，`p->c`，`p->i[0]`，`p->v`引用的都是数据结构的起始位置。并且一个联合的总的大小等于它最大字段的大小。

在一些下上文中，联合十分有用。但是，它也能引起一些**错误**，因为它们绕过了C语言类型系统提供的安全措施。一种应用情况是，我们事先知道对一个数据结构中的两个不同字段的使用是互斥的，那么将这两个字段声明为联合的一部分，而不是结构的一部分，会减小分配空间的总量。

另一种情况是联合还可以用来访问不同数据类型的位模式。
```C
unsigned long double2bits(double d) {
    union {
        double d;
        unsigned long u;
    } temp;
    temp.d = d;
    return temp.u;
}
```
在这段代码中，我们以一种数据类型来存储联合中的参数，又以另一种数据类型来访问它。结果会是u具有和d一样的位表示，包括符号位字段、指数和尾数。而强制类型转换`unsigned long u = (unsigned long) d;`，除了d的值为0.0的情况以外，u的位表示会与d的很不一样。

当用联合来将各种不同大小的数据类型结合到一起时，字节顺序问题就变得很重要了。例如，假设我们写了一个过程，它以两个4字节的unsigned的位模式，创建一个8字节的 double:

```C
double uu2double(unsigned word0, unsigned word1) {
    union {
        double d;
        unsigned u[2];
    } temp;

    temp.u[0] = word0;
    temp.u[1] = word1;
    return temp.d;
}
```
在x86-64这样的小端法机器上，参数word0是d的低位4个字节，而word1是高位4个字节。在大端法机器上，这两个参数的角色刚好相反。

### 3.9.3 数据对齐

许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K(通常是2、4或8)的倍数。这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计。例如，假设一个处理器总是从内存中取8个字节，则地址必须为8的倍数。如果我们能保证将所有的double类型数据的地址对齐成8的倍数，那么就可以用一个内存操作来读或者写值了。否则，我们可能需要执行两次内存访问，因为对象可能被分放在两个8字节内存块中。

无论数据是否对齐，x86-64硬件都能正确工作。不过，Intel还是建议要对齐数据以提高内存系统的性能。对齐原则是任何K字节的基本对象的地址必须是K的倍数。可以看到这条原则会得到如下对齐:

|K|类型|
|:-:|:-:|
|1|char|
|2|short|
|4|int, float|
|8|long, double, char*|

确保每种数据类型都是按照指定方式来组织和分配，即每种类型的对象都满足它的对齐限制，就可保证实施对齐。

对于包含结构的代码，编译器可能需要在字段的分配中插入间隙，以保证每个结构元素都满足它的对齐要求。而结构本身对它的起始地址也有一些对齐要求。编译器必须保证任何struct S1 *类型的指针p都满足4字节对齐。另外，编译器结构的末尾可能需要一些填充，这样结构数组中的每个元素都会满足它的对齐要求。

任何针对x86-64处理器的编译器和运行时系统都必须保证分配用来保存可能会被SSE寄存器(这些指令对16字节数据块进行处理，在SSE单元和内存之间传递数据的指令要求内存地址必须是16的倍数)读或写的数据结构的内存，都必须满足16字节对齐。这个要求有两个后果:1.任何内存分配函数(alloca、malloc、calloc或realloc)生成的块的起始地址都必须是16的倍数。2.大多数函数的栈帧的边界都必须是16字节的倍数。(这个要求有一些例外。)

## 3.10 在机器级程序中将控制与数据结合起来

### 3.10.1 理解指针

指针和它们映射到机器代码的关键原则

* **每个指针都对应一个类型。**这个类型表明该指针指向的是哪一类对象。`int *ip`是一个指向int类型对象的指针，`char **cpp`指针指向的对象自身就是一个指向chatr类型对象的指针。通常，如果对象类型为T，那么指针的类型为T*。特殊的void *类型代表通用指针。比如说，malloc函数返回一个通用指针，然后通过显式强制类型转换或者赋值操作那样的隐式强制类型转换，将它转换成一个有类型的指针。指针类型不是机器代码中的一部分﹔它们是C语言提供的一种抽象，帮助程序员避免寻址错误。

* **每个指针都有一个值。**这个值是某个指定类型的对象的地址。特殊的NULL(O)值表示该指针没有指向任何地方。

* **指针用'&'运算符创建。**这个运算符可以应用到任何lvalue类的C表达式上，lvalue意指可以出现在赋值语句左边的表达式。这样的例子包括变量以及结构、联合和数组的元素。因为leaq指令是设计用来计算内存引用的地址的，&运算符的机器代码实现常常用这条指令来计算表达式的值。

* **'*'操作符用于间接引用指针。**其结果是一个值，它的类型与该指针的类型一致。间接引用是用内存引用来实现的，要么是存储到一个指定的地址，要么是从指定的地址读取。

* **数组与指针紧密联系。**一个数组的名字可以像一个指针变量一样引用(但是不能修改)。数组引用(例如a[3\])与指针运算和间接引用(例如* (a+ 3))有一样的效果。数组引用和指针运算都需要用对象大小对偏移量进行伸缩。当我们写表达式p+i，这里指针p的值为p，得到的地址计算为p+L*i，这里L是与p相关联的数据类型的大小。

* **将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。**强制类型转换的一个效果是改变指针运算的伸缩。例如，如果p是一个char *类型的指针，它的值为p，那么表达式(int * )p+ 7计算为p+28，而(int * ) (p+ 7)计算为p+7。(强制类型转换的优先级高于加法。)

* **指针也可以指向函数。**这提供了一个很强大的存储和向代码传递引用的功能，这些引用可以被程序的某个其他部分调用。例如，如果我们有一个函数，用下面这个原型定义：`int fun(int x, int *p);`然后，我们可以声明一个指针fp，将它赋值为这个函数，代码如下:`int (*fp)(int, int *);fp = fun;`然后用这个指针来调用这个函数:`int y = 1;int result - fp(3，&y);`函数指针的值是该函数机器代码表示中第一条指令的地址。

### 3.10.2 应用：使用GDB调试器

启动GDB的指令：`linux > gdb fileName`

GDB指令示例：

|命令|效果|
|:-:|:-:|
|开始和停止||
|quit|退出GDB|
|run|运行程序(在此给出命令行参数)|
|kill|停止程序|
|断点||
|break foo|在函数foo入口处设置断点|
|break * 0x400540|在地址0x400540处设置断点|
|delete 1|删除断点1|
|delete|删除所有断点|
|执行||
|stepi|执行1条指令|
|stepi 4|执行4条指令|
|nexti|类似于stepi，但以函数调用为单位|
|continue|继续执行|
|finish|运行到当前函数返回|
|检查代码||
|disas|反汇编当前函数|
|desas foo|反汇编函数foo|
|disas 0x400540|反汇编位于地址0x400540附近的函数|
|disas 0x400540, 0x40054d|反汇编指定地址范围内的代码|
|print /x $rip|以十六进制输出程序计数器的值|
|检查数据||
|print $rax|以十进制输出%rax的内容|
|print /x $rax|以十六进制输出%rax的内容|
|print /t $rax|以二进制输出%rax的内容|
|print 0x100|输出0x100的十进制表示|
|print /x 555|输出555的十六进制表表示|
|print /x ($rsp+8)|以十六进制输出%rsp的内容加上8|
|print *(long *) 0x7fffffff|输出位于地址0x7fffffff的长整数|
|print *(long *) ($rsp+8)|输出位于地址%rsp+8处的长整数|
|x/2g 0x7fffffff|检查从地址0x7fffffff开始的双(8字节)字|
|x/20bfoo|检查函数foo的前20个字节|
|有用的信息||
|info frame|有关当前栈帧的信息|
|info registers|所有寄存器的值|
|help|获取有关GSB的信息|

### 3.10.3 内存越界引用和缓冲区溢出

我们已经看到，C对于数组引用不进行任何边界检查，而且局部变量和状态信息(例如保存的寄存器值和返回地址)都存放在栈中。这两种情况结合到一起就能导致严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，试图重新加载寄存器或执行ret指令时，就会出现很严重的错误。

一种特别常见的状态破坏称为**缓冲区溢出**。通常，在栈中分配某个字符数组来保存一个字符串，但是字符串的长度超出了为数组分配的空间。返回指针的值以及更多可能的保存状态会被破坏。

缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种最常见的通过计算机网络攻击系统安全的方法。通常，输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为攻击代码(exploit code)，另外，还有一些字节会用一个指向攻击代码的指针覆盖返回地址。那么，执行ret指令的效果就是跳转到攻击代码。

在一种攻击形式中，攻击代码会使用系统调用启动一个shell程序，给攻击者提供一组操作系统函数。在另一种攻击形式中，攻击代码会执行一些未授权的任务，修复对栈的破坏，然后第二次执行ret指令，(表面上)正常返回到调用者。

### 3.10.4 对抗缓冲区溢出攻击

1. 栈随机化

为了在系统中插入攻击代码，攻击者既要插入代码，也要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要知道这个字符串放置的栈地址。在过去，程序的栈地址非常容易预测。对于所有运行同样程序和操作系统版本的系统来说，在不同的机器之间，栈的位置是相当固定的。因此，如果攻击者可以确定一个常见的Web服务器所使用的栈空间，就可以设计一个在许多机器上都能实施的攻击。以传染病来打个比方，许多系统都容易受到同一种病毒的攻击，这种现象常被称作**安全单一化**。

栈随机化的思想使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行同样的代码，它们的栈地址都是不同的。**实现的方式**是:程序开始时，在栈上分配一段0～n字节之间的随机大小的空间，例如，使用分配函数alloca在栈上分配指定字节数量的空间。程序不使用这段空间，但是它会导致程序每次执行时后续的栈位置发生了变化。分配的范围n必须足够大，才能获得足够多的栈地址变化，但是又要足够小，不至于浪费程序太多的空间。

在Linux系统中，栈随机化已经变成了标准行为。它是更大的一类技术中的一种，这类技术称为**地址空间布局随机化**，或者简称ASLR。采用ASLR，每次运行时程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据，都会被加载到内存的不同区域。这就意味着在一台机器上运行一个程序，与在其他机器上运行同样的程序，它们的地址映射大相径庭。这样才能够对抗一些形式的攻击。在32位Linux上，地址的变化范围大小大约是$2^{23}$，在64位Linux上，地址的变化范围大小大约是$2^{32}$，

然而，一个执着的攻击者总是能够用蛮力克服随机化，他可以反复地用不同的地址进行攻击。一种常见的把戏就是在实际的攻击代码前插入很长一段的nop指令。执行这种指令除了对程序计数器加一，使之指向下一条指令之外，没有任何的效果。只要攻击者能够猜中这段序列中的某个地址,程序就会经过这个序列，到达攻击代码。这个序列常用的术语是"空操作雪橇(nop sled)"，意思是程序会“滑过”这个序列。如果我们建立一个256个字节的nop sled，那么枚举$2^{15}=32768$个起始地址，就能破解$n=2^{23}$的随机化，这对于一个顽固的攻击者来说，是完全可行的。对于64位的情况，要尝试枚举$2^{24}=16777216$就有点儿令人畏惧了。我们可以看到栈随机化和其他一些ASLR技术能够增加成功攻击一个系统的难度，因而大大降低了病毒或者蠕虫的传播速度,但是也不能提供完全的安全保障。

2. 栈破坏检测

计算机的第二道防线是能够检测到何时栈已经被破坏。破坏通常发生在当超越局部缓冲区的边界时。在C语言中，没有可靠的方法来防止对数组的越界写。但是，我们能够在发生了越界写的时候，在造成任何有害结果之前，尝试检测到它。

GCC在产生的代码中加入了一种**栈保护者机制**，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀值。这个**金丝雀值**,也称为**哨兵值**，是在程序每次运行时随机产生的，因此，攻击者没有简单的办法能够知道它是什么。在恢复寄存器状态和从函数返回之前,程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个函数的某个操作改变了。如果是的，那么程序异常中止。GCC会试着确定一个函数是否容易遭受栈溢出攻击，并且自动插入这种溢出检测。

栈保护很好地防止了缓冲区溢出攻击破坏存储在程序栈上的状态。它只会带来很小的性能损失，特别是因为GCC只在函数中有局部char类型缓冲区的时候才插入这样的代码。当然，也有其他一些方法会破坏一个正在执行的程序的状态，但是降低栈的易受攻击性能够对抗许多常见的攻击策略。

3. 限制可执行代码区域

最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是**限制哪些内存区域能够存放可执行代码**。在典型的程序中，只有保存编译器产生的代码的那部分内存才需要是可执行的。其他部分可以被限制为只允许读和写。正如第9章中会看到的，虚拟内存空间在逻辑上被分成了页(page)，典型的每页是2048或者4096个字节。硬件支持多种形式的内存保护，能够指明用户程序和操作系统内核所允许的访问形式。许多系统允许控制三种访问形式：读(从内存读数据)、写(存储数据到内存)和执行(将内存的内容看作机器级代码)。以前，x86体系结构将读和执行访问控制合并成一个1位的标志，这样任何被标记为可读的页也都是可执行的。栈必须是既可读又可写的，因而栈上的字节也都是可执行的。已经实现的很多机制，能够限制一些页是可读但是不可执行的，然而这些机制通常会带来严重的性能损失。

AMD为它的64位处理器的内存保护引入了“NX”(No-Execute，不执行)位，将读和执行访问模式分开，Intel也跟进了。有了这个特性，栈可以被标记为可读和可写，但是不可执行,而检查页是否可执行由硬件来完成，效率上没有损失。

有些类型的程序要求动态产生和执行代码的能力。例如，"即时"编译技术为解释语言(例如Java)编写的程序动态地产生代码，以提高执行性能。是否能够将可执行代码限制在由编译器在创建原始程序时产生的那个部分中，取决于语言和操作系统。

我们讲到的这些技术——随机化、栈保护和限制哪部分内存可以存储可执行代码——是用于最小化程序缓冲区溢出攻击漏洞三种最常见的机制。它们都具有这样的属性,即不需要程序员做任何特殊的努力,带来的性能代价都非常小,甚至没有。单独每一种机制都降低了漏洞的等级，而组合起来，它们变得更加有效。不幸的是，仍然有方法能够攻击计算机，因而蠕虫和病毒继续危害着许多机器的完整性。

### 3.10.5 支持变长栈帧

到目前为止,我们已经检查了各种函数的机器级代码，但它们有一个共同点,即编译器能够预先确定需要为栈帧分配多少空间。但是有些函数,需要的局部存储是变长的。例如，当函数调用alloca时就会发生这种情况。alloca是一个标准库函数，可以在栈上分配任意字节数量的存储。当代码声明一个局部变长数组时，也会发生这种情况。

为了**管理变长栈帧**，x86-64代码使用寄存器%rbp作为帧指针(有时称为基指针，这也是%rbp中bp两个字母的由来)。当使用帧指针时,代码必须把%rbp之前的值保存到栈中,因为它是一个被调用者保存寄存器。然后在函数的整个执行过程中，都使得%rbp指向那个时刻栈的位置，然后用固定长度的局部变量(例如i)相对于%rbp的偏移量来引用它们。

在较早版本的x86代码中，每个函数调用都使用了帧指针。而现在，只在栈帧长可变的情况下才使用。历史上，大多数编译器在生成IA32代码时会使用帧指针。最近的GCC版本放弃了这个惯例。可以看到把使用帧指针的代码和不使用帧指针的代码混在一起是可以的，只要所有的函数都把%rbp当做被调用者保存寄存器来处理即可。

## 3.11 浮点代码

我们的讲述基于AVX2，即AVX的第二个版本，它是在2013年Core i7 Haswell处理器中引入的。当给定命令行参数-mavx2时，GCC会生成AVX2代码。基于不同版本的SSE 以及第一个版本的AVX的代码从概念上来说是类似的，不过指令名和格式有所不同。我们只介绍用GCC编译浮点程序时会出现的那些指令。其中大部分是标量AVX指令，我们也会说明对整个数据向量进行操作的指令出现的情况。

媒体寄存器：每个YMM寄存器都是256位(32字节)。当对标量数据操作时，这些寄存器只保存浮点数，而且只使用低32位(对于float)或64位(对于double)。汇编代码用寄存器的SEE XMM寄存器名字%xmm0~%xmm15来引用它们，每个XMM寄存器都是对应的YMM寄存器的低128位(16字节)。

|256位寄存器名称|128位寄存器名称|描述|
|:-:|:-:|:-:|
|%ymm0|%xmm0|1st FP arg.返回值|
|%ymm1|%xmm1|2nd FP参数|
|%ymm2|%xmm2|3rd FP参数|
|%ymm3|%xmm3|4th FP参数|
|%ymm4|%xmm4|5th FP参数|
|%ymm5|%xmm5|6th FP参数|
|%ymm6|%xmm6|7th FP参数|
|%ymm7|%xmm7|8th FP参数|
|%ymm8|%xmm8|调用者保存|
|%ymm9|%xmm9|调用者保存|
|%ymm10|%xmm10|调用者保存|
|%ymm11|%xmm11|调用者保存|
|%ymm12|%xmm12|调用者保存|
|%ymm13|%xmm13|调用者保存|
|%ymm14|%xmm14|调用者保存|
|%ymm15|%xmm15|调用者保存|

### 3.11.1 浮点传送和转换操作

在内存和XMM寄存器之间以及从一对XMM寄存器之间的传送浮点数的指令。引用内存的指令是标量指令，意味着它们只对单个而不是一组封装好的数据值进行操作。数据要么保存在内存中(由表中的$M_{32}$和$M_{64}$指明)，要么保存在XMM寄存器中(在表中用X表示)。无论数据对齐与否，这些指令都能正确执行，不过代码优化规则建议32位内存数据满足4字节对齐，64位数据满足8字节对齐。内存引用的指定方式与整数MOV指令的一样，包括偏移量、基址寄存器、变址寄存器和伸缩因子的所有可能的组合。

|指令|源|目的|描述|
|:-:|:-:|:-:|:-:|
|vmovss|$M_{32}$|X|传送单精度数|
|vmovss|X|$M_{32}$|传送单精度数|
|vmovsd|$M_{64}$|X|传送双精度数|
|vmovsd|X|$M_{64}$|传送双精度数|
|vmovaps|X|X|传送对齐的封装好的单精度数|
|vmovapd|X|X|传送对齐的封装好的双精度数|

GCC只用标量传送操作从内存传送数据到XMM寄存器或从XMM寄存器传送数据到内存。对于在两个XMM寄存器之间传送数据，GCC会使用两种指令之一，即用vmovaps传送单精度数，用vrnovapd传送双精度数。对于这些情况，程序复制整个寄存器还是只复制低位值既不会影响程序功能，也不会影响执行速度，所以使用这些指令还是针对标量数据的指令没有实质上的差别。指令名字中的字母'a'表示"aligned(对齐的)"。当用于读写内存时，如果地址不满足16字节对齐，它们会导致异常。在两个寄存器之间传送数据，绝不会出现错误对齐的状况。

**双操作数浮点转换指令**。这些操作将浮点数转换成整数(X：XMM寄存器，例如%xmm3；$R_{32}$:32位通用寄存器，例如%eax；$R_{64}$位通用寄存器，例如%rax；$M_{32}$：32位内存范围；$M_{64}$：64位内存范围)

|指令|源|目的|描述|
|:-:|:-:|:-:|:-:|
|vcvttss2si|$X/M_{32}$|$R_{32}$|用截断的方法把单精度数转换成整数|
|vcvttsd2si|$X/M_{64}$|$R_{32}$|用截断的方法把双精度数转换成整数|
|vcvttss2siq|$X/M_{32}$|$R_{64}$|用截断的方法把单精度数转换成四字整数|
|vcvttsd2siq|$X/M_{64}$|$R_{64}$|用截断的方法把双精度数转换成四字整数|

**三操作数浮点数转换指令**。这些操作将第一个源的数据类型转换成目的的数据类型。第二个源值对结果的低位字节没有影响。(X：XMM寄存器，例如%xmm3；$R_{32}$:32位通用寄存器，例如%eax；$R_{64}$位通用寄存器，例如%rax；$M_{32}$：32位内存范围；$M_{64}$：64位内存范围)

|指令|源1|源2|目的|描述|
|:-:|:-:|:-:|:-:|:-:|
|vcvtsi2ss|$M_{32}/R_{32}$|X|X|把整数转换成单精度数|
|vcvtsi2sd|$M_{32}/R_{32}$|X|X|把整数转换成双精度数|
|vcvtsi2ssq|$M_{64}/R_{64}$|X|X|把四字整数转换成单精度数|
|vcvtsi2sdq|$M_{64}/R_{64}$|X|X|把四字整数转换成双精度数|

三操作数转换指令中，第一个操作数读自于内存或一个通用目的寄存器。第二个操作数可以忽略，因为它的值只会影响结果的高位字节。第三个操作数必须是XMM寄存器。在最常见的使用场景中，第二个源和目的操作数是一样的。

把浮点值转换成整数时，指令会执行截断，把值向0进行舍入，这是C语言和大多数其他编程语言的要求。

float f 存储于%xmm0中，以下指令将float f 转换为double：
```
vunpcklps %xmm0, %xmm0, %xmm0
vcvtps2pd %xmm0, %xmm0
```
double f 存储于%xmm0中，以下指令将double f 转换为float：
```
vunpcklpd %xmm0, %xmm0, %xmm0
vcvtpd2ps %xmm0, %xmm0
```

### 3.11.2 过程中的浮点代码

在x86-64 中，XMM寄存器用来向函数传递浮点参数，以及从函数返回浮点值。

XMM寄存器%xmm0~%xmm7最多可以传递8个浮点参数。按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。

函数使用寄存器%xmm0来返回浮点值。

所有的XMM寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器中任意一个。

当函数包含指针、整数和浮点数混合的参数时，指针和整数通过通用寄存器传递，而浮点值通过XMM寄存器传递。也就是说，参数到寄存器的映射取决于它们的类型和排列的顺序。`double f1(int x, double y, long z)`和`double f1(double y, int x, long z)`的参数到寄存器的映射相同，把x存放在%edi中，y放在%xmm中，z放在%rsi中。

### 3.11.3 浮点运算操作

以下为执行算术运算的标量AVX2浮点指令。每条指令有一个($S_1$)或两个($S_1$, $S_2$)源操作数，和一个目的操作数D。第一个源操作数$S_1$可以是一个XMM寄存器或一个内存位置。第二个源操作数和目的操作数都必须是XMM寄存器。每个操作都有一条针对单精度的指令和一条针对双精度的指令。结果存放在目的寄存器中。

|单精度|双精度|效果|描述|
|:-:|:-:|:-:|:-:|
|vaddss|vaddsd|$S_2+S_1 → D$||
|vsubss|vsubsd|$S_2-S_1 → D$||
|vmulss|vmulsd|$S_2 * S_1 → D$||
|vdivss|vdivsd|$S_2/S_1 → D$||
|vmaxss|vmaxsd|$max(S_2, S_1) → D$||
|vminss|vminsd|$min(S_2, S_1) → D$||
|sqrtss|sqrtsd|$\sqrt{S_1} → D$||

### 定义和使用浮点常数

和整数运算操作不同，AVX浮点操作不能以立即数值作为操作数。相反，编译器必须为所有的常量值分配和初始化存储空间。然后代码在把这些值从内存读人。下面从摄氏度到华氏度转换的函数就说明了这个问题:
```C
double cel2fahr(double tmep) {
    return 1.8 * temp + 32.0
}
```

相应的x86-64汇编代码部分如下：

```x86asm
; double cel2fahr(double temp)
; temp in %xmm0
cel2fahr:
    vmulsb .LC2(%rip), %xmm0, %xmm0 ; Multiply by 1.8
    vaddsb .LC3($rip), %xmm0, %xmm0 ; Add 32.0
    ret
.LC2:
    .long 3435973837    ; Low-order 4 bytes of 1.8
    .long 1073532108    ; High-order 4 bytes of 1.8
.LC3:
    .long 0             ; Low-order 4 bytes of 32.0
    .long 1077936128    ; High-order 4 bytes of 32.0
```

可以看到函数从标号为.LC2的内存位置读出值1.8，从标号为.LC3的位置读入值32.0。观察这些标号对应的值，可以看出每一个都是通过一对.long声明和十进制表示的值指定的。该怎样把这些数解释为浮点值呢?标号为.LC2的声明，有两个值:3435973837(Oxcccccccd)和1073532108(0x3ffccccc)。因为机器采用的是小端法字节顺序，第一个值给出的是低位4字节，第二个给出的是高位4字节。从高位字节，可以抽取指数字段为0x3ff(1023)，减去偏移1023得到指数0。将两个值的小数位连接起来，得到小数字段0xccccccccccccd，二进制小数表示为0.8，加上隐含的1得到1.8。标号为.LC3的声明，有两个值:0(Oxcccccccd)和1077936128(0x40400000)。因为机器采用的是小端法字节顺序，第一个值给出的是低位4字节，第二个给出的是高位4字节。从高位字节，可以抽取指数字段为0x404(1028)，减去偏移1023得到指数5。将两个值的小数位连接起来，得到小数字段为0，二进制小数表示为0，加上隐含的1得到1.0。因此常数是$1.0*2^5=32.0$。

### 3.11.5 在浮点代码中使用位级操作

在浮点代码中使用的位级操作都作用于封装好的数据，即它们更新整个目的XMM寄存器，对两个源寄存器的所有位都实施指定的位级操作。

|单精度|双精度|效果|描述|
|:-:|:-:|:-:|:-:|
|vxorps|vxrpd|$S_2^S_1 → D$|位级异或(EXCLUSIVE-OR)|
|vandps|andpd|$S_2\&S_1 → D$|位级与(AND)|

### 3.11.6 浮点比较操作

|指令|基于|描述|
|:-:|:-:|:-:|
|ucomiss $S_1, S_2$|$S_2-S_1$|比较单精度值|
|ucomisd $S_1, S_2$|$S_2-S_1$|比较双精度值|

这些指令类似于CMP指令，它们都比较操作数$S_1$和$S_2$(但是顺序可能与预计的相反)，并且设置条件码指示它们的相对值。与cmpq一样，它们遵循以相反顺序列出操作数的ATT格式惯例。参数$S_2$必须在XMM寄存器中，而$S_1$可以在XMM寄存器中，也可以在内存中。

浮点比较指令会设置三个**条件码**：零标志位ZF、进位标志位CF和奇偶标志位PF。奇偶标志位在GCC产生的x86代码中不太常见。对于整数操作，当最近的一次算术或逻辑运算产生的值的最低位字节是偶校验的(即这个字节中有偶数个1)，那么就会设置这个标志位，即最低位字节与奇偶标志位中1的个数的和为奇数。不过对于浮点比较，当两个操作数中任一个是NaN时，会设置该位。根据惯例，C语言中如果有个参数为NaN，就认为比较失败了,这个标志位就被用来发现这样的条件。例如，当x为NaN时，比较x==x都会得到0。

条件码的设置条件如下:

|顺序$S_2:S_1$|CF|ZF|PF|
|:-:|:-:|:-:|:-:|
|无序的|1|1|1|
|$S_2<S_1$|1|0|0|
|$S_2=S_1$|0|1|0|
|$S_2>S_1$|0|0|0|

当任一操作数为NaN时，就会出现无序的情况。可以通过奇偶标志位发现这种情况。通常jp指令是条件跳转，条件就是浮点比较得到一个无序的结果。除了这种情况以外，进位和零标志位的值都和对应的无符号比较一样：当两个操作数相等时，设置ZF;当$S_2<S_1$时，设置CF。像ja和jb这样的指令可以根据标志位的各种组合进行条件跳转。

### 3.11.7 对浮点代码的观察结论

我们可以看到，用AVX2为浮点数上的操作产生的机器代码风格类似于为整数上的操作产生的代码风格。它们都使用一组寄存器来保存和操作数据值，也都使用这些寄存器来传递函数参数。

当然，处理不同的数据类型以及对包含混合数据类型的表达式求值的规则有许多复杂之处，同时，AVX2代码包括许多比只执行整数运算的函数更加不同的指令和格式。

AVX2还有能力在封装好的数据上执行并行操作，使计算执行得更快。编译器开发者正致力于自动化从标量代码到并行代码的转换，但是目前通过并行化获得更高性能的最可靠的方法是使用GCC支持的、操纵向量数据的C语言扩展。

## 3.12 小结

在本章中，我们窥视了C语言提供的抽象层下面的东西，以了解机器级编程。通过让编译器产生机器级程序的汇编代码表示，我们了解了编译器和它的优化能力，以及机器、数据类型和指令集。在第5章，我们会看到，当编写能有效映射到机器上的程序时，了解编译器的特性会有所帮助。我们还更完整地了解了程序如何将数据存储在不同的内存区域中。在第12章会看到许多这样的例子，应用程序员需要知道一个程序变量是在运行时栈中，是在某个动态分配的数据结构中，还是全局程序数据的一部分。理解程序如何映射到机器上，会让理解这些存储类型之间的区别容易一些。

机器级程序和它们的汇编代码表示，与C程序的差别很大。各种数据类型之间的差别很小。程序是以指令序列来表示的，每条指令都完成一个单独的操作。部分程序状态，如寄存器和运行时栈，对程序员来说是直接可见的。本书仅提供了低级操作来支持数据处理和程序控制。编译器必须使用多条指令来产生和操作各种数据结构，以及实现像条件、循环和过程这样的控制结构。我们讲述了C语言和如何编译它的许多不同方面。我们看到C语言中缺乏边界检查，使得许多程序容易出现缓冲区溢出。虽然最近的运行时系统提供了安全保护，而且编译器帮助使得程序更安全，但是这已经使许多系统容易受到恶意入侵者的攻击。

我们只分析了C到x86-64的映射，但是大多数内容对其他语言和机器组合来说也是类似的。例如,编译C++与编译C就非常相似。实际上，C++的早期实现就只是简单地执行了从C++到C的源到源的转换，并对结果运行C编译器，产生目标代码。C++的对象用结构来表示，类似于C的struct。C++的方法是用指向实现方法的代码的指针来表示的。相比而言，Java的实现方式完全不同。Java的目标代码是一种特殊的二进制表示，称为Java字节代码。这种代码可以看成是虚拟机的机器级程序。正如它的名字暗示的那样，这种机器并不是直接用硬件实现的，而是用软件解释器处理字节代码，模拟虚拟机的行为。另外，有一种称为及时编译(just-in-time compilation)的方法,动态地将字节代码序列翻译成机器指令。当代码要执行多次时(例如在循环中)，这种方法执行起来更快。用字节代码作为程序的低级表示，优点是相同的代码可以在许多不同的机器上执行，而在本章谈到的机器代码只能在x86-64机器上运行。
