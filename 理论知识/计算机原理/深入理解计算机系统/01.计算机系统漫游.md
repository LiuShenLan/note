- [计算机系统漫游](#计算机系统漫游)
	- [1.1 信息就是位+上下文](#11-信息就是位上下文)
	- [1.2 程序被其他程序翻译成不同的格式](#12-程序被其他程序翻译成不同的格式)
	- [1.3 了解编译系统如何工作是大有益处的](#13-了解编译系统如何工作是大有益处的)
	- [1.4 处理器读并解释储存在内存中的指令](#14-处理器读并解释储存在内存中的指令)
		- [1.4.1 系统的硬件组成](#141-系统的硬件组成)
		- [1.4.2 运行hello程序](#142-运行hello程序)
	- [1.5 高速缓存至关重要](#15-高速缓存至关重要)
	- [1.6 存储设备形成层次结构](#16-存储设备形成层次结构)
	- [1.7 操作系统管理硬件](#17-操作系统管理硬件)
		- [1.7.1 进程](#171-进程)
		- [1.7.2 线程](#172-线程)
		- [1.7.3 虚拟内存](#173-虚拟内存)
		- [1.7.4 文件](#174-文件)
	- [1.8 系统之间利用网络通信](#18-系统之间利用网络通信)
	- [1.9 重要主题](#19-重要主题)
		- [1.9.1 Amdahl定律](#191-amdahl定律)
		- [1.9.2 并发和并行](#192-并发和并行)
		- [1.9.3 计算机系统中抽象的重要性](#193-计算机系统中抽象的重要性)
	- [1.10 小结](#110-小结)

# 计算机系统漫游

## 1.1 信息就是位+上下文

程序的生命周期是从一个源程序(源文件)开始的，即程序员通过编辑器创建并保存的文本文件(如hello.c)。源程序实际上就是一个由值0和1组成的位(比特)序列，8个位被组织成一组，称为**字节**。

只由ASCII字符构成的文件称为文本文件，所有其他文件都称为二进制文件。

系统中所有的信息：包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。

## 1.2 程序被其他程序翻译成不同的格式

编译系统：
* 预处理阶段：

预处理器(cpp)根据以字符#开头的指令，修改原始的C程序。结果就得到了另一个C程序，通常是以.i作为文件扩展名。

* 编译阶段

编译器(ccl)将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。汇编语言程序中的语句以一种文本格式描述了一条低级机器语言指令。汇编语言为不同高级语言的不同编译器提供了通用的输出语言。

* 汇编阶段

汇编器(as)将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序(relocatable object program)的格式，并将结果保存在目标文件hello.o中(二进制文件)。

* 链接阶段

hello程序调用了printf函数，它是每个C编译器都提供的标准C库中的一个函数。printf函数存在于一个名为printf.o的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的hello.o程序中。

链接器(ld)就负责处理这种合并，结果就得到hello文件，它是一个可执行目标文件(简称为可执行文件)，可以被加载到内存中，由系统执行。

## 1.3 了解编译系统如何工作是大有益处的

* 优化程序性能
* 理解链接时出现的错误
* 避免安全漏洞

## 1.4 处理器读并解释储存在内存中的指令

### 1.4.1 系统的硬件组成

1. 总线

贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字(word)。

字节中的字数(即字长)是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是4个字节(32位)，要么是8个字节(64位)。

2. I/O设备

I/O(输入/输出)设备是系统与外部世界的联系通道。

每个I/O设备都通过一个控制器或适配器与I/O总线相连。控制器和适配器之间的区别主要在于他们的封装方式。控制器是I/O设备本身或者系统的主印制电路板(主板)上的芯片组，适配器是一块插在主板插槽上的卡。他们的功能都是在I/O总线和I/O设备之间传递信息。

3. 主存

主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。

从物理上来说，主存是一组动态随机存取存储器(DRAM)芯片组成

从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址(数组索引)，这些地址是从零开始的。

一般来说，组成程序的每条机器指令都有不同数量的字节构成。

4. 处理器

中央处理单元(CPU)简称处理器，是解释(或执行)存储在主存中指令的引擎。

处理器的核心是一个大小为一个字的存储设备(或寄存器)，称为程序计数器(PC)。在任何时刻，PC都指向主存中的某条机器语言指令(即含有该条指令的地址)。

从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，在更新程序计数器，使其指向下一条指令。

处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的为，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，而这条指令并不一定个在内存中刚刚执行的指令相邻。

这样的简单操作并不多，他们围绕着主存、寄存器文件(register file)和算数/逻辑单元(ALU)进行。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。

处理器的指令集架构描述的是每条机器代码指令的效果，而处理器微体系结构描述的是处理器实际上是如何实现的

### 1.4.2 运行hello程序

shell程序执行它的指令，等待输入指令，然后将指令字符逐一读入寄存器，再把它放到内存中。

然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。利用直接存储器存取(DMA)技术，数据可以不通过处理器而直接从磁盘到达主存

处理器开始执行hello程序的main程序中的机器语言指令。指令将输出字符串中的字节从主存复制到寄存器文件，再从寄存器文件复制到显示设备，最终显示在屏幕上。

## 1.5 高速缓存至关重要

处理器从寄存器文件中读数据比从主存中读取几乎要快100倍，并且处理器与主存之间的差距还在持续扩大。针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为**高速缓存存储器**(简称为cache或高速缓存)，作为暂时的集结区域，存放处理器近期可能会需要的信息。

位于处理器芯片上的L1高速缓存的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。一个容量为数十万到数百万字节的更大的L2高速缓存通过一条特殊的总线连接到处理器。进程访问L2高速缓存的时间要比访问L1高速缓存的时间长5倍，但是这仍然比访问主存的时间快5~10倍。L1和L2高速缓存是用一种叫做静态随机访问存储器(SRAM)的硬件技术实现的。比较新的、处理能力更强大的系统甚至有三级高速缓存：L1、L2和L3。

系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。

## 1.6 存储设备形成层次结构

每个计算机系统中的存储设备都被组织成了一个存储器层次结构。在这个层次结构中，从左至右，设备的访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜

L0：寄存器→→→L1：L1高速缓存(SRAM)→→→L2：L2高速缓存(SRAM)→→→L3：L3高速缓存(SRAM)→→→L4：主存(DRAM)→→→L5：本地二级存储(本地磁盘)→→→L6：远程二级存储(分布式文件系统，Web服务器)

存储器层次结构的主要思想是上一层的存储器作为低一层的存储器的高速缓存

## 1.7 操作系统管理硬件

可以把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。

操作系统有两个基本功能：
* 防止硬件被失控的应用程序滥用
* 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备

操作系统通过几个基本的抽象概念(进程、虚拟内存和文件)来实现这两个功能* 文件是对I/O设备的抽象表示* 虚拟内存是对主存和磁盘I/O设备的抽象表示* 进程则是对处理器、主存和I/O设备的抽象表示

### 1.7.1 进程

**进程**是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件

**并发运行**则是说一个进程的指令和另一个进程的指令是交错执行的。

传统系统在一个时刻只能执行一个程序，而多核处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为上下文切换。

操作系统保持跟踪进程运行所需的所有状态信息。这种状态(也就是**上下文**)包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，都会进行**上下文切换**，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。

从一个进程到另一个进程的转换是由操作系统内核管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，它就会执行一条特殊的系统调用(system call)指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。

### 1.7.2 线程

在现代系统中，一个进程实际上可以由多个称为**线程**的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据由于网络服务器中对并行处理的需求，线程成为越来越重要的编程模块，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。当有多处理器可用的时候，多线程也是一种是的程序可以运行得的更快的方法。

### 1.7.3 虚拟内存

**虚拟内存**是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。

在Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的，
这对所有进程来说都是一样的。
地址空间的底部区域存放用户进程定义的代码和数据。
注意，下列的地址是从下往上增大的
|表中的地址是从下往上增大的|
|:-:|
|内核虚拟内存|
|用户栈(运行时创建的)|
|共享库的内存映射区域|
|运行时堆(在运行时由malloc创建的)|
|读/写数据|
|只读代码和数据|

从最低的地址开始，逐步向上介绍

* 程序代码和数据

对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C(语言)全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件hello。

* 堆

代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的C标准库函数时，堆可以在运行时动态地扩展和收缩。

* 共享库

大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。

* 栈

位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次我们调用一个函数时，栈就会增长;从一个函数返回时，栈就会收缩。

* 内核虚拟内存

地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。

虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。

### 1.7.4 文件

**文件**就是字节序列。每个I/O设备，包括磁盘、键盘、显示器甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为Unix I/O的系统函数调用来读写文件实现的。

文件这个简单而精致的概念是非常强大的，因为它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的I/O设备。

## 1.8 系统之间利用网络通信

从一个单独的系统来看，网络可视为一个I/O设备。当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，而不是比如说到达本地磁盘驱动器。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。

## 1.9 重要主题

### 1.9.1 Amdahl定律

Amdahl定律的主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。

Amdahl定律的主要观点是，要想显著加速整个系统，必须提升全系统中相当大的部分的速度。

### 1.9.2 并发和并行

并发指一个同时具有多个活动的系统;并行指用并发来使一个系统运行的更快。

我们按照系统层次结构中由高到低的顺序重点强调三个层次

1. 线程级并发

传统意义上，并发执行只是模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的。在以前，即使处理器必须在多个任务间切换，大多数实际的计算也都是由一个处理器来完成的。这种配置称为单处理器系统。

当构建一个由单操作系统内核控制的多处理器组成的系统时，我们就得到了一个多处理器系统。随着多核处理器和超线程的出现，这种系统才变得常见。

**多核处理器**是将多个CPU(称为"核")集成到一个集成电路芯片上。一个典型多核处理器的组织结构，其中微处理器芯片有4个CPU核，每个核都有自己的L1和L2高速缓存，其中的L1高速缓存分为两个部分，一个保存最近取到的指令的L1指令高速缓存，一个存放数据的L1数据高速缓存。这些核共享更高层次的高速缓存(L3及以上)，以及到主存的接口。

**超线程**，有时称为同时多线程，是一项允许一个CPU控制多个控制流的基数。它设计CPU某些硬件有多个备份，比如PC和寄存器文件，而其他的硬件部分只有一份，比如执行浮点算术运算的单元。常规的处理器需要大约2W个时钟周期做不同线程的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得CPU能够更好地利用它的处理资源。

多处理器的使用可以从两方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的不要。其次，它可以使应用程序运行得更快，当然，这必须要求程序是以多线程方式来书写的，这些线程可以并行地高效执行。

2. 指令级并行

在较低的抽象层次上，
现代处理器可以同时执行多条指令的属性被称为**指令级并行**。在流水线中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。

如果处理器可以达到比一个周期一条指令更快的执行效率，就称之为超标量处理器。

3. 单指令、多数据并行

在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SMID并行。

### 1.9.3 计算机系统中抽象的重要性

抽象的使用是计算机科学中最为重要的概念之一。

文件是I/O设备的抽象，虚拟内存是对程序存储器的抽象(主存+磁盘)，进程是对一个正在运行的程序的抽象(处理器+主存+I/O设备)，指令集架构提供了对实际处理器硬件的抽象(使用这个抽象，机器代码程序表现得就好像运行在一个一次只执行一条指令的处理器上)虚拟机提供对整个计算机的抽象(包括操作系统、处理器和程序)

## 1.10 小结

计算机系统是由硬件和系统软件组成的，他们共同写作以运行应用程序。计算机内部的信息被表示为一组组的位，他们一句上下文有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是ASCII文本，然后被编译器和链接器翻译成二进制可执行文件。

处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O设备和CPU寄存器之间复制数据，所以将系统中的存储设备划分成层次结构---CPU寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM主存和磁盘存储器。在层次模型中，位于更高层的存储设备比低层的存储设备要更快，单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次结构的知识，程序员可以优化C程序的性能。

操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象：1)文件是对I/O设备的抽象;2)虚拟内存是对主存和磁盘的抽象;3)进程是处理器、主存和I/O设备的抽象。

最后，网络提供了计算机系统之间通信的手段。从特殊系统的角度看，网络就是一种I/O设备。