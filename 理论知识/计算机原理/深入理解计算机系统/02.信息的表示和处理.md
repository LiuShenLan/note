- [信息的表示和处理](#信息的表示和处理)
	- [2.1 信息存储](#21-信息存储)
		- [2.1.1 十六进制表示法](#211-十六进制表示法)
		- [2.1.2 字数据大小](#212-字数据大小)
		- [2.1.3 寻址和字节顺序](#213-寻址和字节顺序)
		- [2.1.4 表示字符串](#214-表示字符串)
		- [2.1.5 表示代码](#215-表示代码)
		- [2.1.6 布尔代数简介](#216-布尔代数简介)
		- [2.1.8 C语言中的逻辑运算](#218-c语言中的逻辑运算)
		- [2.1.9 C语言中的移位运算](#219-c语言中的移位运算)
	- [2.2 整数表示](#22-整数表示)
		- [2.2.1 整型数据类型](#221-整型数据类型)
		- [2.2.2 无符号数的编码](#222-无符号数的编码)
		- [2.2.3 补码编码](#223-补码编码)
		- [2.2.4 有符号数和无符号数之间的转换](#224-有符号数和无符号数之间的转换)
		- [2.2.5 C语言中的有符号数与无符号数](#225-c语言中的有符号数与无符号数)
		- [2.2.6 扩展一个数字的位表示](#226-扩展一个数字的位表示)
		- [2.2.7 截断数字](#227-截断数字)
		- [2.2.8 关于有符号数和无符号数的建议](#228-关于有符号数和无符号数的建议)
	- [2.3 整数运算](#23-整数运算)
		- [2.3.1 无符号加法](#231-无符号加法)
		- [2.3.2 补码加法](#232-补码加法)
		- [2.3.3 补码的非](#233-补码的非)
		- [2.3.4 无符号乘法](#234-无符号乘法)
		- [2.3.5 补码乘法](#235-补码乘法)
		- [2.3.6 乘以常数](#236-乘以常数)
		- [2.3.7 除以2的幂](#237-除以2的幂)
		- [2.3.8 关于整数运算的最后思考](#238-关于整数运算的最后思考)
	- [2.4 浮点数](#24-浮点数)
		- [2.4.1 二进制小数](#241-二进制小数)
		- [2.4.2 IEEE浮点表示](#242-ieee浮点表示)
		- [2.4.3 数字示例](#243-数字示例)
		- [2.4.4 舍入](#244-舍入)
		- [2.4.5 浮点运算](#245-浮点运算)
		- [2.4.6 C语言中的浮点数](#246-c语言中的浮点数)
	- [2.5 小结](#25-小结)

# 信息的表示和处理

数字表示：无符号编码基于传统的二进制表示法，表示大于或者等于零的数字。补码编码是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。浮点数编码是表示实数的科学记数法的以2为基数的版本。

整数的计算机运算满足真正整数运算的许多性质，例如乘法的结合律和交换律。但由于表示的精度有限，浮点运算是不可结合的。

## 2.1 信息存储

大多数计算机使用8位的块，或者字节，作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。内存的每个字节都由一个唯一的数字来标识，称为它的地址，所有可能地址的集合就称为虚拟地址空间。虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现是将动态随机访问存储器(DRAM)、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。

### 2.1.1 十六进制表示法

二进制转化为十六进制：从右向左将数字分为四个一组，位总数不是4的倍数，最左边的一组可以少于4位，前面用0补足。

十进制转化为十六进制：反复地用16除x，得到一个商q和一个余数r，也就是x=q·16+r。然后，我们用十六进制数字表示的r作为最低位数字，并且通过对q反复进行这个过程得到剩下的数字。

### 2.1.2 字数据大小

每台计算机都有一个字长，指明指针数据的标称大小。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为w位的机器而言，虚拟地址的范围为0～2^w—1，程序最多访问2^w个字节。

### 2.1.3 寻址和字节顺序

对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。

排列表示一个对象的字节的规则：
* 小端法：在内存中按照从最低有效字节到最高有效字节的顺序存储对象，最低有效字节在最前面；
* 大端法：在内存中按照从最高有效字节到最低有效字节的顺序存储对象，最高有效字节在最前面。
* 双端法：可以把它们配置成大端或者小端的机器运行。

字节顺序需要注意的情况：
1. 在不同类型的机器之间通过网络传送二进制数据；
2. 阅读表示整数数据的字节序列时字节顺序很重要(这通常发生在检查机器级程序时)
3. 当编写规避正常的类型系统的程序时。在C语言中，可以通过使用强制类型转换或联合来允许以一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。大多数应用编程都强烈不推荐这种编码技巧，但是它们对系统级编程来说是非常有用，甚至是必需的。

### 2.1.4 表示字符串

C语言中字符串被编码为一个以null(其值为0)字符结尾的字符数组。每个字符都有某个标准编码来表示，最常见的是ASCII字符码。

在使用ASCII作为字符码的任何系统上都讲得到相同的结果，与字节顺序和字大小规则无关。因而，文本数据比二进制数据具有更强的平台独立性。

### 2.1.5 表示代码

不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。

计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。

### 2.1.6 布尔代数简介

位向量就是固定长度位w，由0和1组成的串。位向量的运算可以定义成参数的每个对应元素之间的运算。

### 2.1.8 C语言中的逻辑运算

逻辑运算符&&和||与它们对应的位级运算&和|之间的区别之一是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算就不会对第二个参数求值。

### 2.1.9 C语言中的移位运算

右移运算x>>k，
一般而言，机器支持两种形式的右移：逻辑右移和算术右移。逻辑右移是在左端补k个0，算术右移是在左端补k个最高有效位的值。算术右移对有符号整数数据的运算非常有用。

几乎所有的C编译器/机器组合都对有符号数使用算术右移，且许多程序员也都假设机器会使用这种右移。另一方面，对于无符号数，右移必须是逻辑的。

Java对于如何右移有明确的定义。x>>k会将x算术右移k个位置，而x>>>k会对x做逻辑右移。

C语言中x的位数为w时，位移量是通过计算k mod w得到的

## 2.2 整数表示

### 2.2.1 整型数据类型

取值范围不是对称的，负数的范围比整数的范围大1。

C和C++都支持有符号(默认)和无符号数，Java只支持有符号数。

### 2.2.2 无符号数的编码

无符号数编码的定义，用一个函数$B2U_{w}$(Binary to Unsigned的缩写，长度为w)来表示：

对向量$\overrightarrow{x}=[x_{w-1}, x_{w-2}, ... , x_{0}]$：$B2U_{w}(\overrightarrow{x})=\sum_{i=0}^{w-1}x_{i}2^{i}$

表示范围：$UMax_{w}=2^{w}-1$

**无符号数编码的唯一性**：函数$B2U_{w}$是一个双射（即y=f(x)中y与x一一对应）

将$U2B_{w}$称为无符号数到二进制的映射函数，在0~$2^{w}$-1之间的每一个整数都可以映射为一个唯一的长度为w的位模式。

### 2.2.3 补码编码

对于非负数x，我们用$2^{w}-x$来计算-x的w位表示。

最常见的有符号数的表示方式就是**补码形式**，在这个定义中，将字的最高有效位解释为负权。用函数$B2T_{w}$(Binaty to Two's-complement的缩写，长度为w)来表示

对向量$\overrightarrow{x}=[x_{w-1}, x_{w-2}, ... , x_{0}]$：$B2T_{w}(\overrightarrow{x})=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_{i}2^{i}$

最高有效位$x_{w-1}$也称为符号位，它的“权重”为$-2^{w-1}$，是无符号表示中权重的负数。符号位被设置为1时，表示值为负，而当设置为0时，值为非负。

表示范围：$TMin_{w}=-2^{w-1}$、$TMax_{w}=2^{w-1}-1$

**补码编码的唯一性**：函数$B2T_{w}$是一个双射。

定义函数$T2B_{w}$(即补码到二进制)作为$B2T_{w}$的反函数。

### 2.2.4 有符号数和无符号数之间的转换

对于位表示相同的无符号数和用补码表示的有符号数：
* 当有符号数大于零时，补码=无符号数
* 当有符号数小于零时，补码的绝对值+无符号数=$2^w$

对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。

* $T2U_{w}(x)=B2U_{w}(T2B_{w}(x))$

* $U2T_{w}(x)=B2T_{w}(U2B_{w}(x))$

补码转换为无符号数：$T2U_w(x)=\left\{\begin{matrix}x+2^w & x<0 \\ x & x\geqslant 0 \end{matrix}\right.$，当将一个有符号数映射为它相应的无符号数时，负数就被转换成了大的正数，而非负数会保持不变。

无符号数转换为补码：$U2T_w(u)=\left\{\begin{matrix}u & x\leqslant TMax_w \\ u-2^w & u>TMax_w \end{matrix}\right.$，对于小的数($\leqslant TMax_w$)，从无符号数到有符号的转换将保留数字的原值。对于大的数($>TMax_w$)，数字将被转换为一个负数值。

### 2.2.5 C语言中的有符号数与无符号数

在进行无符号数和有符号数之间的转换时，大多数系统遵循的原则是底层的位表示保持不变。

当执行一个运算时，如果一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。

### 2.2.6 扩展一个数字的位表示

要将一个无符号数转换为一个更大的数据类型，只需要在表示的开头添加0，这种运算被称为零扩展。

要将一个补码数字转换为一个更大的数据类型，需要在表示的开头添加最高有效位的值，这种运算称为符号扩展。

### 2.2.7 截断数字

当将一个w位的数截断位一个k位数字时，会丢弃高w-k位，得到一个原数字低k位的数字。

截断无符号数：将x截断位k位的x'，则$x'=x\ mod\ 2^k$

截断补码数值：将x截断位k位的x'，则$x'=\ U2T_k(x\ mod\ 2^k)$，即把截断后的数字的最高有效位的权重从$2^{k-1}$转变为$-2^{k-1}$

### 2.2.8 关于有符号数和无符号数的建议

许多无符号运算的细微特性，尤其是有符号数到无符号数的隐式转换，会导致错误或者漏洞的方式。避免这类错误的一种方式就是绝不使用无符号数。比如Java只支持有符号整数，并且要求以补码运算来实现。正常的右移运算符>>被定义为执行算术右移，特殊的右移运算符>>>被指定为执行逻辑右移。

当把字看做是位的集合而没有任何数字意义时，无符号数值是非常有用的。当实现模运算和多精度运算的数学包时，数字是由字的数组来表示的，无符号值也会非常有用。

## 2.3 整数运算

### 2.3.1 无符号加法

对于用w位表示的x和y，定义运算$+^u_w$为无符号加法，该操作将结果截断取低w位。这可以视为 $x+y\ mod\ 2^w$

$x\ +^u_w\ y=\left\{\begin{matrix}x+y & x+y<2^w & 正常 \\ x+y-2^w & 2^w\leqslant x+y<2^{w+1} & 溢出 \end{matrix}\right.$

**算术溢出**，是指完整的整数结果不能放到数据类型的字长限制中去。

**检测无符号数加法中的溢出**：对在范围$0\leqslant x,y\leqslant UMax_w$中的x和y，令$s=x+^u_wy$。则对计算s，当且仅当s < x (或者等价地s < y)时，发生了溢出。

模数加法形成了阿贝尔群，即它是可交换和可结合的。它有一个单位元0，并且对每个元素有一个加法逆元。

**无符号数求反**：对满足$0\leqslant x<2^w$的任意x，其w位的无符号逆元$-^u_wx$(即$x-^u_wx=0$)为：$-^u_wx=\left\{\begin{matrix}x & x=0 \\ 2^w-x & x>0\end{matrix}\right.$

### 2.3.2 补码加法

两个数的w位补码之和与无符号之和有完全相同的位级表示。大多及计算机使用相同的机器指令来执行无符号或者有符号加法。

对于用w位表示的x和y，通过将x+y截断到w位避免数据大小的不断扩张。

$x+^t_wy=\left\{\begin{matrix}x+y-2^w & 2^{w-1}\leqslant x+y & 正溢出 \\ x+y & -2^{w-1}\leqslant x+y<2^{w-1} & 正常 \\ x+y+2^w & x+y<-2^{w-1} 负溢出\end{matrix}\right.$

**检测补码加法中的溢出**：对满足$TMin_w\leqslant x,y\leqslant TMax_w$的x和y，令$s=x+^t_wy$。当且仅当x>0，y>0，但s<=0时，计算s发生了正溢出。当且仅当x<0，y<0，但s>=0时，计算s发生了负溢出。

### 2.3.3 补码的非

对满足$TMin_w\leqslant x\leqslant TMax_w$的x，其补码的非为：$-^t_wx=\left\{\begin{matrix}TMin_w & x=TMin_w \\ -x & x>TMin_w\end{matrix}\right.$

计算一个位级表示的值的补码非：* 对每一位求补，再对结果+1。在C语言中，对任意整数x，-x=~x+1。* 结社k是最右边的1的位置，对位k(不含)左边的所有位取反。(如果没有1，则-0=0)

### 2.3.4 无符号乘法

范围在$0\leqslant x,y\leqslant 2^w-1$内的整数x和y可以被表示为w位的无符号数，但乘积x\*y的取值范围为0到$(2^w-1)^2=2^{2w}-2^{w+1}+1$之间，可能需要2w位来表示。

C语言中的无符号乘法被定义为产生w位的值，就是2w位的整数乘积的低w位表示的值

$x*^u_wy=(x*y)\ mod\ 2^w$

### 2.3.5 补码乘法

范围在$-2^{w-1}\leqslant x,y\leqslant 2^{w-1}-1$内的整数x和y可以被表示为w位的补码数字，但乘积x\*y的取值范围为$-2^{w-1}*(2^{w-1}-1)=-2^{2w-2}+2^{w-1}$到$-2^{w-1}*-2^{w-1}=-2^{2w-2}$之间，可能需要2w位来表示。

C语言中的有符号乘法被定义为产生w位的值，就是2w位的整数乘积的低w位表示的值

$x*^t_wy=U2T_w((x*y)\ mod\ 2^w)$

对于无符号数和补码表示的数字，乘法运算的位级表示(截断后)都是一样的。

### 2.3.6 乘以常数

整数乘法指令需要多个时钟周期，而其他整数运算(例如加法、减法、位级运算和移位)只需要一个时钟周期。因此编译器尝试用移位和加法运算来代替乘以常数因子的乘法。

乘以2的幂：舍x为w位的无符号整数，那么对于任意k>=0，$x2^k$的w+k位无符号表示为在x右侧添加k个0。

与2的幂相乘的无符号/补码乘法：无符号/补码数值x和无符号数值k，且0 <= k < w,则$x<<k=x*^u_w2^k=x*^t_w2^k$。即使溢出的时候，通过移位得到的结果也是一样的。

eg：x*14 = (x<<3)+(x<<2)+(x<<1) = (x<<4)-(x<<1)

### 2.3.7 除以2的幂

在大多数机器上，整数除法要比整数乘法更慢。

无符号和补码数分别使用逻辑右移和算术右移来实现除以2的幂。整数除法总是舍入到零，正值向下舍入，负值向上舍入。

除以2的幂的无符号除法：$x>>k=\left \lfloor \frac{x}{2^k} \right \rfloor$

除以2的幂的补码除法，向下舍入：$x>>k=\left \lfloor \frac{x}{2^k} \right \rfloor$

除以2的幂的补码除法，向上舍入：$(x+(1<<k)-1)>>k=\left \lceil \frac{x}{2^k} \right \rceil$。

对于使用算术右移的补码机器：`(x < 0 ? x + (1 << k) - 1 : x) >> k`将会计算$\frac{x}{2^k}$

向上舍入通过在移位之前加上偏置(biasing)来修正向下舍入。对于不需要舍入的情况，加上偏置量只影响被移除的位，对于需要舍入的情况，加上偏置量导致较高的位加一，所以结果会向零舍入。

偏置技术利用如下属性：$\left \lceil \frac{x}{y}\right \rceil=\left \lfloor \frac{x+y-1}{y}\right \rfloor$。设x=qy+r，当y整除x时，$\left \lfloor \frac{x+y-1}{y}\right \rfloor=q$，否则$\left \lfloor \frac{x+y-1}{y}\right \rfloor=q+1$

### 2.3.8 关于整数运算的最后思考

计算机执行的“整数”运算实际上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围，运算结果可能溢出。补码表示提供了一种既能表示负数也能表示正数的灵活方法，同时使用了与执行无符号算术相同的位级实现，这些运算包括像加法、减法、乘法，甚至除法，无论运算数是以无符号形式还是以补码形式表示的，都有完全一样或者非常类似的位级行为。

## 2.4 浮点数

### 2.4.1 二进制小数

表示方法$b_{m}b_{m-1}…b_{1}b_{0}.b_{-1}b_{-2}…b_{-n-1}b_{-n}$表示的数b的**定义**为：$b=\sum^m_{i=-n}2^i*b_i$。

符号“.”为二进制的点，点左侧的位的权是2的正幂，点右边的位的权是2的负幂。

二进制小数点向左移动一位(数字右移)相当于这个数被2除，向右移动一位(数字左移)相当于这个数乘2。

形如$0.11…1_2$的数表示的是刚好小于1的数，比如$0.111111_2$表示$\frac{63}{64}$，用简单的表达法1.0-ε表示这样的数值。

仅考虑有限长度的编码，小数的二进制表示法只能表示那些能够被写成$x*2^y$的数。其他的值只能够被近似地表示。增加二进制表示的长度可以提高表示的精度。

**将$\frac{x}{2^k}$表示为二进制小数形式**：将x使用二进制表示，然后插入小数点使小数点右侧有k位

### 2.4.2 IEEE浮点表示

IEEE浮点标准用$V=(-1)^s*2^E*M$的形式来表示一个数：
* 符号：s决定这个数是负数(s=1)还是正数(s=0)，而对于数值0的符号位解释作为特殊情况处理。
* 阶码：E的作用是对浮点数加权，这个权重是2的E次幂(可能是负数)。
* 尾数：M是一个二进制小数，它的范围是1~2-ε，或者是0~1-ε。

将浮点数的位表示划分为三个字段，分别对这些值进行编码：
* 一个单独的符号位s直接编码符号s。
* 阶码域：k位的阶码字段 $exp=e_{k-1}…e_1e_0$ 编码阶码E
* 小数域：n位小数字段 $frac=f_{n-1}…f_1f_0$ 编码尾数M，但是编码出来的值也依赖于阶码字段的值是否等于零。
    * 在单精度浮点格式(C语言中的float)中，s、exp和frac字段分别为1位、k=8位和n=23位，得到一个32位的表示。
    * 在双精度浮点格式(C语言中的double)中，s、exp和frac字段分别为1位、k=11位和n=52位，得到一个64位的表示。

给定位的表示，根据阶码exp的表示，被编码的值可以分成三种不同的情况：

1. 格式化的值：

当阶码exp的位模式既不全为0也不全为1时，阶码字段被解释为偏置形式表示的有符号整数。也就是说，阶码的值是E=e-Bias，其中e是无符号数，其位表示为$e_{k-1}…e_1e_0$。

Bias是一个等于$2^{k-1}-1$(k-1个1，单精度是127，双精度是1023)的偏置值。由此产生的指数的取值范围，对于单精度是-126~+127，而对于双精度是-1022~+1023。

小数字段frac被解释为描述小数值f，其中0<=f<1，其二进制表示为 $0.f_{n-1}…f_1f_0$，也就是二进制小数点在最高有效位的的左边。尾数的定义为M=1+f。有时这种方式也叫作隐含的以1开头的表示，因为可以把M看成一个二进制表达式为$1.f_{n-1}…f_1f_0$的数字。能够通过调整阶码E，使得尾数M在范围1<=M<2之中(假设没有溢出)。

2. 非格式化的值：

当阶码域exp全为0时，所表示的数时非格式化的。

在这种情况下，阶码值是E=1-Bias，尾数的值是M=f，也就是小数字段的值，不包含隐含的开头的1.

非规格化数有两个用途：

* 提供了一种表示数值0的方法。因为使用规格化数，必须总是使M>=1，因此不能表示0。实际上，+0.0的浮点表示的位模式为全0:符号位是0，阶码字段全为0(表明是一个非规格化值)，而小数域也全为0，这就得到M=f=0。当符号位为1，而其他域全为0时，我们得到值-0.0。根据IEEE的浮点格式，值+0.0和-0.0在某些方面被认为是不同的，而在其他方面是相同的。

* 表示那些非常接近于0.0的数。它们提供了一种属性，称为逐渐溢出，其中，可能的数值分布均匀地接近于0.0。

3. 特殊值：当阶码exp全为1的时候。

   * 当小数域frac全为0时，得到的值表示无穷，当s=0时是+∞，当s=1时是-∞。当我们把两个非常大的数相乘，或者除以零时，无穷能够表示溢出的结果。
   * 当小数域frac为非零时，结果值表示"NaN"，即"Not a Number"的缩写。一些运算的结果不能是实数或∞，就会返回这样的NaN值，比如$\sqrt{-1}$或∞-∞。或者在某些应用中国表示未初始化的数据。

### 2.4.3 数字示例

8位浮点数格式的示例，其中阶码k=4，小数位n=3，偏置量是$2^{4-1}-1=7$

|描述|位表示|exp|E|$2^E$|frac|M|$2^E*M$|V|十进制|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|0|0 0000 000|0|-6|$\frac{1}{64}$|$\frac{0}{8}$|$\frac{0}{8}$|$\frac{0}{512}$|0|0.0|
|最小的非格式化数|0 0000 001|0|-6|$\frac{1}{64}$|$\frac{1}{8}$|$\frac{1}{8}$|$\frac{1}{512}$|$\frac{1}{512}$|0.001953|
||0 0000 010|0|-6|$\frac{1}{64}$|$\frac{2}{8}$|$\frac{2}{8}$|$\frac{2}{512}$|$\frac{1}{256}$|0.003906|
||0 0000 011|0|-6|$\frac{1}{64}$|$\frac{3}{8}$|$\frac{3}{8}$|$\frac{3}{512}$|$\frac{3}{512}$|0.005859|
||...|||||||||
|最大的非格式化数|0 0000 111|0|-6|$\frac{1}{64}$|$\frac{7}{8}$|$\frac{7}{8}$|$\frac{7}{512}$|$\frac{7}{512}$|0.013672|
|---|---|---|---|---|---|---|---|---|---|
|最小的规格化数|0 0001 000|1|-6|$\frac{1}{64}$|$\frac{0}{8}$|$\frac{8}{8}$|$\frac{8}{512}$|$\frac{1}{64}$|0.015625|
||0 0001 001|1|-6|$\frac{1}{64}$|$\frac{1}{8}$|$\frac{9}{8}$|$\frac{9}{512}$|$\frac{9}{512}$|0.017578|
||...|||||||||
||0 0110 110|6|-1|$\frac{1}{2}$|$\frac{6}{8}$|$\frac{14}{8}$|$\frac{14}{16}$|$\frac{7}{8}$|0.875|
||0 0110 111|6|-1|$\frac{1}{2}$|$\frac{7}{8}$|$\frac{15}{8}$|$\frac{15}{16}$|$\frac{15}{16}$|0.9375|
|1|0 0111 000|7|0|1|$\frac{0}{8}$|$\frac{8}{8}$|$\frac{8}{8}$|1|1.0|
||0 0111 001|7|0|1|$\frac{1}{8}$|$\frac{9}{8}$|$\frac{9}{8}$|$\frac{9}{8}$|1.125|
||0 0111 010|7|0|1|$\frac{2}{8}$|$\frac{10}{8}$|$\frac{10}{8}$|$\frac{5}{4}$|1.25|
||...|||||||||
||0 1110 110|14|7|128|$\frac{6}{8}$|$\frac{14}{8}$|$\frac{1792}{8}$|224|224.0|
|最大的规格化数|0 1110 111|14|7|128|$\frac{7}{8}$|$\frac{15}{8}$|$\frac{1920}{8}$|240|240.0|
|---|---|---|---|---|---|---|---|---|---|
|无穷大|0 1111 000|-|-|-|-|-|-|∞|-|

可以观察到最大非规格化数$\frac{7}{512}$和最小规格化数$\frac{8}{512}$之间的平滑转变。这种平滑性归功于对非规格化数的E的定义。通过将E定义为1-Bias，而不是-Bias，可以补偿非规格化数的尾数没有隐含的开头的1。

当增大阶码和尾数超出最大规格化数V=240时，就会溢出到+∞。

IEEE格式的浮点数，非负数的位表达式解释为无符号整数时，浮点数和无符号整数都是升序排列。因此浮点数能够使用整数排序函数来进行排序。当处理负数时，浮点数有开头的1，并且是按照降序出现的，但是不需要浮点运算进行比较也能解决这个问题。

非负浮点数示例
|描述|位 exp frac|单精度值|单精度十进制|双精度值|双精度十进制|
|:-:|:-:|:-:|:-:|:-:|:-:|
|0|0 00...00 0...00|0|0.0|0|0.0|
|最小非规格化数|0 00...00 0...01|$2^{-23}*2^{-126}$|$1.4*10^{-45}$|$2^{-52}*2^{-1022}$|$4.9*10^{-324}$|
|最大非规格化数|0 00...00 1...11|$(1-ε)*2^{-126}$|$1.2*10^{-38}$|$(1-ε)*2^{-1022}$|$2.2*10^{-308}$|
|最小规格化数|0 00...01 0...00|$1*2^{-126}$|$1.2*10^{-38}$|$1*2^{-1022}$|$2.2*10^{-308}$|
|1|0 01...11 0...00|$1*2^0$|1.0|$1*2^0$|1.0|
|最大规格化数|0 11...10 1...11|$(2-ε)*2^{127}$|$3.4*10^{38}$|$(2-ε)*2^{1023}$|$1.8*10^{308}$|

* 值＋0.0总有一个全为0的位表示。* 最小的正非规格化值的位表示，是由最低有效位为1而其他所有位为0构成的。它具有小数(和尾数)值$M=frac=2^{-n}$和阶码值$E=-2^{k-1}＋2$。因此它的数字值是$V=2^{-n-2^{k-1}+2}$。* 最大的非规格化值的位模式是由全为0的阶码字段和全为1的小数字段组成的。它有小数(和尾数)值$M=frac=1-2^{-n}$(我们写成1-ε)和阶码值$E=-2^{k-1}+2$。因此，数值$V=(1-2^{-n})*2^{-2^{k-1}+2}$，这仅比最小的规格化值小一点。* 最小的正规格化值的位模式的阶码字段的最低有效位为1，其他位全为0。它的尾数值frac=0，M=1，而阶码值$E=—2^{k-1}+2$。因此，数值$V=2^{-2^{k-1}+2}$。* 值1.0的位表示的阶码字段除了最高有效位等于0以外，其他位都等于1。它的尾数值frac=0，M=1，而它的阶码值是E=0。* 最大的规格化值的位表示的符号位为0，阶码的最低有效位等于0，其他位等于1。它的小数值$f=1—2^{-n}$，尾数$M=2-2^{-n}$(我们写作2-ε)。它的阶码值$E=2^{k-1}-1$，得到数值$V=(2-2^{-n})×2^{2^{k-1}-1}=(1-2^{-n-1})×2^{2^{k-1}}$。

**整数值转换为浮点形式**：将整数表示为二进制形式，将小数点左移n位使得小数点前一位为二进制表示中的最高有效位1。为了用IEEE形式来编码，丢弃小数点前一位的1，并在末尾添加m个零来构造小数字段(当为32位时，使得m+n=23，当为64位时，使得m+n=52)。为了构造阶码字段，用左移的位数n加上偏置量(当为32位时，Bias=127，当为64位时，Bias=1023)。加上符号位0，就得到二进制的浮点表示。

### 2.4.4 舍入
舍入运算的任务：因为百世方法限制了浮点数的范围和精度，
所以浮点运算只能近似地表示实数运算。因此，对于值x，一般使用以中国系统的方法，能够找到"最接近的"匹配值x'，它可以用期望的浮点形式表示出来。IEEE浮点格式定义了四种不同的舍入方式：

* 向偶数舍入：也被称为向最接近的值舍入，是默认的方式，试图找到一个最接近的匹配值。唯一个设计决策是确定两个可能结果中间数值的舍入效果，它将数字向上或向下舍入，使得结果的最低有效数字是偶数。

* 向零舍入：把正数向下舍入，把负数向上舍入，得到值$\hat{x}$，使得$|\hat{x}\leqslant |x|$

* 向下舍入：把正数和负数都向下舍入，得到值$x^-$，使得$x^- \leqslant x$

* 向上舍入：把正数和负数都向上舍入，得到值$x^+$，使得$x \leqslant x^+$

向偶数舍入的一个优势是求一组数的平均值时，在大多数现实情况中不会引入统计偏差。

当不想舍入到整数时，也可以使用向偶数舍入，只考虑最低有效数字是奇数还是偶数。当数字不在两个相数中间时向更靠近的数舍入，当在中间时向偶数舍入。

向偶数舍入法能够运用在二级制上，将最低有效位的值0认为是偶数，值1认为是奇数。一般来说，只有对形如XX…X.YY…Y100…的二进制位模式的数，这种舍入方式才有效，其中X和Y表示任意位值，最右边的Y是要被舍入的值(即舍入后的最低有效位)。只有这种位模式表示在两个可能的结果正中间的值。

### 2.4.5 浮点运算

IEEE规定，把浮点值x和y看成实数，运算$\bigodot$定义在实数上，计算将产生$Round(x \bigodot y)$，这是对实际运算的精确结果进行舍入后的结果。

IEEE标准定义$\frac{1}{-0}=-∞$，$\frac{1}{+0}=+∞$，$+∞-∞=NaN$，$NaN+^fx=NaN$

* 加法：

将$x+^fy$定义为$Round(x+y)$。这个运算的定义针对x和y的所有取值，但是由于溢出，该运算可能得到无穷值。

对于所有的x和y的值，这个运算是可交换的，但是是不可结合的。

大多数数值在浮点加法下都是有逆元的，即$x+^f-x=0$。无穷(+∞-∞=NaN)和NaN($NaN+^fx=NaN$)例外

浮点加法满足**单调性**：如果a>=b，对任何a,b和x，除了NaN，都有x+a>=x+b。无符号或补码加法不具备这个事实(和整数)加法的属性。

* 乘法：

将$x*^fy$定义为$Round(x*y)$。这个运算的在乘法中是封闭的(虽然可能产生∞或NaN)，但是由于溢出，该运算可能得到无穷值。

乘法是可交换的，但是是不可结合的(可能发生溢出或由于舍入而损失精度)，浮点乘法在加法上不具备分配性。

对任何不为NaN的a，b和c，浮点乘法满足**单调性**：
1. $a \geqslant b且c \geqslant 0 \Rightarrow a*^fc \geqslant b*^fc$，
2. $a \geqslant b且c \leqslant 0 \Rightarrow a*^fc \leqslant b*^fc$，
3. $a \neq NaN \Rightarrow a*^fa \geqslant 0$，无符号或补码的乘法没有这些单调性属性。

### 2.4.6 C语言中的浮点数

所有的C语言版本提供了两种不同的浮点数据类型:float和 double。在支持IEEE浮点格式的机器上，这些数据类型就对应于单精度和双精度浮点。另外，这类机器使用向偶数舍入的舍入方式。不幸的是，因为C语言标准不要求机器使用IEEE浮点，所以没有标准的方法来改变舍入方式或者得到诸如-0、+∞、-∞或者NaN之类的特殊值。

当在int、float和double格式之间进行强制类型转换时，程序改变数值和位模式的原则如下(假设int是32位的):* 从int转换成float，数字不会溢出，但是可能被舍入。* 从int或float转换成double，因为double有更大的范围(也就是可表示值的范围)，也有更高的精度(也就是有效位数)，所以能够保留精确的数值。* 从double转换成float，因为范围要小一些，所以值可能溢出成+∞或-∞。另外，由于精确度较小，它还可能被舍入。* 从float或者double转换成int，值将会向零舍入(将小数部分截断丢弃)。进一步来说，值可能会溢出。C语言标准没有对这种情况指定固定的结果。

## 2.5 小结

计算机将信息编码为位(比特)，通常组织成字节序列。有不同的编码方式用来表示整数、实数和字符串。不同的计算机模型在编码数字和多字节数据中的字节顺序时使用不同的约定。

C语言的设计可以包容多种不同字长和数字编码的实现。64位程序的优势是可以突破32位程序具有的4GB地址限制。

大多数机器对整数使用补码编码，而对浮点数使用IEEE标准754编码。在位级上理解这些编码，并且理解算术运算的数学特性，对于想使编写的程序能在全部数值范围上正确运算的程序员来说，是很重要的。

在相同长度的无符号和有符号整数之间进行强制类型转换时，大多数C语言实现遵循的原则是底层的位模式不变。在补码机器上，对于一个w位的值，这种行为是由函数$T2U_w$和$U2T_w$来描述的。C语言隐式的强制类型转换会出现许多程序员无法预计的结果，常常导致程序错误

由于编码的长度有限，与传统整数和实数运算相比，计算机运算具有非常不同的属性。当超出表示范围时，有限长度能够引起数值溢出。当浮点数非常接近于0.0，从而转换成零时，也会下溢。

和大多数其他程序语言一样，C语言实现的有限整数运算和真实的整数运算相比，有一些特殊的属性。例如，由于溢出，表达式x\*x能够得出负数。但是，无符号数和补码的运算都满足整数运算的许多其他属性，包括结合律、交换律和分配律。这就允许编译器做很多的优化。例如，用(x<<3)-x取代表达式7\*x时，我们就利用了结合律、交换律和分配律的属性，还利用了移位和乘以2的幂之间的关系。

我们已经看到了几种使用位级运算和算术运算组合的聪明方法。例如，使用补码运算，~x+1等价于-x。另外一个例子，假设我们想要一个形如\[0，…，0，1，…，1]的位模式(由w-k个0后面紧跟着k个1组成)。这些位模式有助于掩码运算。这种模式能够通过C表达式`(1<<k)-1`生成，利用的是这样一个属性，即我们想要的位模式的数值为$2^k-1$。

浮点表示通过将数字编码为$x*2^y$的形式来近似地表示实数。最常见的浮点表示方式是由IEEE标准754定义的。它提供了几种不同的精度，最常见的是单精度(32位)和双精度(64位)。IEEE浮点也能够表示特殊值+∞、-∞和NaN。

必须非常小心地使用浮点运算，因为浮点运算只有有限的范围和精度，而且并不遵守普遍的算术属性，比如结合性。
