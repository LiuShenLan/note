- [8. 计算机网络中的安全](#8-计算机网络中的安全)
	- [8.1 什么是网络安全](#81-什么是网络安全)
	- [8.2 密码学的原则](#82-密码学的原则)
		- [8.2.1 对称密钥密码体制(对称加密)](#821-对称密钥密码体制对称加密)
		- [8.2.2 公开密钥加密(非对称加密)](#822-公开密钥加密非对称加密)
			- [8.2.2.1 RSA](#8221-rsa)
			- [8.2.2.2 会话密钥](#8222-会话密钥)
	- [8.3 报文完整性和数字签名](#83-报文完整性和数字签名)
		- [8.3.1 密码散列函数](#831-密码散列函数)
		- [8.3.2 报文鉴别码(MAC)](#832-报文鉴别码mac)
		- [8.3.3 数字签名](#833-数字签名)
	- [8.4 端点鉴别](#84-端点鉴别)
	- [8.5 安全电子邮件](#85-安全电子邮件)
		- [8.5.1 安全电子邮件](#851-安全电子邮件)
		- [8.5.2 PGP](#852-pgp)
	- [8.6 使TCP连接安全：SSL](#86-使tcp连接安全ssl)
		- [8.6.1 宏观描述](#861-宏观描述)
		- [8.6.2 更完整的描述](#862-更完整的描述)
	- [8.7 网络层安全性：IPsec和虚拟专用网](#87-网络层安全性ipsec和虚拟专用网)
		- [8.7.1 IPsec和虚拟专用网](#871-ipsec和虚拟专用网)
		- [8.7.2 AH协议和ESP协议](#872-ah协议和esp协议)
		- [8.7.3 安全关联](#873-安全关联)
		- [8.7.4 IPsec数据报](#874-ipsec数据报)
		- [8.7.5 IKE：IPsec中的密钥管理](#875-ikeipsec中的密钥管理)
	- [8.8 使无线LAN安全](#88-使无线lan安全)
		- [8.8.1 有线等效保密](#881-有线等效保密)
		- [8.8.2 IEEE 802.11i](#882-ieee-80211i)
	- [8.9 运行安全性：防火墙和入侵检测系统](#89-运行安全性防火墙和入侵检测系统)
		- [8.9.1 防火墙](#891-防火墙)
		- [8.9.2 入侵检测系统](#892-入侵检测系统)
	- [8.10 小结](#810-小结)

# 8. 计算机网络中的安全

## 8.1 什么是网络安全

安全通信特性：

* **机密性**：仅有发送方和希望的接收方能够理解传输报文的内容。因为窃听者可以截获报文，这必须要求报文在一定程度上进行加密，使截取的报文无法被截获者所理解。我们将在[8.2 密码学的原则](#82-密码学的原则)中学习数据加密和解密的密码学技术

* **报文完整性**：Alice和Bob希望确保其通信的内容在传输过程中未被改变——或者恶意篡改或者意外改动。我们将在[8.3 报文完整性和数字签名](#83-报文完整性和数字签名)中研究该主题

* **端点鉴别**：发送方和接收方都应该能证实通信过程所涉及的另一方，以确信通信的另一方确实具有其所声称的身份。我们将在[8.4 端点鉴别](#84-端点鉴别)中学习端点鉴别技术

* **运行安全性**：攻击者能够试图在网络主机中安放蠕虫，获取公司秘密，勘察内部网络配置并发起DoS攻击。我们将在[8.9 运行安全性：防火墙和入侵检测系统](#89-运行安全性防火墙和入侵检测系统)中看到诸如防火墙和入侵检测系统等运行设备正被用于反制对机构网络的攻击。防火墙位于机构网络和公共网络之间，控制接入和来自网络的分组。入侵检测系统执行"深度分组检查"任务，向网络管理员发出有关可疑活动的警告

入侵者能够执行安全攻击：

* 监听并记录信道上传输的控制报文和数据报文

* 修改、插入或删除报文或报文内容

* 假冒另一个实体

* 劫持一个正在进行的会话，通过使系统资源过载拒绝合法网络用户的服务请求

## 8.2 密码学的原则

明文：报文的最初形式

密文：使用加密算法加密明文，生成的加密报文

密钥$K_A$：一串数字或字符，作为加密算法的输入，加密算法以密钥$K_A$和明文m为输入，生成的密文$K_A(m)$作为输出

对称密钥系统：双方的密钥是相同的并且是秘密的，对称加密

公开密钥系统：使用一对密钥，一个密钥为公钥，另一个为私钥，私钥只有其中一方知道，非对称加密

### 8.2.1 对称密钥密码体制(对称加密)

1. 破解加密方案的难易程度分类

**唯密文攻击**：有些情况下，入侵者只能得到截取的密文，也不了解明文报文的内容。统计分析有助于对加密方案的唯密文攻击

**已知明文攻击**：当入侵者知道(明文，密文)的一些匹配时，我们将其称为对加密方案的已知明文攻击

**选择明文攻击**：在选择明文攻击中，入侵者能够选择某一明文报文并得到该明文报文对应的密文形式。对于更为复杂的加密技术来说，使用选择明文攻击不一定意味着能够攻破该加密机制

2. 块密码

对称加密技术有两种宽泛的类型:**流密码**和**块密码**。当我们研究无线LAN的安全性时，将在[8.7 网络层安全性：IPsec和虚拟专用网](#87-网络层安全性ipsec和虚拟专用网)中简要地研究流密码。在本节中，我们关注块密码，该密码用在多种因特网协议的加密中，包括[PGP](#852-pgp)(用于安全电子邮件)、[SSL](#86-使tcp连接安全ssl)(用于使TCP连接更安全)和[IPsec](#87-网络层安全性ipsec和虚拟专用网)(用于使网络层传输更安全)

**加密方法**：在块密码中，要加密的报文被处理为k比特的块。例如，如果k=64则报文被划分为64比特的块，每块被独立加密。为了加密一个块，该密码采用了一对一映射，将k比特块的明文映射为k比特块的密文

**函数模拟随机排列表**：如刚才所述，尽管全表块密码对于不大的k值能够产生健壮的对称密钥加密方案，但不幸的是它们空间需求大，修改困难，难以实现。块密码通常使用函数模拟随机排列表。例如当k=64时，该函数首先将64比特块划分为8个块，每个块由8比特组成。每个8比特块由一个"8比特到8比特"表处理，这是个可管理的长度。例如，第一个块由标志为$T_1$的表来处理。接下来，这8个输出块被重新装配成一个64比特的块。该输出被回馈到64比特的输入，开始了第二次循环。经n次这样的循环后，该函数提供了一个64比特的密文块。这种循环的目的是使得每个输入比特影响最后输出比特的大部分(即使不是全部)(如果仅使用一次循环，一个给定的输入比特将仅影响64比特中的8比特)。这种块密码算法的密钥将是8张排列表(假定之乱函数是公共已知的)

3. 密码块链接(CBC)技术

**引入随机性**：注意到两个或更多个明文块可能是相同的，对于这些相同的块，块密码将产生相同的密文。为了解决这个问题，可以在密文中混合某些随机性，使得相同的明文块产生不同的密文块。为了解释这个想法，令m(i)表示第i个明文块，c(i)表示第i个密文块，并且a⊕b表示两个比特串α和b的异或(XOR)(0⊕0=1⊕1=0和0⊕1=1⊕0=1,并且两个比特串的异或是逐位进行的)。另外，将具有密钥S的块密码加密算法表示为$K_s$。其基本思想如下:发送方为第i块生成一个随机的k比特数r(i)，并且计算$c(i)=K_s(m(i)⊕r(i))$。注意到每块选择一个新的k比特随机数。则发送方发送c(1)、r(1)、c(2)、r(2)、c(3)和r(3)等等。因为接收方接收到c(i)和r(i)，它能够通过计算$m(i)=K_s(c(i)⊕r(i))$而恢复每个明文块。重要的是注意到下列事实:尽管r(i)是以明文发送的，并且因此能被入侵者嗅探到，但它无法获得明文m(i)，因为它不知道密钥$K_s$。同时注意到如果两个明文块m(i)和m(j)是相同的，对应的密文块c(i)和c(j)将是不同的(只要随机数r(i)和r(i)不同，这种情况出现的概率将很高)。

**引入随机性带来的问题**：发送方必须传输以前两倍的比特。对每个加密比特，发送方必须再发送一个随机比特，使需要的带宽加倍。


**基本思想**：仅随第一个报文发送一个随机值，然后让发送方和接收方使用计算的编码块代替后继的随机数

**过程**：

1、在加密报文(或数据流)之前，发送方生成一个随机的k比特串，称为初始向量IV)。将该初始向量表示为c(0)。发送方以明文方式将IV发送给接收方

2、对第一个块，发送方计算m(1)⊕c(0)，即计算第一块明文与IV的异或。然后通过块密码算法运行得到的结果以得到对应的密文块，即$c(1)=K_s(m(1)⊕c(0))$。发送方向接收方发送加密块c(1)

3、对于第i个块，发送方根据$c(i)=K_s(m(i)⊕c(i-1))$生成第i个密文块

**效果**：

1、接收方将仍能够恢复初始报文。$s(i)=K_s(c(i))=m(i)⊕c(i-1)$；因为接收方已经知道c(i-1)，则从m(i)=s(i)⊕c(i-1)获得明文块

2、即使两个明文块是相同的，相应的密文块也(几乎)总是不同的

3、 虽然发送方以明文发送IV，入侵者将仍不能解密密文块,因为该入侵者不知道秘密密钥S

4、发送方仅发送一个最前面的块(即IV)，因此对(由数百块组成的)长报文而言增加的带宽用量微不足道

**注意**：CBC需要在协议中提供一种机制，以从发送方向接收方分发IV

### 8.2.2 公开密钥加密(非对称加密)

**概念**：信息发送方(A)与信息接收方(B)并未共享一个密钥(如同在对称密钥系统情况下)，而B(A报文的接收方)则有两个密钥，一个是世界上任何人都可得到的公钥$K^+_B$，另一个是只有B知道的私钥$K^-_B$。为了与B通信，A首先取得B的公钥，然后用这个公钥和一个众所周知的加密算法，加密它要传递给B的报文m；即A计算$K^+_B(m)$。B接收到A的加密报文后，用其私钥和一个众所周知的解密算法解密A的加密报文，即B计算$K^-_B(K^+_B(m))$。存在着可以选择公钥和私钥的加密/解密算法和技术，使得$K^-_B(K^+_B(m))=m$；也就是说，用B的公钥$K^+_B$加密报文m(得到$K^+_B(m)$)，然后再用B的私钥$K^-_B$解密报文的密文形式(就是计算$K^-_B(K^+_B(m))$)就能得到最初的明文m。用这种办法，A可以使用B公开可用的密钥给B发送机密信息，而他们任一方都无须分发任何密钥。同时公钥和私钥相互交换同样能够实现通信，即$K^-_B(K^+_B(m))=K^+_B(K^-_B(m))=m$

**注意**：因为入侵者知道B的公钥，因此入侵者可以使用已知的标准加密算法和B公开可用的加密所用的算法对入侵者自己所选择的任意报文进行编码，从而发起选择明文攻击。其次，既然B的加密密钥是公开的，任何人都可能向B发送一个已加密的报文。在单一共享密钥情况下，发送方知道共享秘密密钥的事实就已经向接收方隐含地证实了发送方的身份。然而在公钥体制中，这点就行不通了，因为任何一个人都可向B发送使用B的公开可用密钥加密的报文。这就需要用数字签名把发送方和报文绑定起来，数字签名是[8.3 报文完整性和数字签名](#83-报文完整性和数字签名)中讨论的主题。

#### 8.2.2.1 RSA

**引论**：

1. $[(a \% n) + (b \% n)] \% n = (a + b) \%n$

2. $[(a \% n) - (b \% n)] \% n = (a - b) \%n$

3. $[(a \% n) * (b \% n)] \% n = (a * b) \%n$

4. $(a \% n)^d \% n = a^d \%n$

5. 如果p和q是素数，且n=pq，z=(p-1)(q-1)，则$x^y \%n = x^{y \% z} \% n$

**组成**：公钥和私钥的选择、加密和解密算法

**密钥生成步骤**：

1. 选择两个大素数p和q(该值越大，破解RSA越困难，执行加密和解密所用的时间就越长，RSA实验室推荐p和q的乘积为1024比特的数量级)

2. 计算n=pq和z=(p-1)(q-1)

3. 选择小于n的一个数e，使e与z互素

4. 选择一个数d，使得$(ed-1)\%z=0$，即$(ed)\%z=1$

5. 公钥$K^+_B$即为(n, e)，私钥$K^-_B$为(n, d)

**加密过程**：明文为m，要求m < n，密文$c=m^e\%n$

**解密过程**：密文为c，明文$m=c^d\%n$

**原理**：$c^d\%n=(m^e\%n)^d\%n=^{引论4}=(m^{ed})\%n=^{引论5}=(m^{ed\%z})\%n=m^1\%n=m$。同时，如果颠倒加密与解密顺序，即先用d进行解密操作，再用e进行加密操作，同样可以恢复出明文m

#### 8.2.2.2 会话密钥

因为RSA运算耗费时间，所以A向B发送大量加密数据时，可以A选择一个用于加密数据本身的密钥，此密钥称为**会话密钥**$K_S$，这个密钥是对称密钥密码中所使用的共享对称密钥。A使用B的RSA公钥$K^+_B$加密该会话密钥$K_S$，即计算$c=K^+_B(K_S)=(K_S)^e\%n$，B收到经过加密的会话密钥c后，解密得到会话密钥$K_S$

## 8.3 报文完整性和数字签名

报文完整性定义：收到的报文确实来自正确的发送方，并且在途中没有被篡改

### 8.3.1 密码散列函数

**定义**：散列函数以m为输入，并计算得到一个称为散列的固定长度的字符串H(m)

**性质**：找到任意两个不同的报文x和y，使得H(x)=H(y)在计算上是不可能的

**MD5散列算法**：通过4步过程计算得到128比特的散列

1. 填充：先填1，然后填足够多的0，直到报文长度满足一定的条件

2. 添加：在填充前添加一个用64比特表示的报文长度

3. 初始化累加器

4. 循环：在最后的循环步骤中,对报文的16字块进行4轮处理

### 8.3.2 报文鉴别码(MAC)

**鉴别密钥s**：发送方A和接收方B共享的一个比特串s，用于帮助接收方鉴别发送方身份

**报文完整性实现步骤**：

1. 发送方A生成明文报文m，使用鉴别密钥s级联m以生成m+s，并计算散列值H(m+s)，H(m+s)即为报文鉴别码MAC

2. 发送方A将MAC附加到报文m上，生成扩展报文(m, H(m+s))，并将该扩展报文发送给接收方B

3. 接收方B接收到扩展报文(m, h)，计算报文鉴别码H(m+s)，如果H(m+s)=h，则接收方确定该报文的完整性

**MAC优点**：不要求一种加密算法，通信实体仅关心报文完整性，不关心报文机密性

**问题**：如何向通信实体分发共享的鉴别密钥s

### 8.3.3 数字签名

**性质**：数字签名必须是可证实的，并且该签名是无法伪造的(能够证明某人在文件上的签名是本人签署的，并且有且只有该人可以签署)

**生成方式**：B使用私钥$K^-_B$对文档m计算得到$K^-_B(m)$

**验证方式**：使用B的公钥$K^+_B$对$K^-_B(m)$计算即可得到原文m，同时在计算$K^-_B(m)$时使用了B的私钥$K^-_B$，并且该私钥有且只有B持有

**完整性保障**：如果源文档m被修改过变为m'，则B对m生成的签名对m'无效，因为$K^+_B(K^-_B(m))!=m'$。因此数字签名可以使得接收方验证该报文未被篡改，同时也验证了该报文的源

**引入散列**：因为加密和解密的计算代价昂贵，所以可以将散列函数引入数字签名。对于明文m，发送方B首先使用散列函数生成H(m)，B对报文的散列H(m)签名，计算得到$K^-_B(H(m))$，而不是对报文m本身签名，降低了计算量

MAC与数字签名对比↓：

||MAC|数字签名|
|:-:|:-:|:-:|
|作用对象|报文m|报文m|
|附加信息|鉴别密钥s|×|
|计算散列|√|√|
|密钥加密|×|√|

* **公钥认证**

**作用**：证实一个公钥属于某个特定的实体。要使公钥密码有用，需要能够证实公钥实际上就是要进行通信的实体的公钥，而不是他人冒充的

**认证中心CA**：使得识别和发行证书合法化

**CA作用**：

1. CA证实一个实体(人、路由器等)的真实身份(如何进行认证并没有强制的过程)

2. 一旦CA验证了某个实体的身份，这个CA会生成一个将其身份和实体的公钥绑定起来的证书。这个证书包含这个公钥和公钥所有者全局唯一的身份标识信息(一个人的名字或IP地址等)。由CA使用CA的私钥$K^-_{CA}$对这个证书进行数字签名

## 8.4 端点鉴别

**端点鉴别**就是一个实体经过计算机网络向另一个实体证明其身份的过程。鉴别应当在报文和数据交换的基础上作为**鉴别协议**的一部分独立完成。鉴别协议通常在两个通信实体运行其他协议之前运行。鉴别协议首先建立相互满意的各方的标识，仅当鉴别完成之后，各方才继续下面的工作

入侵者能够执行**安全攻击**：

1. IP哄骗：伪装自己的IP源地址等

2. 窃听通信，获取未加密的登录口令等

3. 回放攻击：窃听通信并记录加密的口令，并向接收方回放口令的加密版本

**不重数**：在一个协议的生存期中只使用一次的数(TCP三次握手中的随机初始序号)

**不重数使用方法**：

1. 发送方A向接收方B发送识别信息

2. B选择一个不重数R，然后将R发送给A

3. A使用A与B共享的对称加密密钥$K_S$加密不重数，然后将加密的不重数$K_S(R)$发送给B

4. B解密接收到的报文，如果解密得到的不重数与步骤2中发送的相同，则可确定发送方是A(发送方使用了共享对称加密密钥$K_S$)，并且A是活跃的(A加密了随机不重数)

## 8.5 安全电子邮件

### 8.5.1 安全电子邮件

**需要的安全特性**：机密性、发送方鉴别、报文完整性、接收方鉴别，参考[8.1 什么是网络安全](#81-什么是网络安全)

**机密性实现**：

1. 发送方A选择一个随机对称会话密钥$K_S$

2. A用这个对称密钥加密报文m得到$K_S(m)$

3. A用接收方B的公钥$K^+_B$加密这个对称密钥得到$K^+_B(K_S)$

4. A级联该加密的报文$K_S(m)$和加密的对称密钥$K^+_B(K_S)$以形成一个"包"

5. A向B的电子邮件地址发送这个包

6. 当B接收到这个包时，使用其私钥$K^-_B$得到对称密钥$K_S$，使用这个对称密钥$K_S$解密报文m

**发送方鉴别与报文完整性实现**：

1. 发送方A对它要发送的报文m应用一个散列函数H(例如MD5)，从而得到一个报文摘要H(m)

2. A用它的私钥$K^-_A$对散列函数的结果，从而得到一个数字签名$K^-_A(H(m))$

3. A把初始报文(未加密)和该数字签名级联起来生成一个包

4. A向接收方B的电子邮件地址发送这个包

5. 当B接收到这个包时，B将A的公钥$K^+_A$应用到被签名的报文摘要$K^-_A(H(m))$上，将该操作的结果与B自己对该报的散列H(m)进行比较

**机密性、发送方鉴别与报文完整性综合实现**：

* 发送方A：1-3同发送方鉴别与报文完整性实现，4-7同机密性实现

	1. A准备初始报文m，使用散列函数对初始报文计算得到报文摘要H(m)

	2. A用它的私钥$K^-_A$对散列函数的结果，从而得到一个数字签名$K^-_A(H(m))$

	3. A把初始报文(未加密)和该数字签名级联起来生成一个包$n=m+K^-_A(H(m))$

	4. A选择一个随机对称会话密钥$K_S$

	5. A用这个对称密钥加密包n得到$K_S(n)$

	6. A用接收方B的公钥$K^+_B$加密这个对称密钥得到$K^+_B(K_S)$

	7. A级联该加密的报文$K_S(n)$和加密的对称密钥$K^+_B(K_S)$以形成要发送的数据$K_S(n)+K^+_B(K_S)$

* 接收方B：1、2同机密性实现，3、4同发送方鉴别与报文完整性实现

	1. B使用自己的私钥$K^-_B$解密$K^+_B(K_S)$得到对称密钥$K_S$
	2. B使用对称密钥$K_S$解密$K_S(n)$得到包$n=m+K^-_A(H(m))$
	3. B使用A的公钥$K^+_A$解密$K^-_A(H(m))$得到H(m)
	4. B对m进行散列计算，将结果与第三步中的结果对比

* 注意，A在发送时使用了自己的私钥与B的公钥，B在接收时使用了自己的私钥与A的公钥

### 8.5.2 PGP

PGP是电子邮件加密方案的一个范例

## 8.6 使TCP连接安全：SSL

**安全套接字层(SSL)**：密码技术用安全性服务加强的TCP服务，安全性服务包括机密性、数据完整性和端点鉴别。SSL版本3的一个稍加修改的版本称为**运输层安全性(TLS)**

http使用TCP，https使用SSL

TCP的API为IP->TCP(TCP套接字)->应用程序，SSL的API为IP->TCP(TCP套接字)->SSL子层(SSL套接字)->应用程序。因为SSL使TCP安全，因此SSL能被应用于运行在TCP之上的任何应用程序

### 8.6.1 宏观描述

SSL的简化版本的工作过程具有三个阶段：握手、密钥导出和数据传输。以下描述客户端B和服务器端A之间的通信会话的这三个阶段，其中A具有私钥/公钥对和将它的身份与其公钥绑定的证书

1. 握手：

在握手阶段，客户端需要与服务器端创建一条TCP连接->验证服务器端是真实的服务器端->发送给服务器端一个主密钥，客户端B和服务器端A持用该主密钥生成SSL会话所需的所有对称密钥

注意TCP三次握手之后，客户端就向服务器端发送一个SSL hello报文，服务器端则用它的证书进行响应，证书中包含了它的公钥(因为该证书已经被CA证实过，客户端确定该公钥属于服务器端)。然后客户端产生一个主密钥MS(该MS将仅用于这个SSL会话)，用服务器端的公钥加密该MS以生成加密的主密钥EMS，并将该EMS发送给服务器端。服务器端用私钥解密该EMS从而得到该MS

2. 密钥导出

对于客户端和服务端而言，使用不同的密码密钥，并且对于加密和完整性检查也使用不同的密钥，通常认为更为安全，因此客户端和服务端都使用MS生成四个密钥

* $E_B$：用于从客户端B发送到服务器端A的数据的会话加密密钥

* $M_B$：用于从客户端B发送到服务器端A的数据的会话MAC密钥

* $E_A$：用于从服务器端A发送到客户端B的数据的会话加密密钥

* $M_A$：用于从服务器端A发送到客户端B的数据的会话MAC密钥

在密钥导出阶段结束时，客户端和服务器端都有四个密钥，其中两个加密密钥将用于加密数据，两个MAC密钥将用于验证数据的完整性

3. 数据传输

SSL将数据流分割成记录，对每个记录附加一个MAC用于完整性检查，然后加密该"记录+MAC"。为了产生这个MAC，客户端B将数据连同密钥$M_B$放入一个散列函数中，如在[8.3 报文完整性和数字签名](#83-报文完整性和数字签名)所讨论。为了加密"记录+MAC"这个包，客户端B使用他的会话加密密钥$E_B$。然后这个加密的包将传递给TCP经因特网传输

为了防止报文段被插入、删除或者替代，SSL中会使用序号。客户端B维护一个序号计数器，计数器开始为0，客户端B每发送的一个SSL记录，计数器都增加1.客户端B并不实际在记录中包括一个序号，但当客户端B计算MAC时，他会把该序号包括在MAC的计算中，所以，该MAC现在是数据+MAC密钥$M_B$+当前序号的散列值(此时MAC密钥$M_B$即可认为是鉴别密钥s？)。服务器端A跟踪客户端B的序号，通过在MAC的计算中包括适当的序号，使服务器端A验证一条记录的完整性。SSL序号的使用阻止了诸如重排序或重放报文段等中间人攻击

4. SSL记录

SSL记录为：类型字段、版本字段、长度字段、数据字段以及MAC字段组成

仅有数据字段与MAC字段使用$E_B$加密

类型字段指出该字段是握手报文还是包含应用数据的报文，也用于关闭SSL连接

### 8.6.2 更完整的描述

**SSL握手**：

1. 客户发送它支持的密码算法的列表,连同一个客户的不重数

2. 从该列表中，服务器选择一种对称加密算法(例如AES)、一种公钥算法(例如具有特定密钥长度的RSA)和一种MAC算法。它把它的选择以及证书和一个服务器不重数返回给客户

3. 客户验证该证书，提取服务器的公钥，生成一个前主密钥(PMS)，用服务器的公钥加密该PMS，并将加密的PMS发送给服务器

4. 使用相同的密钥导出函数，客户和服务器独立地从PMS和不重数中计算出主密钥(MS)。然后该MS被切片以生成两个密码和两个MAC密钥。此外，当选择的对称密码应用于CBC，则两个初始化向量(IV)也从该MS获得，这两个IV分别用于该连接的两端。自此以后，客户和服务器之间发送的所有报文均被加密和鉴别(使用MAC)

5. 客户发送所有握手报文的一个MAC

6. 服务器发送所有握手报文的一个MAC

最后两个步骤使握手免受篡改危害。在第一步中，客户通常提供一个算法列表，其中有些算法强，有些算法弱。因为这些加密算法和密钥还没有被协商好，所以算法的这张列表以明文形式发送。中间人能够从列表中删除较强的算法，迫使客户选择一种较弱的算法。为了防止这种篡改攻击，在步骤5中客户发送一个它已发送和接收的所有握手报文的MAC。服务器能够比较这个MAC与它已接收和发送的握手报文的MAC。如果有不一致，服务器能够终止该连接。类似地，服务器发送一个它已经看到的握手报文的MAC，允许客户检查不一致性

在SSL中，序号用于防御在一个进行中的会话中重放个别分组，而不重数用于防御在不同时间重放整个连接

**连接关闭**：

在某个时刻，客户端B或者服务器端A将要终止SSL会话。一个方法是让客户端B通过直接终止底层的TCP连接来结束该SSL会话，这就是说，通过让客户端B向服务器端A发送一个TCP FIN报文段。但是这种设计为截断攻击创造了条件，中间人再一次介入一个进行中的SSL会话中，并用TCP FIN过早地结束了该会话。如果中间人这样做的话，服务器端A将会认为她收到了客户端B的所有数据，而实际上她仅收到了其中的一部分。对这个问题的解决方法是，在类型字段中指出该记录是否是用于终止该SSL会话的(尽管SSL类型是以明文形式发送的，但在接收方使用了记录的MAC对它进行了鉴别)。通过包括这样一个字段，如果服务器端A在收到一个关闭SSL记录之前突然收到了一个TCP FIN，服务器端A可以确定此次断开不正常

## 8.7 网络层安全性：IPsec和虚拟专用网
### 8.7.1 IPsec和虚拟专用网
### 8.7.2 AH协议和ESP协议
### 8.7.3 安全关联
### 8.7.4 IPsec数据报
### 8.7.5 IKE：IPsec中的密钥管理

## 8.8 使无线LAN安全
### 8.8.1 有线等效保密
### 8.8.2 IEEE 802.11i

## 8.9 运行安全性：防火墙和入侵检测系统
### 8.9.1 防火墙
### 8.9.2 入侵检测系统

## 8.10 小结

安全通信包含如下机制：机密性(因此只有他们才能理解传输的报文内容)、端点鉴别(因此他们确信正在与对方交谈)和报文完整性(因此他们确信在传输过程中他们的报文未被篡改)。可以在网络体系结构中的各个层次使用安全性，使之免受采用各种各样攻击手段的坏家伙们的侵扰

本章前面部分给出了安全通信所依赖的各种原理。在[8.2 密码学的原则](#82-密码学的原则)中，我们涉及了加密和解密数据的密码技术，包括对称密钥密码和公开密钥密码。作为今天网络中两种重要的密码技术的特定的学习案例，我们考察了DES和RSA

在[8.3 报文完整性和数字签名](#83-报文完整性和数字签名)中，我们研究了提供报文完整性的两种方法:[报文鉴别码(MAC)](#832-报文鉴别码mac)和[数字签名](#833-数字签名)。这两种方法有一些共同之处。它们都使用了密码散列函数，这两种技术都使我们能够验证报文的源以及报文自身的完整性。一个重要的差异是MAC不依赖于加密，而数字签名要求公钥基础设施。如我们在8.5~8.8节所见，这两种技术广泛在实际中都得到了广泛应用。此外，数字签名用于生成数字证书，数字证书对于证实公钥的合法性是重要的。在[8.4 端点鉴别](#84-端点鉴别)中，我们考察了端点鉴别并引入了不重数以防御重放攻击

在8.5~8.8节中，我们研究了几种在实践中得到广泛使用的安全性网络协议。我们看到了对称密钥密码在PGP、SSL、IPsec和无线安全性中的核心地位。我们看到了公开密钥密码对PGP和SSL是至关重要的。我们看到PGP使用数字签名而SSL和IPsec使用MAC来保证报文完整性。在目前理解了密码学的基本原理以及学习了这些原理的实际应用方法之后，你现在已经有能力设计你自己的安全网络协议了!

利用8.2~8.4节所包含的技术，Bob和Alice就能够安全通信了。而机密性仅是整个网络安全的一小部分。如我们在[8.9 运行安全性：防火墙和入侵检测系统](#89-运行安全性防火墙和入侵检测系统)节中所学习，现在网络安全的焦点越来越多地关注网络基础设施的安全性，以防止"坏家伙"的潜在猛烈攻击。在本章的后面部分，我们因此学习了防火墙和IDS系统，它们检查进入和离开一个机构网络的分组
