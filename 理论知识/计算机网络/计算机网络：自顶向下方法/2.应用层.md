- [2. 应用层](#2-应用层)
	- [2.1 应用层协议原理](#21-应用层协议原理)
		- [2.1.1 网络应用程序体系结构](#211-网络应用程序体系结构)
		- [2.1.2 进程通信](#212-进程通信)
		- [2.1.3 可供应用程序使用的运输服务](#213-可供应用程序使用的运输服务)
		- [2.1.4 因特网提供的运输服务](#214-因特网提供的运输服务)
		- [2.1.5 应用层协议](#215-应用层协议)
		- [2.1.6 本书涉及的网络应用](#216-本书涉及的网络应用)
	- [2.2 Web和HTTP](#22-web和http)
		- [2.2.1 HTTP概况](#221-http概况)
		- [2.2.2 非持续连接和持续连接](#222-非持续连接和持续连接)
		- [2.2.3 HTTP报文格式](#223-http报文格式)
		- [2.2.4 用户与服务器的交互：cookie](#224-用户与服务器的交互cookie)
		- [2.2.5 Web缓存](#225-web缓存)
		- [2.2.6 条件GET方法](#226-条件get方法)
	- [2.3 因特网中的电子邮件](#23-因特网中的电子邮件)
		- [2.3.1 SMTP](#231-smtp)
		- [2.3.2 与HTTP的对比](#232-与http的对比)
		- [2.3.3 邮件报文格式](#233-邮件报文格式)
		- [2.3.4 邮件访问协议](#234-邮件访问协议)
	- [2.4 DNS(域名系统)：因特网的目录服务](#24-dns域名系统因特网的目录服务)
		- [2.4.1 DNS提供的服务](#241-dns提供的服务)
		- [2.4.2 DNS工作机理概述](#242-dns工作机理概述)
		- [2.4.3 DNS记录和报文](#243-dns记录和报文)
	- [2.5 P2P文件分发](#25-p2p文件分发)
	- [2.6 视频流和内容分发网(CDN)](#26-视频流和内容分发网cdn)
		- [2.6.1 因特网视频](#261-因特网视频)
		- [2.6.2 HTTP流和DASH](#262-http流和dash)
		- [2.6.3 内容分发网(CDN)](#263-内容分发网cdn)
	- [2.7 套接字编程：生成网络应用](#27-套接字编程生成网络应用)
		- [2.7.1 UDP套接字编程](#271-udp套接字编程)
		- [2.7.2 TCP套接字编程](#272-tcp套接字编程)
	- [2.8 小结](#28-小结)

# 2. 应用层

## 2.1 应用层协议原理

研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序。当研发新应用程序时，你需要编写将在多台端系统上运行的软件。该软件能够用如C、Java或Python来编写。重要的是，你不需要写在网络核心设备如路由器或链路层交换机上运行的软件。即使你要为网络核心设备写应用程序软件，你也不能做到这一点。网络核心设备并不在应用层上起作用，而仅在较低层起作用，特别是在网络层及下面层次起作用。这种将应用软件限制在端系统的基本设计，促进了大量的网络应用程序的迅速研发和部署

### 2.1.1 网络应用程序体系结构

应用程序的体系结构明显不同于网络的体系结构。从应用程序研发者的角度看，网络体系结构是固定的，并为应用程序提供了特定的服务集合。在另一方面，**应用程序体系结构** 由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序。在选择应用程序体系结构时，应用程序研发者很可能利用现代网络应用程序中所使用的两种主流体系结构之一：客户-服务器体系结构或对等(P2P)体系结构

* **客户-服务器体系结构**：

在客户-服务器体系结构中，有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求。利用客户-服务器体系结构，客户相互之间不直接通信；客户-服务器体系结构的另一个特征是该服务器具有固定的、周知的地址，该地址称为IP地址。因为该服务器具有固定的、周知的地址，并且因为该服务器总是打开的，客户总是能够通过向该服务器的IP地址发送分组来与其联系。具有客户-服务器体系结构的非常著名的应用程序包括Web、FTP、Telnet和电子邮件

在一个客户-服务器应用中，常常会出现一台单独的服务器主机跟不上它所有客户请求的情况。为此，配备大量主机的**数据中心**常被用于创建强大的虚拟服务器

* **P2P体系结构**：

在一个P2P体系结构中，对位于数据中心的专用服务器有最小的(或者没有)依赖。相反，应用程序在间断连接的主机对之间使用直接通信，这些主机对被称为对等方。这些对等方并不为服务提供商所有，相反却为用户控制端系统所有。因为这种对等方通信不必通过专门的服务器，该体系结构被称为对等方到对等方的。需要提及的是，某些应用具有混合的体系结构，它结合了客户-服务器和P2P的元素。例如，对于许多即时讯息应用而言，服务器被用于跟踪用户的IP地址，但用户到用户的报文在用户主机之间(无须通过中间服务器)直接发送

P2P体系结构的最引人入胜的特性之一是它们的**自扩展性**。例如，在一个P2P文件共享应用中，尽管每个对等方都由于请求文件产生工作负载，但每个对等方通过向其他对等方分发文件也为系统增加服务能力。P2P体系结构也是有成本效率的，因为它们通常不需要庞大的服务器基础设施和服务器带宽(这与具有数据中心的客户-服务器设计形成鲜明对比)。然而，未来P2P应用由于高度非集中式结构，面临安全性、性能和可靠性等挑战

### 2.1.2 进程通信

一个进程可以被认为是运行在端系统中的一个程序。当多个进程运行在相同的端系统上时，它们使用进程间通信机制相互通信。进程间通信的规则由端系统上的操作系统确定

在两个不同端系统上的进程，通过跨越计算机网络交换报文(message)而相互通信。发送进程生成并向网络中发送报文；接收进程接收这些报文并可能通过回送报文进行响应

1. 客户和服务器进程

网络应用程序由成对的进程组成，这些进程通过网络相互发送报文

在一对进程之间的通信会话场景中，发起通信(即在该会话开始时发起与其他进程的联系)的进程被标识为**客户**，在会话开始时等待联系的进程是**服务器**

2. 进程与计算机网络之间的接口

进程通过一个称为**套接字**的软件接口向网络发送报文和从网络接收报文

套接字是同一台主机内应用层与运输层之间的接口。由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的**应用程序编程接口(Application Programming Interface，API)**。应用程序开发者可以控制套接字在应用层端的一切，但是对该套接字的运输层端几乎没有控制权。应用程序开发者对于运输层的控制仅限于：1.选择运输层协议；2.也许能设定几个运输层参数，如最大缓存和最大报文段长度等(将在[第3章 运输层](3.运输层.md)中涉及)。一旦应用程序开发者选择了一个运输层协议(如果可供选择的话)，则应用程序就建立在由该协议提供的运输层服务之上。我们将在[2.7 套接字编程：生成网络应用](#27-套接字编程生成网络应用)中对套接字进行更为详细的探讨

3. 进程寻址

在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个地址。为了标识该接收进程，需要定义两种信息：1.主机的地址；2.在目的主机中指定接收进程的标识符

在因特网中，主机由其**IP地址**标识。我们将在[第4章 网络层：数据平面](4.网络层：数据平面.md)中非常详细地讨论IP地址。此时，我们只要知道IP地址是一个32比特的量且它能够唯一地标识该主机就够了。除了知道报文发送目的地的主机地址外，发送进程还必须指定运行在接收主机上的接收进程(更具体地说，接收套接字)。因为一般而言一台主机能够运行许多网络应用，这些信息是需要的。目的地**端口号(port number**)用于这个目的。已经给流行的应用分配了特定的端口号。我们将在[第3章 运输层](3.运输层.md)中详细学习端口号

### 2.1.3 可供应用程序使用的运输服务

我们大体能够从四个方面对应用程序服务要求进行分类：可靠数据传输、吞吐量、定时和安全性

1. 可靠数据传输

分组在计算机网络中可能丢失。例如，分组能够使路由器中的缓存溢岀，或者当分组中的某些比特损坏后可能被丢弃。为了保证数据不丢失，必须做一些工作以确保由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端。如果一个协议提供了这样的确保数据交付服务，就认为提供了**可靠数据传输**。运输层协议能够潜在地向应用程序提供的一个重要服务是进程到进程的可靠数据传输。当一个运输协议提供这种服务时，发送进程只要将其数据传递进套接字，就可以完全相信该数据将能无差错地到达接收进程

当一个运输层协议不提供可靠数据传输时，由发送进程发送的某些数据可能到达不了接收进程。这可能能被容忍丢失的应用所接受，最值得注意的是多媒体应用，如交谈式音频/视频，它们能够承受一定量的数据丢失。在这些多媒体应用中，丢失的数据引起播放的音频/视频出现小干扰，而不是致命的损伤

2. 吞吐量

在沿着一条网络路径上的两个进程之间的通信会话场景中，可用吞吐量就是发送进程能够向接收进程交付比特的速率。因为其他会话将共享沿着该网络路径的带宽，并且因为这些会话将会到达和离开，该可用吞吐量将随时间波动。这些观察导致另一种自然的服务，即运输层协议能够以某种特定的速率提供确保的可用吞吐量。使用这种服务，该应用程序能够请求r比特/秒的确保吞吐量，并且该运输协议能够确保可用吞吐量总是为至少r比特/秒。这样的确保吞吐量的服务将对许多应用程序有吸引力具有吞吐量要求的应用程序被称为**带宽敏感的应用**。许多当前的多媒体应用是带宽敏感的，尽管某些多媒体应用程序可能采用自适应编码技术对数字语音或视频以与当前可用带宽相匹配的速率进行编码

带宽敏感的应用具有特定的吞吐量要求，而**弹性应用**能够根据当时可用的带宽或多或少地利用可供使用的吞吐量

3. 定时

运输层协议也能提供定时保证。如同具有吞吐量保证那样，定时保证能够以多种形式实现。很多实时服务为了有效性而要求数据交付有严格的时间限制。对于非实时的应用，较低的时延总比较高的时延好，但对端到端的时延没有严格的约束

4. 安全性

最后，运输协议能够为应用程序提供一种或多种安全性服务。例如，在发送主机中，运输协议能够加密由发送进程传输的所有数据，在接收主机中，运输层协议能够在将数据交付给接收进程之前解密这些数据。这种服务将在发送和接收进程之间提供机密性，以防该数据以某种方式在这两个进程之间被观察到。运输协议还能提供除了机密性以外的其他安全性服务，包括数据完整性和端点鉴别，我们将在[第8章 计算机网络中的安全](8.计算机网络中的安全.md)中详细讨论这些主题

### 2.1.4 因特网提供的运输服务

1. TCP服务

TCP服务模型包括面向连接服务和可靠数据传输服务。当某个应用程序调用TCP作为其运输协议时，该应用程序就能获得来自TCP的这两种服务

* 面向连接的服务：在应用层数据报文开始流动之前，TCP让客户和服务器互相交换运输层控制信息。这个所谓的握手过程提醒客户和服务器，让它们为大量分组的到来做好准备。在握手阶段后，一个TCP连接就在两个进程的套接字之间建立了。这条连接是全双工的，即连接双方的进程可以在此连接上同时进行报文收发。当应用程序结束报文发送时，必须拆除该连接。在[第3章 运输层](3.运输层.md)中我们将详细讨论面向连接的服务，并分析它是如何实现的

* 可靠的数据传送服务：通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。当应用程序的一端将字节流传进套接字时，它能够依靠TCP将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余

TCP协议还具有拥塞控制机制，这种服务不一定能为通信进程带来直接好处，但能为因特网带来整体好处。当发送方和接收方之间的网络出现拥塞时，TCP的拥塞控制机制会抑制发送进程(客户或服务器)。如我们将在[第3章 运输层](3.运输层.md)所见，TCP拥塞控制也试图限制每个TCP连接，使它们达到公平共享网络带宽的目的

TCP安全：无论TCP还是UDP都没有提供任何加密机制，这就是说发送进程传进其套接字的数据，与经网络传送到目的进程的数据相同。因特网界已经研制了TCP的加强版本，称为安全套接字层(SSL)。用SSL加强后的TCP不仅能够做传统的TCP所能做的一切，而且提供了关键的进程到进程的安全性服务，包括加密、数据完整性和端点鉴别。我们强调SSL不是与TCP和UDP在相同层次上的第三种因特网运输协议，而是一种对TCP的加强，这种强化是在应用层上实现的。特别是，如果一个应用程序要使用SSL的服务，它需要在该应用程序的客户端和服务器端包括SSL代码(利用现有的、高度优化的库和类)。我们将在[第8章 计算机网络中的安全](8.计算机网络中的安全.md)中更为详细地讨论SSL

2. UDP服务

UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。UDP是无连接的，因此在两个进程通信前没有握手过程。UDP协议提供一种不可靠数据传送服务，也就是说，当进程将一个报文发送进UDP套接字时，UDP协议并不保证该报文将到达接收进程。不仅如此，到达接收进程的报文也可能是乱序到达的

UDP没有包括拥塞控制机制，所以UDP的发送端可以用它选定的任何速率向其下层(网络层)注入数据(然而，值得注意的是实际端到端吞吐量可能小于该速率，这可能是因为中间链路的带宽受限或因为拥塞而造成的)

3. 因特网运输协议所不提供的服务

现在的因特网通常能够为时间敏感应用提供满意的服务，但它不能提供任何定时或带宽保证

### 2.1.5 应用层协议

**应用层协议**定义了运行在不同端系统上的应用程序进程如何相互传递报文。特别是应用层协议定义了：1.交换的报文类型，例如请求报文和响应报文；2.各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的；3.字段的语义，即这些字段中的信息的含义；4.确定一个进程何时以及如何发送报文，对报文进行响应的规则

区分网络应用和应用层协议是很重要的。应用层协议只是网络应用的一部分(尽管从我们的角度看，它是应用非常重要的一部分)

### 2.1.6 本书涉及的网络应用

在本章中我们详细讨论5种重要的应用：Web、文件传输、电子邮件、目录服务、流式视频和P2P

Web应用不仅是极为流行的应用，而且它的应用层协议HTTP比较简单并且易于理解

电子邮件比Web更复杂，是因为它使用了多个而不是一个应用层协议

DNS为因特网提供目录服务。大多数用户不直接与DNS打交道，而是通过其他的应用(包括Web、文件传输和电子邮件)间接使用它。DNS很好地说明了一种核心的网络功能(网络名字到网络地址的转换)是怎样在因特网的应用层实现的。

在P2P文件共享应用中通过讨论包括经内容分发网分发存储的视频在内的按需流式视频，结束应用层的学习

## 2.2 Web和HTTP

Web的按需操作：当用户需要时，就能得到所想要的内容

### 2.2.1 HTTP概况

Web的应用层协议是**超文本传输协议(HTTP)**，它是Web的核心。HTTP由两个程序实现：一个客户程序和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式。HTTP规范仅定义了在HTTP客户程序与HTTP服务器程序之间的通信协议

**Web页面(也叫文档**)是由对象组成的。一个**对象(object**)只是一个文件且它们可通过一个URL地址寻址。多数Web页面含有一个**HTML基本文件**以及几个引用对象。例如，如果一个Web页面包含HTML文本和5个JPEG图形，那么这个Web页面有6个对象：一个HTML基本文件加5个图形。HTML基本文件通过对象的URL地址引用页面中的其他对象。每个URL地址由两部分组成：存放对象的服务器主机名和对象的路径名。例如，URL地址`http://www.someSchool.edu/someDepartment/pic­ture.gif`，其中的`www.someSchool.edu`就是主机名，`/someDepartment/picture.gif`就是路径名。因为Web浏览器实现了HTTP的客户端，所以在Web环境中我们经常交替使用"浏览器"和"客户"这两个术语。Web服务器实现了HTTP的服务器端，它用于存储Web对象，每个对象由URL寻址

HTTP定义了Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的方式。其基本思想为当用户请求一个Web页面(如点击一个超链接)时，浏览器向服务器发出对该页面中所包含对象的HTTP请求报文，服务器接收到请求并用包含这些对象的HTTP响应报文进行响应

HTTP使用TCP作为它的支撑运输协议。HTTP客户首先发起一个与服务器的TCP连接。一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问TCP。客户向它的套接字接口发送HTTP请求报文并从它的套接字接口接收HTTP响应报文。类似地，服务器从它的套接字接口接收HTTP请求报文和向它的套接字接口发送HTTP响应报文。一旦客户向它的套接字接口发送了一个请求报文，该报文就脱离了客户控制并进入TCP的控制。TCP为HTTP提供可靠数据传输服务。这意味着，一个客户进程发出的每个HTTP请求报文最终能完整地到达服务器；类似地，服务器进程发出的每个HTTP响应报文最终能完整地到达客户。这里我们看到了分层体系结构最大的优点，即HTTP协议不用担心数据丢失，也不关注TCP从网络的数据丢失和乱序故障中恢复的细节。那是TCP以及协议栈较低层协议的工作

服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息。假如某个特定的客户在短短的几秒内两次请求同一个对象，服务器并不会因为刚刚为该客户提供了该对象就不再做出反应，而是重新发送该对象，就像服务器已经完全忘记不久之前所做过的事一样。因为HTTP服务器并不保存关于客户的任何信息，所以我们说HTTP是一个**无状态协议**。我们同时也注意到Web使用了客户-服务器应用程序体系结构。Web服务器总是打开的，具有一个固定的IP地址，且它服务于可能来自数以百万计的不同浏览器的请求

### 2.2.2 非持续连接和持续连接

在客户-服务器的经TCP的交互中，**非持续连接**是每个请求/相应对是经一个单独的TCP连接发送，**持续连接**是所有的请求及其相应经相同的TCP连接发送

1. 采用非持续连接的HTTP

每个TCP连接在服务器发送一个对象后关闭，即该连接并不为其他的对象而持续下来。值得注意的是每个TCP连接只传输一个请求报文和一个响应报文

**往返时间(RTT)**：一个短分组从客户到服务器然后再返回客户所花费的时间。RTT包括分组传播时延、分组在中间路由器和交换机处的排队时延以及分组处理时延

浏览器在它和Web服务器之间发起一个TCP连接时涉及一次"三次握手"过程，即客户向服务器发送一个小TCP报文段，服务器用一个小TCP报文段做出确认和响应，最后，客户向服务器返回确认。三次握手中前两个部分所耗费的时间占用了一个RTT。完成了三次握手的前两个部分后，客户结合三次握手的第三部分(确认)向该TCP连接发送一个HTTP请求报文。一旦该请求报文到达服务器，服务器就在该TCP连接上发送HTML文件。该HTTP请求/响应用去了另一个RTT。因此，粗略地讲，总的响应时间就是两个RTT加上服务器传输HTML文件的时间

缺点：第一，必须为每一个请求的对象建立和维护一个全新的连接。对于每个这样的连接，在客户和服务器中都要分配TCP的缓冲区和保持TCP变量，这给Web服务器带来了严重的负担，因为一台Web服务器可能同时服务于数以百计不同的客户的请求。第二，每一个对象经受两倍RTT的交付时延，即一个RTT用于创建TCP，另一个RTT用于请求和接收一个对象

2. 采用持续连接的HTTP

在采用HTTP1.1持续连接的情况下，服务器在发送响应后保持该TCP连接打开。在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送

### 2.2.3 HTTP报文格式

1. HTTP请求报文

```
GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr

(data data data ...)(实体体)
```

请求报文由ASCII文本书写，每行由一个回车和换行符结束，第一块后再附加一个回车换行符，后面为实体体(entity body)。一个请求报文能够具有更多的行或者至少为一行

HTTP请求报文的第一行为**请求行(request line)**，有三个字段：方法字段、URL字段和HTTP版本字段。方法字段可以取几种不同的值，包括GET、POST、HEAD、PUT和DELETE，绝大部分的HTTP请求报文使用GET方法，当浏览器请求一个对象时，使用GET方法；在URL字段带有请求对象的标识；其版本字段是自解释的

请求行后继的行是**首部行(header line)**：

首部行`Host: www.someschool.edu`指明了对象所在的主机。你也许认为该首部行是不必要的，因为在该主机中已经有一条TCP连接存在了。但该首部行提供的信息是Web代理高速缓存所要求的

通过包含`Connection: close`首部行，该浏览器告诉服务器不要麻烦地使用持续连接，它要求服务器在发送完被请求的对象后就关闭这条连接

`User-agent: Mozilla/5.0`首部行用来指明用户代理，即向服务器发送请求的浏览器的类型。这里浏览器类型是`Mozilla/5.0`，即Firefox浏览器。这个首部行是有用的，因为服务器可以有效地为不同类型的用户代理实际发送相同对象的不同版本(每个版本都由相同的URL寻址)

`Accept-language: fr`首部行表示用户想得到该对象的法语版本(如果服务器中有这样的对象的话)；否则服务器应当发送它的默认版本。`Accept-language:`首部行仅是HTTP中可用的众多内容协商首部之一

在首部行后面为**实体体**，使用GET方法时实体体为空，而使用POST方法时才使用该实体体。当用户提交表单时，HTTP客户常常使用POST方法，例如当用户向搜索引擎提供搜索关键词时。使用POST报文时，用户仍可以向服务器请求一个Web页面，但Web页面的特定内容依赖于用户在表单字段中输入的内容。如果方法字段的值为POST时，则实体体中包含的就是用户在表单字段中的输入值。

当然用表单生成的请求报文不一定必须使用POST方法。HTML表单经常使用GET方法，并在(表单字段中)所请求的URL中包括输入的数据。例如，一个表单使用GET方法，它有两个字段，分别填写的是"monkeys"和"bananas"，这样，该URL结构为`www.somesite.com/animalsearch?monkeys&bananas`

HEAD方法类似于GET方法。当服务器收到一个使用HEAD方法的请求时，将会用一个HTTP报文进行响应，但是并不返回请求对象。应用程序开发者常用HEAD方法进行调试跟踪。PUT方法常与Web发行工具联合使用，它允许用户上传对象到指定的Web服务器上指定的路径(目录)。PUT方法也被那些需要向Web服务器上传对象的应用程序使用。DELETE方法允许用户或者应用程序删除Web服务器上的对象

2. HTTP响应报文

```
HTTP/1.1 200 OK
Connection: close
Date Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3(CentOS)
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html

(data data data ...)(实体体)
```

HTTP响应报文的第一行为**状态行**，状态行有3个字段：协议版本字段、状态码和相应状态信息。在这个例子中，状态行指示服务器正在使用HTTP/1.1，并且一切正常(即服务器已经找到并正在发送所请求的对象)

请求行后继的行是**首部行(header line)**：

服务器用`Connection: close`首部行告诉客户，发送完报文后将关闭该TCP连接

`Date Tue, 18 Aug 2015 15:44:04 GMT`首部行指示服务器产生并发送该响应报文的日期和时间。值得一提的是，这个时间不是指对象创建或者最后修改的时间，而是服务器从它的文件系统中检索到该对象，将该对象插入响应报文，并发送该响应报文的时间

`Server: Apache/2.2.3(CentOS)`首部行指示该报文是由一台Apache Web服务器产生的，它类似于HTTP请求报文中的`User-agent:`首部行

`Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT`首部行指示了对象创建或者最后修改的日期和时间。`Last-Modified:`首部行对既可能在本地客户也可能在网络缓存服务器上的对象缓存来说非常重要。我们将很快详细地讨论缓存服务器(也叫代理服务器)

`Content-Length: 6821`首部行指示了被发送对象中的字节数

`Content-Type: text/html`首部行指示了实体体中的对象是HTML文本(该对象类型应该正式地由`Content-Type:`首部行而不是用文件扩展名来指示)


状态码及其相应的短语指示了请求的结果，一些常见的状态码和相关的短语如下所示↓：

|状态码|相应短语|
|:-:|:-:|
|200 OK|请求成功，信息在返回的响应报文中|
|301 Moved Permanently|请求的对象已经被永久转移了</br>新的URL定义在响应报文的`Location:`首部行中</br>客户软件将自动获取新的URL|
|400 Bad Request|一个通用差错代码，指示该请求不能被服务器理解|
|404 Not Found|被请求的文档不在服务器上|
|505 HTTP Version Not Supported|服务器不支持请求报文使用的HTTP协议版本|

浏览器产生的首部行与很多因素有关，包括浏览器的类型和协议版本、浏览器的用户配置、浏览器当前是否有一个缓存的但是可能超期的对象版本。Web服务器的表现也类似：在产品、版本和配置上都有差异，所有这些都会影响响应报文中包含的首部行

### 2.2.4 用户与服务器的交互：cookie

HTTP使用了cookie。cookie允许站点对用户进行跟踪。目前大多数商务Web站点都使用了cookie

cookie技术有4个组件：1.在HTTP响应报文中的一个cookie首部行；2.在HTTP请求报文中的一个cookie首部行；3.在用户端系统中保留有一个cookie文件，并由用户的浏览器进行管理；4位于Web站点的一个后端数据库

cookie的工作过程如下↓：

用户首次与某Web站点联系。当请求报文到达该Web服务器时，该Web站点将产生一个唯一识别码，并以此作为索引在它的后端数据库中产生一个表项。接下来Web服务器用一个包含`Set-cookie:`首部的HTTP响应报文对用户的浏览器进行响应，其中`Set-cookie:`首部含有该识别码。例如，该首部行可能是`Set-cookie: 1678`

当用户的浏览器收到了该HTTP响应报文时，它会看到该`Set-cookie:`首部。该浏览器在它管理的特定cookie文件中添加一行，该行包含服务器的主机名和在`Set-cookie:`首部中的识别码。值得注意的是该cookie文件已经有了用户过去访问过的其他站点的表项。当用户继续浏览网站时，每请求一个Web页面，其浏览器就会查询该cookie文件并抽取用户对这个网站的识别码，并放到HTTP请求报文中包括识别码的cookie首部行中，
特别是用户对该Web服务器的每个HTTP请求报文都包括以下首部行`Cookie: 1678`

在这种方式下，Web服务器可以跟踪用户在Web站点的活动。尽管Web站点不必知道用户的名字，但它确切地知道用户1678按照什么顺序、在什么时间、访问了哪些页面

如果用户再次访问Web站点，比如说一个星期后，她的浏览器会在其请求报文中继续放入首部行`Cookie: 1678`。Web将根据用户过去在Web访问的网页向用户推荐产品。如果用户也在Web注册过，即提供了用户的全名、电子邮件地址、邮政地址和信用卡账号，则Web服务器能在其数据库中包括这些信息，将用户的名字与识别码相关联(以及用户在过去访问过的本站点的所有页面)

从上述讨论中我们看到，cookie可以用于标识一个用户。用户首次访问一个站点时，可能需要提供一个用户标识(可能是名字)。在后继会话中，浏览器向服务器传递一个cookie首部，从而向该服务器标识了用户。因此cookie可以在无状态的HTTP之上建立一个用户会话层

### 2.2.5 Web缓存

**Web缓存器(Web cache**)也叫**代理服务器(proxy server)它是能够代表初始Web服务器来满足HTTP请求的网络实体。Web缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。可以配置用户的浏览器，使得用户的所有HTTP请求首先指向Web缓存器。一旦某浏览器被配置，每个对某对象的浏览器请求首先被定向到该Web缓存器

* 浏览器配置Web缓存器后请求对象`http://www.someschool.edu/campus.gif`的情况如下↓：

	1. 浏览器创建一个到Web缓存器的TCP连接，并向Web缓存器中的对象发送一个HTTP请求

	2. Web缓存器进行检查，看看本地是否存储了该对象副本。如果有，Web缓存器就向客户浏览器用HTTP响应报文返回该对象

	3. 如果Web缓存器中没有该对象，它就打开一个与该对象的初始服务器(即`http://www.someschool.edu`)的TCP连接。Web缓存器则在这个缓存器到服务器的TCP连接上发送一个对该对象的HTTP请求。在收到该请求后，初始服务器向该Web缓存器发送具有该对象的HTTP响应

	4. 当Web缓存器接收到该对象时，它在本地存储空间存储一份副本，并向客户的浏览器用HTTP响应报文发送该副本(通过现有的客户浏览器和Web缓存器之间的TCP连接)

Web缓存器既是服务器又是客户。当它接收浏览器的请求并发回响应时，它是一个服务器。当它向初始服务器发出请求并接收响应时，它是一个客户

Web缓存器通常由ISP购买并安装。例如，一所大学可能在它的校园网上安装一台缓存器，并且将所有校园网上的用户浏览器配置为指向它。或者，一个主要的住宅ISP(例如Comcast)可能在它的网络上安装一台或多台Web缓存器，并且预先配置其配套的浏览器指向这些缓存器

在因特网上部署Web缓存器有两个原因。首先，Web缓存器可以大大减少对客户请求的响应时间，特别是当客户与初始服务器之间的瓶颈带宽远低于客户与Web缓存器之间的瓶颈带宽时更是如此。如果在客户与Web缓存器之间有一个高速连接(情况常常如此)，并且如果用户所请求的对象在Web缓存器上，则Web缓存器可以迅速将该对象交付给用户。其次，Web缓存器能够大大减少一个机构的接入链路到因特网的通信量。通过减少通信量，该机构(如一家公司或者一所大学)就不必急于增加带宽，因此降低了费用。此外，Web缓存器能从整体上大大减低因特网上的Web流量，从而改善了所有应用的性能

通过使用内容分发网络(CDN)，Web缓存器正在因特网中发挥着越来越重要的作用。CDN公司在因特网上安装了许多地理上分散的缓存器，因而使大量流量实现了本地化。有多个共享的CDN和专用的CDN(例如谷歌和Netflix)。我们将在[2.6 视频流和内容分发网](#26-视频流和内容分发网)节中更为详细地讨论CDN

### 2.2.6 条件GET方法

尽管高速缓存能减少用户感受到的响应时间，但也引入了一个新的问题，即存放在缓存器中的对象副本可能是陈旧的。换句话说，保存在服务器中的对象自该副本缓存在客户上以后可能已经被修改了。幸运的是，HTTP协议有一种机制，允许缓存器证实它的对象是最新的。这种机制就是**条件GET**方法。如果：1.请求报文使用GET方法；2.请求报文中包含一个`If-Modified-Since:`首部行。那么，这个HTTP请求报文就是一个条件GET请求报文

条件GET操作方式如下↓：

首先一个代理缓存器代表一个请求浏览器，想某Web服务器发送一个请求报文：

```
GET /fruit/kiwi.gif HTTP/1.1
Host: www.exotiquecuisine.com
```

其次，该Web服务器向缓存器发送具有被请求的对象的响应报文：

```
HTTP/1.1 200 OK
Date: Sat, 3 Oct 2015 15:39:29
Server: Apache/1.3.0 (Unix)
Last-Modified: Wed, 9 Sep 2015 09:23:24
Content-Type: image/gif

(data data data ...)
```

该缓存器在将对象转发到请求的浏览器的同时，也在本地缓存了该对象。重要的是，缓存器在存储该对象时也存储了最后修改日期。最后，一段时间后，另一个用户经过该缓存器请求同一个对象，该对象仍在这个缓存器中。由于在过去的一个星期中位于Web服务器上的该对象可能已经被修改了，该缓存器通过发送一个条件GET执行最新检查。具体来说，该缓存器发送：

```
GET /fruit/kiwi.gif HTTP/1.1
Host: www.exotiquecuisine.com
If-modified-since: Wed, 9 Sep 2015 09:23:24
```

值得注意的是`If-modified-since:`首部行的值正好等于一星期前服务器发送的响应报文中的`If-modified-since:`首部行的值。该条件GET报文告诉服务器，仅当自指定日期之后该对象被修改过，才发送该对象。假设该对象自2015年9月9日09:23:24后没有被修改。接下来的第四步，Web服务器向该缓存器发送一个响应报文：

```
HTTP/1.1 304 Not Modified
Date: Sat, 10 Oct 2015 15:39:29
Server: Apache/1.3.0 (Unix)

(empty entity body)
```

我们看到，作为对该条件GET方法的响应，该Web服务器仍发送一个响应报文，但并没有在该响应报文中包含所请求的对象。包含该对象只会浪费带宽，并增加用户感受到的响应时间，特别是如果该对象很大的时候更是如此。值得注意的是在最后的响应报文中，状态行中为304 Not Modified，它告诉缓存器可以使用该对象，能向请求的浏览器转发它(该代理缓存器)缓存的该对象副本

## 2.3 因特网中的电子邮件

因特网电子邮件系统有三个主要组成部分：**用户代理**、**邮件服务器**和**简单邮件传输协议(SMTP)**。下面结合发送方Alice发电子邮件给接收方Bob的场景，对每个组成部分进行描述：

用户代理允许用户阅读、回复、转发、保存和撰写报文。当Alice完成邮件撰写时，她的邮件代理向其邮件服务器发送邮件，此时邮件放在邮件服务器的外出报文队列中。当Bob要阅读报文时，他的用户代理在其邮件服务器的邮箱中取得该报文

邮件服务器形成了电子邮件体系结构的核心。每个接收方(如Bob)在其中的某个邮件服务器上有一个邮箱(mailbox)。Bob的邮箱管理和维护着发送给他的报文。一个典型的邮件发送过程是：从发送方的用户代理开始，传输到发送方的邮件服务器，再传输到接收方的邮件服务器，然后在这里被分发到接收方的邮箱中。当Bob要在他的邮箱中读取该报文时，包含他邮箱的邮件服务器(使用用户名和口令)来鉴别Bob。Alice的邮箱也必须能处理Bob的邮件服务器的故障。如果Alice的服务器不能将邮件交付给Bob的服务器，Alice的邮件服务器在一个报文队列(message queue)中保持该报文并在以后尝试再次发送。通常每30分钟左右进行一次尝试；如果几天后仍不能成功，服务器就删除该报文并以电子邮件的形式通知发送方(Alice)

SMTP是因特网电子邮件中主要的应用层协议。它使用TCP可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件。像大多数应用层协议一样，SMTP也有两个部分：运行在发送方邮件服务器的客户端和运行在接收方邮件服务器的服务器端。每台邮件服务器上既运行SMTP的客户端也运行SMTP的服务器端。当一个邮件服务器向其他邮件服务器发送邮件时，它就表现为SMTP的客户；当邮件服务器从其他邮件服务器上接收邮件时，它就表现为一个SMTP的服务器

### 2.3.1 SMTP

SMTP是因特网电子邮件的核心。SMTP用于从发送方的邮件服务器发送报文到接收方的邮件服务器。尽管电子邮件应用在因特网上的独特地位可以证明SMTP有着众多非常岀色的性质，但它所具有的某种陈旧特征表明它仍然是一种继承的技术。例如，它限制所有邮件报文的体部分(不只是其首部)只能采用简单的7位ASCII表示。在今天的多媒体时代，7位ASCII的限制的确有点痛苦，即在用SMTP传送邮件之前，需要将二进制多媒体数据编码为ASCII码，并且在使用SMTP传输后要求将相应的ASCII码邮件解码还原为多媒体数据。使用HTTP传送前不需要将多媒体数据编码为ASCII码

* 下面通过假设Alice向Bob发送邮件来描述SMTP的基本操作↓：

	1. Alice调用她的邮件代理程序并提供Bob的邮件地址(例如bob@someschool.edu)，撰写报文，然后指示用户代理发送该报文

	2. Alice的用户代理把报文发给她的邮件服务器，在那里该报文被放在报文队列中

	3. 运行在Alice的邮件服务器上的SMTP客户端发现了报文队列中的这个报文，它就创建一个到运行在Bob的邮件服务器上的SMTP服务器的TCP连接

	4. 在经过一些初始SMTP握手后，SMTP客户通过该TCP连接发送Alice的报文

	5. 在Bob的邮件服务器上，SMTP的服务器端接收该报文。Bob的邮件服务器然后将该报文放入Bob的邮箱中

	6. 在Bob方便的时候，他调用用户代理阅读该报文

SMTP一般不使用中间邮件服务器发送邮件，即使这两个邮件服务器位于地球的两端也是这样。假设Alice的邮件服务器在中国香港，而Bob的服务器在美国圣路易斯，那么这个TCP连接也是从香港服务器到圣路易斯服务器之间的直接相连。特别是，如果Bob的邮件服务器没有开机，该报文会保留在Alice的邮件服务器上并等待进行新的尝试，这意味着邮件并不在中间的某个邮件服务器存留

SMTP是将一个报文从发送邮件服务器传送到接收邮件服务器的过程如下：首先，客户SMTP(运行在发送邮件服务器主机上)在25号端口建立一个到服务器SMTP(运行在接收邮件服务器主机上)的TCP连接。如果服务器没有开机，客户会在稍后继续尝试连接。一旦连接建立，服务器和客户执行某些应用层的握手，SMTP的客户和服务器在传输信息前先相互介绍。在SMTP握手的阶段，SMTP客户指示发送方的邮件地址(产生报文的那个人)和接收方的邮件地址。一旦该SMTP客户和服务器彼此介绍之后，客户发送该报文。SMTP能依赖TCP提供的可靠数据传输无差错地将邮件投递到接收服务器。该客户如果有另外的报文要发送到该服务器，就在该相同的TCP连接上重复这种处理；否则，它指示TCP关闭连接

### 2.3.2 与HTTP的对比

* 共同特征：

	* 这两个协议都用于从一台主机向另一台主机传送文件：HTTP从Web服务器向Web客户(通常是一个浏览器)传送文件(对象)；SMTP从一个邮件服务器向另一个邮件服务器传送文件(电子邮件报文)

	* 当进行文件传送时，持续的HTTP和SMTP都使用持续连接

* 区别：

	* HTTP主要是一个拉协议，即在方便的时候，某些人在Web服务器上装载信息，用户使用HTTP从该服务器拉取这些信息。特别是TCP连接是由想接收文件的机器发起的。另一方面，SMTP基本上是一个推协议，即发送邮件服务器把文件推向接收邮件服务器。特别是，这个TCP连接是由要发送该文件的机器发起的

	* SMTP要求每个报文(包括它们的体)采用7比特ASCII码格式。如果某报文包含了非7比特ASCII字符(如具有重音的法文字符)或二进制数据(如图形文件)，则该报文必须按照7比特ASCII码进行编码。HTTP数据则不受这种限制

	* 如何处理一个既包含文本又包含图形(也可能是其他媒体类型)的文档：HTTP把每个对象封装到它自己的HTTP响应报文中，而SMTP则把所有报文对象放在一个报文之中

### 2.3.3 邮件报文格式

当一个人给另一个人发送电子邮件时，一个包含环境信息的首部位于报文体前面。这些环境信息包括在一系列首部行中，这些行由RFC 5322定义。首部行和该报文的体用空行(即回车换行)进行分隔。如同HTTP协议，每个首部行包含了可读的文本，是由关键词后跟冒号及其值组成的。某些关键词是必需的，另一些则是可选的。每个首部必须含有一个`From:`首部行和一个`To:`首部行；一个首部也许包含一个`Subject:`首部行以及其他可选的首部行。重要的是注意到下列事实：这些首部行不同于我们在[2.3.1 SMTP](#231-smtp)节所学到的SMTP命令(即使那里包含了某些相同的词汇，如from和to)。那节中的命令是SMTP握手协议的一部分；本节中考察的首部行则是邮件报文自身的一部分

一个典型的报文首部行如下↓：

```
From: alice@crepes.fr
To: bob@hamburger.edu
Subject: Searching for the meaning of life.

```

在报文首部之后，紧接着一个空白行，然后是以ASCII格式表示的报文体

### 2.3.4 邮件访问协议

邮件访问使用了一种客户-服务器体系结构，即典型的用户通过在用户端系统上运行的客户程序来阅读电子邮件，这里的端系统可能是办公室的PC、便携机或者是智能手机。通过在本地主机上运行邮件客户程序，用户享受一系列丰富的特性，包括查看多媒体报文和附件的能力。典型的用户通常在本地PC上运行一个用户代理程序，而它访问存储在总是保持开机的共享邮件服务器上的邮箱。该邮件服务器与其他用户共享，并且通常由用户的ISP进行维护(如大学或公司)

现在考虑当从Alice向Bob发送一个电子邮件报文时所取的路径。Alice的用户代理用SMTP将电子邮件报文推入她的邮件服务器，接着她的邮件服务器(作为一个SMTP客户)再用SMTP将该邮件中继到Bob的邮件服务器。为什么该过程要分成两步呢？主要是因为不通过Alice的邮件服务器进行中继，Alice的用户代理将没有任何办法到达一个不可达的目的地接收服务器。通过首先将邮件存放在自己的邮件服务器中，Alice的邮件服务器可以重复地尝试向Bob的邮件服务器发送该报文，如每30分钟一次，直到Bob的邮件服务器变得运行为止(并且如果Alice的邮件服务器关机，她则能向系统管理员进行申告)

像Bob这样的接收方，是如何通过运行其本地PC上的用户代理，获得位于他的某ISP的邮件服务器上的邮件呢？值得注意的是Bob的用户代理不能使用SMTP得到报文，因为取报文是一个拉操作，而SMTP协议是一个推协议。通过引入一个特殊的邮件访问协议来解决这个难题，该协议将Bob邮件服务器上的报文传送给他的本地PC。目前有一些流行的邮件访问协议，包括第三版的邮局协议(POP3)、因特网邮件访问协议(IMAP)以及HTTP

1. POP3(第三版邮局协议)

POP3是一个极为简单的邮件访问协议。因为该协议非常简单，故其功能相当有限。当用户代理(客户)打开了一个到邮件服务器(服务器)端口 110上的TCP连接后，POP3就开始工作了。随着建立TCP连接，POP3按照三个阶段进行工作：特许、事务处理以及更新。在第一个阶段即特许阶段，用户代理发送(以明文形式)用户名和口令以鉴别用户。在第二个阶段即事务处理阶段，用户代理取回报文；同时在这个阶段用户代理还能进行如下操作，对报文做删除标记，取消报文删除标记，以及获取邮件的统计信息。在第三个阶段即更新阶段，它出现在客户发出了quit命令之后，目的是结束该POP3会话；这时，该邮件服务器删除那些被标记为删除的报文

在用户代理与邮件服务器之间的POP3会话期间，该POP3服务器保留了一些状态信息；特别是记录了哪些用户报文被标记为删除了。然而，POP3服务器并不在POP3会话过程中携带状态信息。会话中不包括状态信息大大简化了POP3服务的实现

使用POP3访问时，一旦Bob将邮件下载到本地主机后，他就能建立邮件文件夹，并将下载的邮件放入该文件夹中。然后Bob可以删除报文，在文件夹之间移动报文，并查询报文(通过发送方的名字或报文主题)。但是这种文件夹和报文存放在本地主机上的方式，会给移动用户带来问题，因为他更喜欢使用一个在远程服务器上的层次文件夹，这样他可以从任何一台机器上对所有报文进行访问。使用POP3是不可能做到这一点的，POP3协议没有给用户提供任何创建远程文件夹并为报文指派文件夹的方法

2. IMAP(因特网邮件访问协议)

IMAP服务器把每个报文与一个文件夹联系起来；当报文第一次到达服务器时，它与收件人的INBOX文件夹相关联。收件人则能够把邮件移到一个新的、用户创建的文件夹中，阅读邮件，删除邮件等。IMAP协议为用户提供了创建文件夹以及将邮件从一个文件夹移动到另一个文件夹的命令。IMAP还为用户提供了在远程文件夹中查询邮件的命令，按指定条件去查询匹配的邮件。值得注意的是，与POP3不同，IMAP服务器维护了IMAP会话的用户状态信息，例如，文件夹的名字以及哪些报文与哪些文件夹相关联

IMAP的另一个重要特性是它具有允许用户代理获取报文某些部分的命令。例如，一个用户代理可以只读取一个报文的报文首部，或只是一个多部分MIME报文的一部分。当用户代理和其邮件服务器之间使用低带宽连接(如一个低速调制解调器链路)的时候，一个特性非常有用。使用这种低带宽连接时，用户可能并不想取回他邮箱中的所有邮件，尤其要避免可能包含如音频或视频片断的大邮件

3. 基于Web的电子邮件

使用基于Web的电子邮件服务，使用这种服务，用户代理就是普通的浏览器，用户和他远程邮箱之间的通信则通过HTTP进行。当一个收件人(如Bob)，想从他的邮箱中访问一个报文时，该电子邮件报文从Bob的邮件服务器发送到他的浏览器，使用的是HTTP而不是POP3或者IMAP协议。当发件人(如Alice)要发送一封电子邮件报文时，该电子邮件报文从Alice的浏览器发送到她的邮件服务器，使用的是HTTP而不是SMTP。然而，Alice的邮件服务器在与其他的邮件服务器之间发送和接收邮件时，仍然使用的是SMTP

## 2.4 DNS(域名系统)：因特网的目录服务

因特网上的主机可以使用多种方式进行标识，比如**主机名(hostname**)或**IP地址(IP address**)等

主机名：如www.google.com等，这些名字便于记忆，但很少或几乎没有提供关于主机在因特网中位置的信息。并且主机名可能由不定长的字母数字组成，路由器难以处理

IP地址：我们将在[第4章 网络层：数据平面](4.网络层：数据平面.md)更为详细地讨论IP地址。一个IP地址由4个字节组成，并有着严格的层次结构。例如121.7.106.83这样一个IP地址，其中的每个字节都被句点分隔开来，表示了0~255的十进制数字。我们说IP地址具有层次结构，是因为当我们从左至右扫描它时，我们会得到越来越具体的关于主机位于因特网何处的信息(即在众多网络的哪个网络里)

### 2.4.1 DNS提供的服务

DNS(域名系统)的主要任务是进行主机名到IP地址转换的目录服务。是1.一个由分层的DNS服务器实现的分布式数据库；2.一个使得主机能够查询分布式数据库的应用层协议。DNS服务器通常是运行BIND软件的UNIX机器。DNS协议运行在UDP之上，使用53号端口

与HTTP、FTP和SMTP协议一样，DNS协议是应用层协议，其原因在于：1.使用客户-服务器模式运行在通信的端系统之间；2.在通信的端系统之间通过下面的端到端运输协议来传送DNS报文。然而，在其他意义上，DNS的作用非常不同于Web等应用。与这些应用程序不同之处在于，DNS不是一个直接和用户打交道的应用。相反，DNS是为因特网上的用户应用程序以及其他软件提供一种核心功能，即将主机名转换为其背后的IP地址。因特网体系结构的复杂性大多数位于网络的"边缘"。DNS通过采用了位于网络边缘的客户和服务器，实现了关键的名字到地址转换功能，它还是这种设计原理的另一个范例

* DNS通常是由其他应用层协议所使用的，包括HTTP、SMTP和FTP，将用户提供的主机名解析为IP地址。举一个例子，考虑运行在某用户主机上的一个浏览器(即一个HTTP客户)请求URL `www.someschool.edu/index.html`页面时会发生什么现象。为了使用户的一主机能够将一个HTTP请求报文发送到Web服务器`www.someschool.edu`，该用户主机必须获得`www.someschool.edu`的IP地址。其做法如下：

	1. 同一台用户主机上运行着DNS应用的客户端

	2. 浏览器从上述URL中抽取岀主机名`www.someschool.edu`，并将这台主机名传给DNS应用的客户端

	3. DNS客户向DNS服务器发送一个包含主机名的请求

	4. DNS客户最终会收到一份回答报文，其中含有对应于该主机名的IP地址

	5. 一旦浏览器接收到来自DNS的该IP地址，它能够向位于该IP地址80端口的HTTP服务器进程发起一个TCP连接

从这个例子中，我们可以看到DNS给使用它的因特网应用带来了额外的时延，有时还相当可观。幸运的是，想获得的IP地址通常就缓存在一个"附近的"DNS服务器中，这有助于减少DNS的网络流量和DNS的平均时延

* DNS提供的服务：

	* **主机名到IP地址的转换**：如上所述

	* **主机别名**：有着复杂主机名的主机能拥有一个或者多个别名。例如，一台名为`relay1.west-coast.enterprise.com`的主机，可能还有两个别名为`enter-prise.com`和`www.enterprise.com`。在这种情况下，`relay1.west-coast.enterprise.com`也称为**规范主机名**。主机别名(当存在时)比主机规范名更加容易记忆。应用程序可以调用DNS来获得主机别名对应的规范主机名以及主机的IP地址

	* **邮件服务器别名**：电子邮件应用程序可以调用DNS，对提供的主机名别名进行解析，以获得该主机的规范主机名及其IP地址。事实上，MX记录(参见后面)允许一个公司的邮件服务器和Web服务器使用相同(别名化的)的主机名；例如，一个公司的Web服务器和邮件服务器都能叫作`enterprise.com`

	* **负载分配**：DNS也用于在冗余的服务器(如冗余的Web服务器等)之间进行负载分配。繁忙的站点被冗余分布在多台服务器上，每台服务器均运行在不同的端系统上，每个都有着不同的IP地址。由于这些冗余的Web服务器，一个IP地址集合因此与同一个规范主机名相联系。DNS数据库中存储着这些IP地址集合。当客户对映射到某地址集合的名字发出一个DNS请求时，该服务器用IP地址的整个集合进行响应，但在每个回答中循环这些地址次序。因为客户通常总是向IP地址排在最前面的服务器发送HTTP请求报文，所以DNS就在所有这些冗余的Web服务器之间循环分配了负载。DNS的循环同样可以用于邮件服务器，因此，多个邮件服务器可以具有相同的别名。一些内容分发公司如Akamai也以更加复杂的方式使用DNS，以提供Web内容分发(参见[2.6.3 内容分发网](#263-内容分发网)节)

### 2.4.2 DNS工作机理概述

假设运行在用户主机上的某些应用程序(如Web浏览器或邮件阅读器)需要将主机名转换为IP地址。这些应用程序将调用DNS的客户端，并指明需要被转换的主机名。用户主机上的DNS接收到后，向网络中发送一个DNS查询报文。所有的DNS请求和回答报文使用UDP数据报经端口53发送。经过若干毫秒到若干秒的时延后，用户主机上的DNS接收到一个提供所希望映射的DNS回答报文。这个映射结果则被传递到调用DNS的应用程序。因此，从用户主机上调用应用程序的角度看，DNS是一个提供简单、直接的转换服务的黑盒子。但事实上，实现这个服务的黑盒子非常复杂，它由分布于全球的大量DNS服务器以及定义了DNS服务器与查询主机通信方式的应用层协议组成

* **集中式设计**：DNS的一种简单设计是在因特网上只使用一个DNS服务器，该服务器包含所有的映射。在这种集中式设计中，客户直接将所有查询直接发往单一的DNS服务器，同时该DNS服务器直接对所有的查询客户做出响应。尽管这种设计的简单性非常具有吸引力，但它不适用于当今的因特网，因为因特网有着数量巨大(并持续增长)的主机。这种集中式设计的问题包括：

	* **单点故障**：如果该DNS服务器崩溃，整个因特网随之瘫痪

	* 通信容量(traffic volume)。单个DNS服务器不得不处理所有的DNS査询(用于为上亿台主机产生的所有HTTP请求报文和电子邮件报文服务)

	* **远距离的集中式数据库**：单个DNS服务器不可能"邻近"所有查询客户，中间也许还要经过低速和拥塞的链路。这将导致严重的时延

	* **维护**：单个DNS服务器将不得不为所有的因特网主机保留记录。这不仅将使这个中央数据库庞大，而且它还不得不为解决每个新添加的主机而频繁更新

	* 总的来说，在单一 DNS服务器上运行集中式数据库完全没有可扩展能力。因此，DNS采用了分布式的设计方案。事实上，DNS是一个在因特网上实现分布式数据库的精彩范例

1. 分布式、层次数据库

为了处理扩展性问题，DNS使用了大量的DNS服务器，它们以层次方式组织，并且分布在全世界范围内。没有一台DNS服务器拥有因特网上所有主机的映射。相反，这些映射分布在所有的DNS服务器上。大致说来，有3种类型的DNS服务器：**根DNS服务器**、**顶级域(TLD)DNS服务器**和**权威DNS服务器**。为了理解这3种类型的DNS服务器交互的方式，假定一个DNS客户要决定主机名www.amazon.com的IP地址。粗略说来，将发生下列事件。客户首先与根服务器之一联系，它将返回顶级域名com的TLD服务器的IP地址。该客户则与这些TLD服务器之一联系，它将为amazon.com返回权威服务器的IP地址。最后，该客户与amazon.com权威服务器之一联系，它为主机名www.amazon.com返回其IP地址。我们将很快更为详细地考察DNS查找过程。不过我们先仔细看一下这3种类型的DNS服务器：

* 根DNS服务器：有400多个根名字服务器遍及全世界。这些根名字服务器由13个不同的组织管理。根名字服务器提供TLD服务器的IP地址

* 顶级域(TLD)DNS服务器：对于每个顶级域(如com、org、net、edu和gov)和所有国家的顶级域(如uk、fr、ca和jp)，都有TLD服务器(或服务器集群)。支持TLD的网络基础设施可能是大而复杂的。TLD服务器提供了权威DNS服务器的IP地址

* 权威DNS服务器：在因特网上具有公共可访问主机(如Web服务器和邮件服务器)的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。一个组织机构的权威DNS服务器收藏了这些DNS记录。一个组织机构能够选择实现它自己的权威DNS服务器以保存这些记录；另一种方法是，该组织能够支付费用，让这些记录存储在某个服务提供商的一个权威DNS服务器中。多数大学和大公司实现和维护它们自己基本和辅助(备份)的权威DNS服务器

根、TLD和权威DNS服务器都处在该DNS服务器的层次结构中。还有另一类重要的DNS服务器，称为**本地DNS服务器**。严格说来，一个本地DNS服务器并不属于该服务器的层次结构，但它对DNS层次结构是至关重要的。每个ISP(如一个居民区的ISP或一个机构的ISP)都有一台本地DNS服务器(也叫默认名字服务器)。当主机与某个ISP连接时，该ISP提供一台主机的IP地址，该主机具有一台或多台其本地DNS服务器的IP地址(通常通过DHCP，将在[第4章 网络层：数据平面](4.网络层：数据平面.md)中讨论)。通过访问Windows或UNIX的网络状态窗口，用户能够容易地确定他的本地DNS服务器的IP地址。主机的本地DNS服务器通常"邻近"本主机。对某机构ISP而言，本地DNS服务器可能就与主机在同一个局域网中；对于某居民区ISP来说，本地DNS服务器通常与主机相隔不超过几台路由器。当主机发岀DNS请求时，该请求被发往本地DNS服务器，它起着代理的作用，并将该请求转发到DNS服务器层次结构中

2. DNS缓存

**DNS缓存**：为了改善时延性能并减少在因特网上到处传输的DNS报文数量，DNS广泛使用了缓存技术。DNS缓存的原理非常简单。在一个请求链中，当某DNS服务器接收一个DNS回答(例如，包含某主机名到IP地址的映射)时，它能将映射缓存在本地存储器中。如果在DNS服务器中缓存了一台主机名/IP地址对，另一个对相同主机名的查询到达该DNS服务器时，该DNS服务器就能够提供所要求的IP地址，即使它不是该主机名的权威服务器。由于主机和主机名与IP地址间的映射并不是永久的，DNS服务器在一段时间后(通常设置为两天)将丢弃缓存的信息

本地DNS服务器也能够缓存TLD服务器的IP地址，因而允许本地DNS绕过查询链中的根DNS服务器。事实上，因为缓存，除了少数DNS查询以外，根服务器被绕过了

### 2.4.3 DNS记录和报文

共同实现DNS分布式数据库的所有DNS服务器存储了资源记录(RR)，RR提供了主机名到IP地址的映射。每个DNS回答报文包含了一条或多条资源记录

* 资源记录是一个包含了下列字段的4元组：`(Name, Value, Type, TTL)`

	* TTL是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间。在下面给岀的记录例子中，我们忽略掉TTL字段

	* Name和Value的值取决于Type

	* 如果Type=A，则Name是主机名，Value是该主机名对应的IP地址。因此，一条类型为A的资源记录提供了标准的主机名到IP地址的映射。例如`(relay1.bar.foo.com, 145.37.93.126, A)`就是一条类型A记录

	* 如果Type=NS，则Name是个域(如`foo.com`)，而Value是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名。这个记录用于沿着查询链来路由DNS查询。例如`(foo.com, dns.foo.com, NS)`就是一条类型为NS的记录

	* 如果Type=CNAME，则Value是别名为Name的主机对应的规范主机名。该记录能够向査询的主机提供一个主机名对应的规范主机名，例如`(foo.com, relay1.bar.foo.com, CNAME)`就是一条CNAME类型的记录

	* 如果Type=MX，则Value是个别名为Name的邮件服务器的规范主机名。举例来说，`(foo.com, mail.bar.foo.com, MX)`就是一条MX记录。MX记录允许邮件服务器主机名具有简单的别名。值得注意的是，通过使用MX记录，一个公司的邮件服务器和其他服务器(如它的Web服务器)可以使用相同的别名。为了获得邮件服务器的规范主机名，DNS客户应当请求一条MX记录；而为了获得其他服务器的规范主机名，DNS客户应当请求CNAME记录

如果一台DNS服务器是用于某特定主机名的权威DNS服务器，那么该DNS服务器会有一条包含用于该主机名的类型A记录(即使该DNS服务器不是其权威DNS服务器，它也可能在缓存中包含有一条类型A记录)。如果服务器不是用于某主机名的权威服务器，那么该服务器将包含一条类型NS记录，该记录对应于包含主机名的域；它还将包括一条类型A记录，该记录提供了在NS记录的Value字段中的DNS服务器的IP地址。举例来说，假设主机gaia.cs.umass.edu的权威DNS服务器为`dns.umass.edu`，一台edu TLD服务器不是主机gaia.cs.umass.edu的权威DNS服务器，则该服务器将包含一条包括主机cs.umass.edu的域记录，如`(umass.edu, dns.umass.edu, NS)`；该edu TLD服务器还将包含一条类型A记录，如`(dns.umass.edu, 128.119.40.111, A)`，该记录将名字dns.umass.edu映射为一个IP地址

* 在DNS数据库中插入记录

搭建一个新网站之后(假设域名为`networkutopia.com`)，第一件事是在注册登记机构注册域名`networkutopia.com`。**注册登记机构**是一个商业实体，它验证该域名的唯一性，将该域名输入DNS数据库(如下面所讨论的那样)，对提供的服务收取少量费用。现在有许多注册登记机构竞争客户，因特网名字和地址分配机构(ICANN)向各种注册登记机构授权

当你向某些注册登记机构注册域名networkutopia.com时，需要向该机构提供你的基本和辅助权威DNS服务器的名字和IP地址。假定该名字和1P地址是dns1.networkutopia.com和dns2.networkutopia.com及212.212.212.1和212.212.212.2。对这两个权威DNS服务器的每一个，该注册登记机构确保将一个类型NS和一个类型A的记录输入TLD com服务器。特别是对于用于networkutopia.com的基本权威服务器，该注册登记机构将下列两条资源记录插入该DNS系统中：`(networkutopia.com, dns1.networkutopia.com, NS)`和`(dns1.networkutopia.com, 212.212.212.1, A)`

你还必须确保用于Web服务器www.networkutopia.com的类型A资源记录和用于邮件服务器mail.networkutopia.com的类型MX资源记录被输入你的权威DNS服务器中(之前每台DNS服务器中的内容都是静态配置的，例如来自系统管理员创建的配置文件。后来在DNS协议中添加了一个更新(UPDATE)选项，允许通过DNS报文对数据库中的内容进行动态添加或者删除)

一旦完成所有这些步骤，人们将能够访问你的Web站点，并向你公司的雇员发送电子邮件。我们通过验证该说法的正确性来总结DNS的讨论。这种验证也有助于充实我们已经学到的DNS知识。假定在澳大利亚的Alice要观看www.networkutopia.com的Web页面。如前面所讨论，她的主机将首先向其本地DNS服务器发送请求。该本地服务器接着则联系一个TLD com服务器(如果TLD com服务器的地址没有被缓存，该本地DNS服务器也将必须与根DNS服务器相联系)。该TLD服务器包含前面列出的类型NS和类型A资源记录，因为注册登记机构将这些资源记录插入所有的TLD com服务器。该TLD com服务器向Alice的本地DNS服务器发送一个回答，该回答包含了这两条资源记录。该本地DNS服务器则向212.212.212.1发送一个DNS査询，请求对应于www.networkutopia.com的类型A记录。该记录提供了所希望的Web服务器的IP地址，如212.212.71.4，本地DNS服务器将该地址回传给Alice的主机。Alice的浏览器此时能够向主机212.212.71.4发起一个TCP连接，并在该连接上发送一个HTTP请求

## 2.5 P2P文件分发

在目前为止本章中描述的应用(包括Web、电子邮件和DNS)都采用了客户-服务器体系结构，极大地依赖于总是打开的基础设施服务器。使用P2P体系结构，对总是打开的基础设施服务器有最小的(或者没有)依赖。与之相反，成对间歇连接的主机(称为对等方)彼此直接通信。这些对等方并不为服务提供商所拥有，而是受用户控制的桌面计算机和膝上计算机

在本节中我们将研究一个非常自然的P2P应用，即从单一服务器向大量主机(称为对等方)分发一个大文件。在客户-服务器文件分发中，该服务器必须向每个对等方发送该文件的一个副本，即服务器承受了极大的负担，并且消耗了大量的服务器带宽。在P2P文件分发中，每个对等方能够向任何其他对等方重新分发它已经收到的该文件的任何部分，从而在分发过程中协助该服务器

具有P2P体系结构的应用程序能够使自扩展的。这种扩展性的直接成因是：对等方除了是比特的消费者外还是它们的重新分发者

## 2.6 视频流和内容分发网(CDN)

### 2.6.1 因特网视频

在流式存储视频应用中，基础的媒体是预先录制的视频。这些预先录制好的视频放置在服务器上，用户按需向这些服务器发送请求来观看视频

但在开始讨论视频流之前，我们先迅速感受一下视频媒体自身。视频是一系列的图像，通常以一种恒定的速率(如每秒24或30张图像)来展现。一幅未压缩、数字编码的图像由像素阵列组成，其中每个像素是由一些比特编码来表示亮度和颜色。视频的一个重要特征是它能够被压缩，因而可用比特率来权衡视频质量。今天现成的压缩算法能够将一个视频压缩成所希望的任何比特率。当然，比特率越高，图像质量越好，用户的总体视觉感受越好

从网络的观点看，也许视频最为突出的特征是它的高比特率。压缩的因特网视频的比特率范围通常从用于低质量视频的100kbps，到用于流式高分辨率电影的超过3Mbps，再到用于4K流式展望的超过10Mbps。这能够转换为巨大的流量和存储，特别是对高端视频。到目前为止，对流式视频的最为重要的性能度量是平均端到端吞吐量。为了提供连续不断的布局，网络必须为流式应用提供平均吞吐量，这个流式应用至少与压缩视频的比特率一样大

我们也能使用压缩生成相同视频的多个版本，每个版本有不同的质量等级。例如，我们能够使用压缩生成相同视频的3个版本，比特率分别为300kbps、1Mbps和3Mbps。用户则能够根据他们当前可用带宽来决定观看哪个版本

### 2.6.2 HTTP流和DASH

在HTTP流中，视频只是存储在HTTP服务器中作为一个普通的文件，每个文件有一个特定的URL。当用户要看该视频时，客户与服务器创建一个TCP连接并发送对该URL的HTTP GET请求。服务器则以底层网络协议和流量条件允许的尽可能快的速率，在一个HTTP响应报文中发送该视频文件。在客户一侧，字节被收集在客户应用缓存中。一旦该缓存中的字节数量超过预先设定的门限，客户应用程序就开始播放，特别是，流式视频应用程序周期性地从客户应用程序缓存中抓取帧，对这些帧解压缩并且在用户屏幕上展现。因此，流式视频应用接收到视频就进行播放，同时缓存该视频后面部分的帧

尽管HTTP流在实践中已经得到广泛部署，但它具有严重缺陷，即所有客户接收到相同编码的视频，尽管对不同的客户或者对于相同客户的不同时间而言，客户可用的带宽大小有很大不同。这导致了一种新型基于HTTP的流的研发，它常常被称为**经HTTP的动态适应性流(DASH)**。在DASH中，视频编码为几个不同的版本，其中每个版本具有不同的比特率，对应于不同的质量水平。客户动态地请求来自不同版本且长度为几秒的视频段数据块。当可用带宽量较高时，客户自然地选择来自高速率版本的块；当可用带宽量较低时，客户自然地选择来自低速率版本的块。客户用HTTP GET请求报文一次选择一个不同的块

DASH允许客户使用不同的以太网接入速率流式播放具有不同编码速率的视频。如果端到端带宽在会话过程中改变的话，DASH允许客户适应可用带宽。这种特色对于移动用户特别重要，当移动用户相对于基站移动时，通常他们能感受到其可用带宽的波动

使用DASH后，每个视频版本存储在HTTP服务器中，每个版本都有一个不同的URL。HTTP服务器也有一个**告示文件**，为每个版本提供了一个URL及其比特率。客户首先请求该告示文件并且得知各种各样的版本。然后客户通过在HTTP GET请求报文中对每块指定一个URL和一个字节范围，一次选择一块。在下载块的同时，客户也测量接收带宽并运行一个速率决定算法来选择下次请求的块。自然地，如果客户缓存的视频很多，并且测量的接收带宽较高，它将选择一个高速率的版本。同样，如果客户缓存的视频很少，并且测量的接收带宽较低，它将选择一个低速率的版本。因此DASH允许客户自由地在不同的质量等级之间切换

### 2.6.3 内容分发网(CDN)

建立单一的大规模数据中心，在数据中心中存储所有视频，并直接从该数据中心向世界范围的客户传输流式视频存在的问题有：首先，如果客户远离数据中心，服务器到客户的分组将跨越许多通信链路并很可能通过许多ISP，其中某些ISP可能位于不同的大洲。如果这些链路之一提供的吞吐量小于视频消耗速率，端到端吞吐量也将小于该消耗速率，给用户带来恼人的停滞时延(第1章讲过，一条流的端到端吞吐量由瓶颈链路的吞吐量所决定)。出现这种事件的可能性随着端到端路径中链路数量的增加而增加。第二个缺陷是流行的视频很可能经过相同的通信链路发送许多次。这不仅浪费了网络带宽，因特网视频公司自己也将为向因特网反复发送相同的字节而向其ISP运营商(连接到数据中心)支付费用。这种解决方案的第三个问题是单个数据中心代表一个单点故障，如果数据中心或其通向因特网的链路崩溃，它将不能够分发任何视频流了

为了应对向分布于全世界的用户分发巨量视频数据的挑战，几乎所有主要的视频流公司都利用**内容分发网(CDN**)。CDN管理分布在多个地理位置上的服务器，在它的服务器中存储视频(和其他类型的Web内容，包括文档、图片和音频)的副本，并且所有试图将每个用户请求定向到一个将提供最好的用户体验的CDN位置。CDN可以是**专用CDN**，即它由内容提供商自己所拥有；例如，谷歌的CDN分发YouTube视频和其他类型的内容。另一种CDN可以是**第三方CDN**，它代表多个内容提供商分发内容

* CDN通常采用两种不同的服务器安置原则：

	* **深入**：该原则是通过在遍及全球的接入ISP中部署服务器集群来深入到ISP的接入网中，其目标是靠近端用户，通过减少端用户和CDN集群之间(内容从这里收到)链路和路由器的数量，从而改善了用户感受的时延和吞吐量。因为这种高度分布式设计，维护和管理集群的任务成为挑战

	* **邀请做客**：该原则是通过在少量(例如10个)关键位置建造大集群来邀请到ISP做客。不是将集群放在接入ISP中，这些CDN通常将它们的集群放置在因特网交换点(IXP)。与深入设计原则相比，邀请做客设计通常产生较低的维护和管理开销，可能以对端用户的较高时延和较低吞吐量为代价

一旦CDN的集群准备就绪，它就可以跨集群复制内容。CDN可能不希望将每个视频的副本放置在每个集群中，因为某些视频很少观看或仅在某些国家中流行。事实上，许多CDN没有将视频推入它们的集群，而是使用一种简单的拉策略：如果客户向一个未存储该视频的集群请求某视频，则该集群检索该视频(从某中心仓库或者从另一个集群)，向客户流式传输视频时的同时在本地存储一个副本。类似于因特网缓存(参见[2.2.5 Web缓存](#225-web缓存)节)，当某集群存储器变满时，它删除不经常请求的视频

1. CDN操作

在讨论过这两种部署CDN的重要方法后，我们现在深入看看CDN操作的细节。当用户主机中的一个浏览器指令检索一个特定的视频(由URL标识)时，CDN必须截获该请求，以便能够：确定此时适合用于该客户的CDN服务器集群；将客户的请求重定向到该集群的某台服务器。我们很快将讨论CDN是如何能够确定一个适当的集群的。但是我们首先考察截获和重定向请求所依赖的机制

* 大多数CDN利用DNS来截获和重定向请求。我们考虑用一个简单的例子来说明通常是怎样涉及DNS的。假定一个内容提供商NetCinema，雇佣了第三方CDN公司KingCDN来向其客户分发视频。在NetCinema的Web网页上，它的每个视频都被指派了一个URL，该URL包括了字符串"video"以及该视频本身的独特标识符；例如，转换器7可以指派为http://video.netcinema.com/6Y7B23V。接下来访问过程分为六个步骤：

	1. 用户访问位于NetCinema的Web网页

	2. 当用户点击链接http://video.netcinema.com/6Y7B23V时，该用户主机发送了一个对于video.netcinema.com的DNS请求

	3. 用户的本地DNS服务器(LDNS)将该DNS请求中继到一台用于NetCinema的权威DNS服务器，该服务器观察到主机名video.netcinema.com中的字符串"video"。为了将该DNS请求移交给KingCDN，NetCinema权威DNS服务器并不返回一个IP地址，而是向LDNS返回一个KingCDN域的主机名，如a1105.kingcdn.com

	4. 从这时起，DNS请求进入了KingCDN专用DNS基础设施。用户的LDNS则发送第二个请求，此时是对a1105.kingcdn.com的DNS请求，KingCDN的DNS系统最终向LDNS返回KingCDN内容服务器的IP地址。所以正是在这里，在KingCDN的DNS系统中，指定 CDN服务器，客户将能够从这台服务器接收到它的内容

	5. LDNS向用户主机转发内容服务CDN节点的IP地址

	6. 一旦客户收到KingCDN内容服务器的IP地址，它与具有该IP地址的服务器创建了一条直接的TCP连接，并且发出对该视频的HTTP GET请求。如果使用了DASH，服务器将首先向客户发送具有URL列表的告示文件，每个URL对应视频的每个版本，并且客户将动态地选择来自不同版本的块

2. 集群选择策略

任何CDN部署，其核心是**集群选择策略**，即动态地将客户定向到CDN中的某个服务器集群或数据中心的机制。如我们刚才所见，经过客户的DNS查找，CDN得知了该客户的LDNS服务器的IP地址。在得知该IP地址之后，CDN需要基于该IP地址选择一个适当的集群。CDN一般采用专用的集群选择策略。我们现在简单地介绍一些策略，每种策略都有其优点和缺点

一种简单的策略是指派客户到**地理上最为邻近**的集群。使用商用地理位置数据库，每个LDNS IP地址都映射到一个地理位置。当从一个特殊的LDNS接收到一个DNS请求时，CDN选择地理上最为接近的集群，即离LDNS最少几千米远的集群。这样的解决方案对于众多用户来说能够工作得相当好。但对于某些客户，该解决方案可能执行的效果差，因为就网络路径的长度或跳数而言，地理最邻近的集群可能并不是最近的集群。此外，一种所有基于DNS的方法都内在具有的问题是，某些端用户配置使用位于远地的LDNS，在这种情况下，LDNS位置可能远离客户的位置。此外，这种简单的策略忽略了时延和可用带宽随因特网路径时间而变化，总是为特定的客户指派相同的集群

为了基于当前流量条件为客户决定最好的集群，CDN能够对其集群和客户之间的时延和丢包性能执行周期性的**实时测量**。例如，CDN能够让它的每个集群周期性地向位于全世界的所有LDNS发送探测分组(例如，ping报文或DNS请求)。这种方法的一个缺点是许多LDNS被配置为不会响应这些探测

## 2.7 套接字编程：生成网络应用

代码应用程序流程：

1. 客户从其键盘读取一行字符(数据)并将该数据项服务器发送

2. 服务器接收该数据并将这些字符转换为大写

3. 服务器将修改的数据发送给客户

4. 客户接收修改的数据并在其监视器上将该行显示出来

### 2.7.1 UDP套接字编程

发送进程为数据分组附上目的地址，该目的地址是由目的主机的IP地址和目的地套接字的端口号组成的。此外，发送方的源地址也是由源主机的IP地址和源套接字的端口号组成，该源地址也要附在分组之上。然而，将源地址附在分组之上通常并不是由UDP应用程序代码所为，而是由底层操作系统自动完成的

客户端代码↓：

```python
from socket import *

# 指定目标IP与端口
serverName = "hostName"
serverPort = 12000

# 创建socket
# AF_INET指示地址簇，特别是指示底层网络使用IPv4，
# SOCK_DGRAM指示UDPsocket
# 创建socket时并没没有指定客户socket的端口号，而是让操作系统做这件事
clientSocket = socket(AF_INET, SOCK_DGRAM)

# 读取数据
massage = raw_input("Input lowercase sentence:")

# 将数据由字符串类型转换为字节类型，向套接字发送字节
clientSocket.sendto(message.encode(), (serverName, serverPort))

# 等待接收来自服务器的数据
# modifiedMessage为接收的数据分组，serverAddress为服务器IP与端口号，2048指示安魂村长度
modifiedMessage, serverAddress = clientSocket.recvfrom(2048)

# 输出数据
print(modifiedMessage.decode())

# 关闭socket
clientSocket.close()
```

服务器端代代码↓：

```python
from socket import *

serverPort = 12000
serverSocket = socket(AF_INET, SOCK_DGRAM)

# 将端口号与该socket绑定(即分配)在一起，因此12000端口号接收到数据后将导向该socket
serverSocket.bind(("", serverPort))

print("The server is ready to receive")

while True:
	# 等待一个分组的到达
	massage, clientAddress = serverSocket.recvfrom(2048)

	# 将报文转化为字符串后再转换为大写
	modifiedMessage = message.decode().upper()

	# 将客户的地址附到大写的转换为字节后的报文上，并发送到服务器的socket中
	serverSocket.sendto(modifiedMessage.encode(), clientAddress)
```

### 2.7.2 TCP套接字编程

服务器程序使用欢迎套接字接收来自任意客户的TCP连接请求，当接收到客户的TCP连接请求之后，服务器程序生成一个连接套接字用于与客户通信

客户端代码↓：

```python
from socket import *

serverName = "serverName"
serverPoer = 12000

# 创建socket，SOCK_STREAM指示为TCP socket
# 创建socket时并没没有指定客户socket的端口号，而是让操作系统做这件事
clientSocket = socket(AF_INET, SOCK_STREAM)

# 发起客户和服务器之间的TCP连接，执行三次握手并创建一条连接
clientSocket.connect((serverName, serverPort))

sentence = raw_input("Input lowercase sentence:")

# 将字节放入TCP连接
clientSocket.send(sentence.encode())

# 等待接受来自服务器的字节
modifiedSentence = clientSocket.recv(1024)

print("From Server: ", modifiedSentence.decode())

clientSocket.close()
```

服务器端代码↓：

```python
from socket import *

serverPort = 12000

# 创建socket
serverSocket = socket(AF_INET, SOCK_STREAM)

# 将服务器的端口号serverPort与该socket关联起来
# serverPort是欢迎套接字
serverSocket.bind(("", serverPort))

# 让服务器聆听来自客户的TCP连接请求，参数指定了请求连接的最大数
serverSocket.listen(1)

print("The server is ready to receive")

while True:
	# 在服务器中创建一个称为connectionSocket的新套接字，由该特定客户专用
	# 客户和服务器完成了握手，在客户的clientSocket和服务器的serverSocket之间创建了一个TCP连接
	connectionSocket, addr = serverSocket.accept()

	sentence = connectionSocket.recv(1024).decode()
	capitalizedSentence = sentence.upper()
	connectionSocket.send(capitalizedSentence.encode())

	# 关闭连接套接字，但因为欢迎套接字serverSocket保持打开，因此另一个客户能够创建新的TCP连接
	connectionSocket.close()
```

## 2.8 小结

在本章中，我们学习了网络应用的概念和实现两个方面。我们学习了被因特网应用普遍采用的客户-服务器模式，并且看到了该模式在HTTP、SMTP、POP3和DNS等协议中的使用。我们已经更为详细地学习了这些重要的应用层协议以及与之对应的相关应用(Web、文件传输、电子邮件和DNS)。我们也已学习了P2P体系结构以及它如何应用在许多应用程序中。我们也学习了流式视频，以及现代视频分发系统是如何利用CDN的。对于面向连接的(TCP)和无连接的(UDP)端到端传输服务，我们走马观花般地学习了套接字的使用。至此，我们在分层的网络体系结构中的向下之旅已经完成了第一步

在本书一开始的[2.1.1 网络应用程序体系结构](#211-网络应用程序体系结构)节中，我们对协议给岀了一个相当含糊的框架性定义："在两个或多个通信实体之间交换报文的格式和次序，以及对某报文或其他事件传输和/或接收所采取的动作。"本章中的内容，特别是我们对HTTP、SMTP、POP3和DNS协议进行的细致研究，已经为这个定义加入了相当可观的实质性的内容。协议是网络连接中的核心概念；对应用层协议的学习，为我们提供了有关协议内涵的更为直觉的认识

在[2.1 应用层协议原理](#21-应用层协议原理)节中，我们描述了TCP和UDP为调用它们的应用提供的服务模型。当我们在[2.7 套接字编程：生成网络应用](#27-套接字编程生成网络应用)节中开发运行在TCP和UDP之上的简单应用程序时，我们对这些服务模型进行了更加深入的观察。然而，我们几乎没有介绍TCP和UDP是如何提供这种服务模型的。例如，我们知道TCP提供了一种可靠数据服务，但我们未说它是如何做到这一点的。在下一章中我们将不仅关注运输协议是什么，而且还关注它如何工作以及为什么要这么做

有了因特网应用程序结构和应用层协议的知识之后，我们现在准备继续沿该协议栈向下，在[第3章 运输层](3.运输层.md)中探讨运输层
