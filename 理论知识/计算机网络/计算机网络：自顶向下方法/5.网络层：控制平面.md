- [5. 网络层：控制平面](#5-网络层控制平面)
	- [5.1 概述](#51-概述)
	- [5.2 路由选择算法](#52-路由选择算法)
		- [5.2.1 链路状态路由选择算法](#521-链路状态路由选择算法)
		- [5.2.2 距离向量路由选择算法](#522-距离向量路由选择算法)
		- [5.2.3 LS与DV路由选择算法的比较](#523-ls与dv路由选择算法的比较)
	- [5.3 因特网中自治系统(AS)内部的路由算法：OSPF](#53-因特网中自治系统as内部的路由算法ospf)
	- [5.4 ISP之间的路由选择：BGP](#54-isp之间的路由选择bgp)
		- [5.4.1 BGP的作用](#541-bgp的作用)
		- [5.4.2 通告BGP路由信息](#542-通告bgp路由信息)
		- [5.4.3 确定最好的路由](#543-确定最好的路由)
		- [5.4.4 IP任播](#544-ip任播)
		- [5.4.5 路由选择策略](#545-路由选择策略)
		- [5.4.6拼装在一起：在因特网中呈现](#546拼装在一起在因特网中呈现)
	- [5.5 SDN控制平面](#55-sdn控制平面)
		- [5.5.1 SDN控制平面：SDN控制器和SDN网络控制应用程序](#551-sdn控制平面sdn控制器和sdn网络控制应用程序)
	- [5.6 ICMP：因特网控制报文协议](#56-icmp因特网控制报文协议)
	- [5.7 网络管理和SNMP](#57-网络管理和snmp)
		- [5.7.1 网络管理框架](#571-网络管理框架)
		- [5.7.2 简单网络管理协议(SNMP)](#572-简单网络管理协议snmp)
	- [5.8 小结](#58-小结)

# 5. 网络层：控制平面

控制平面作为一种网络范围的逻辑，不仅控制沿着从源主机到目的主机的端到端路径间的路由器如何转发数据报，而且控制网络层组件和服务如何配置和管理。在[5.2 路由选择算法](#52-路由选择算法)中，我们将包含传统的计算图中最低开销路径的路由选择算法。这些算法是两个广为部署的因特网路由选择协议OSPF和BGP的基础，我们将分别在[5.3 因特网中自治系统内部的路由算法：OSPF](#53-因特网中自治系统内部的路由算法ospf)和[5.4 ISP之间的路由选择：BGP](#54-isp之间的路由选择bgp)中涉及。OSPF是一种运行在单一ISP的网络中的路由选择算法。BGP是一种在因特网中用于互联所有网络的路由选择算法，因此常被称为因特网的"黏合剂"。传统上，控制平面功能与数据平面的转发功能在一起实现，在路由器中作为统一的整体。如我们在[第4章 网络层：数据平面](4.网络层：数据平面.md)所学习的那样，软件定义网络(SDN)在数据平面和控制平面之间做了明确分割，在一台分离的"控制器"服务中实现了控制平面功能，该控制器服务与它所控制的路由器的转发组件完全分开并远离。我们将在[5.5 SDN控制平面](#55-sdn控制平面)中讨论SDN控制器。在[5.6 ICMP：因特网控制报文协议](#56-icmp因特网控制报文协议)和[5.7 网络管理和SNMP](#57-网络管理和snmp)中，我们将涉及管理IP网络的某些具体细节：ICMP(互联网控制报文协议)和SNMP(简单网络管理协议)

## 5.1 概述

转发表(在基于目的地转发的场景中)和流表(在通用转发的场景中)是链接网络层的数据平面和控制平面的首要元素。这些表定义了一台路由器的本地数据平面转发行为。在通用转发的场景下，所采取的动作不仅包括转发一个分组到达路由器的每个输出端口，而且能够丢弃一个分组、复制一个分组和/或重写第2、3或4层分组首部字段

在本章中，我们将学习这些转发表和流表是如何计算、维护和安装的。在[4.1 网络层概述](4.网络层：数据平面.md#41-网络层概述)中我们已经学习了完成这些工作有两种可能的方法。

* **每路由器控制**：在每台路由器中运行一种路由选择算法，每台路由器中都包含转发和路由选择功能。每台路由器有一个路由选择组件，用于与其他路由器中的路由选择组件通信，以计算其转发表的值。这种每路由器控制的方法在因特网中已经使用了几十年。将在[5.3 因特网中自治系统内部的路由算法：OSPF](#53-因特网中自治系统内部的路由算法ospf)和[5.4 ISP之间的路由选择：BGP](#54-isp之间的路由选择bgp)中学习的OSPF和BGP协议都是基于这种每路由器的方法进行控制的。

* **逻辑集中式控制**：逻辑集中式控制器计算并分发转发表以供每台路由器使用，如在[4.4 通用转发和SDN(软件定义网络)](#44-通用转发和sdn软件定义网络)中所见，通用的"匹配加动作"抽象允许执行传统的IP转发以及其他功能(负载共享、防火墙功能和NAT)的丰富集合，而这些功能先前是在单独的中间盒中实现的。该控制器经一种定义良好的协议与每台路由器中的一个控制代理(CA)进行交互，以配置和管理该路由器的转发表。CA—般具有最少的功能，其任务是与控制器通信并且按控制器命令行事。与每路由器控制的路由选择算法不同，这些CA既不能直接相互交互，也不能主动参与计算转发表。这是每路由器控制和逻辑集中式控制之间的关键差异

"逻辑集中式"控制意味着就像路由选择控制服务位于单一的集中服务点那样获取它们，即使该服务出于容错和性能扩展性的原因，很可能经由多个服务器实现。正如我们将在[5.5 SDN控制平面](#55-sdn控制平面)中所见，SDN采用了逻辑集中式控制器的概念，而这种方法在生产部署中得到了越来越多的应用

## 5.2 路由选择算法

路由选择算法目的是从发送方到接收方的过程中确定一条通过路由器网络的好的路径(等价于路由)。通常，一条好路径指具有最低开销的路径。然而我们将看到，实践中现实世界还关心诸如策略之类的问题(例如，有一个规则是"属于组织Y的路由器X不应转发任何来源于组织Z所属网络的分组")。注意到无论网络控制平面采用每路由器控制方法，还是采用逻辑集中式控制方法，必定总是存在一条定义良好的一连串路由器，使得分组从发送主机到接收主机跨越网络"旅行"

可以用图来形式化描述路由选择问题。图G=(N，E)是一个N个节点和E条边的集合，其中每条边是取自N的一对节点。在网络层路由选择的环境中，图中的节点表示路由器，这是做出分组转发决定的点；连接这些节点的边表示这些路由器之间的物理链路；一条边还有一个值表示它的开销。通常，一条边的开销可反映出对应链路的物理长度，它的链路速度，或与该链路相关的金钱上的开销。为了我们的目的，我们只将这些链路开销看成是给定的，而不必操心这些值是如何确定的。对于E中的任一条边(x，y)，我们用c(x，y)表示节点x和y间边的开销。如果节点对(x，y)不属于E，则置c(x，y)=∞。此外，我们在这里考虑的都是无向图(即图的边没有方向)，因此边(x，y)与边(y，x)是相同的并且c(xfy)=c(y，x)。然而，我们将学习的算法能够很容易地扩展到在每个方向有不同开销的有向链路场合。同时，如果(x，y)属于E，节点y也被称为节点x的邻居

最低开销路径问题是找出源和目的地之间具有最低开销的一条路。若在图中的所有边具有相同的开销，则最低开销路径也就是最短路径，即在源和目的地之间的具有最少链路数量的路径

一般而言，路由选择算法的一种分类方式是根据该算法是集中式还是分散式来划分：

* **集中式路由选择算法**：用完整的、全局性的网络知识计算岀从源到目的地之间的最低开销路径。也就是说，该算法以所有节点之间的连通性及所有链路的开销为输入。这就要求该算法在真正开始计算以前，要以某种方式获得这些信息。计算本身可在某个场点进行，或在每台路由器的路由选择组件中重复进行。然而，这里的主要区别在于，集中式算法具有关于连通性和链路开销方面的完整信息。具有全局状态信息的算法常被称作**链路状态(LS)算法**，因为该算法必须知道网络中每条链路的开销。我们将在[5.2.1 链路状态路由选择算法](#521-链路状态路由选择算法)中学习LS算法

* **分散式路由选择算法**：路由器以迭代、分布式的方式计算出最低开销路径。没有节点拥有关于所有网络链路开销的完整信息。相反，每个节点仅有与其直接相连链路的开销知识即可开始工作。然后，通过迭代计算过程以及与相邻节点的信息交换，一个节点逐渐计算出到达某目的节点或一组目的节点的最低开销路径。我们将在后面的[5.2.2 距离向量路由选择算法](#522-距离向量路由选择算法)学习一个称为**距离向量(DV)算法**的分散式路由选择算法。之所以叫作DV算法，是因为每个节点维护到网络中所有其他节点的开销(距离)估计的向量。这种分散式算法，通过相邻路由器之间的交互式报文交换，也许更为天然地适合那些路由器直接交互的控制平面

路由选择算法的第二种广义分类方式是根据算法是静态的还是动态的进行分类。在**静态路由选择算法**中，路由随时间的变化非常缓慢，通常是人工进行调整(如人为手工编辑一条链路开销)。**动态路由选择算法**随着网络流量负载或拓扑发生变化而改变路由选择路径。一个动态算法可周期性地运行或直接响应拓扑或链路开销的变化而运行。虽然动态算法易于对网络的变化做岀反应，但也更容易受诸如路由选择循环、路由振荡之类问题的影响

路由选择算法的第三种分类方式是根据它是负载敏感的还是负载迟钝的进行划分。在**负载敏感算法**中，链路开销会动态地变化以反映出底层链路的当前拥塞水平。如果当前拥塞的一条链路与高开销相联系，则路由选择算法趋向于绕开该拥塞链路来选择路由。当今的因特网路由选择算法(如RIP、OSPF和BGP)都是**负载迟钝的**，因为某条链路的开销不明确地反映其当前(或最近)的拥塞水平

### 5.2.1 链路状态路由选择算法

在链路状态算法中，网络拓扑和所有的链路开销都是已知的，也就是说可用作LS算法的输入。实践中这是通过让每个节点向网络中所有其他节点广播链路状态分组来完成的，其中每个链路状态分组包含它所连接的链路的标识和开销。在实践中(例如使用因特网的OSPF路由选择协议，讨论见[5.3 因特网中自治系统内部的路由算法：OSPF](#53-因特网中自治系统内部的路由算法ospf))，这经常由**链路状态广播**算法来完成。节点广播的结果是所有节点都具有该网络的统一、完整的视图。于是每个节点都能够像其他节点一样，运行LS算法并计算出相同的最低开销路径集合

下面给出的链路状态路由选择算法叫作Dijkstra算法，一个密切相关的算法是Prim算法。Dijkstra算法计算从某节点(源节点，我们称之为u)到网络中所有其他节点的最低开销路径。Dijkstra算法是迭代算法，其性质是经算法的第k次迭代后，可知道到某个目的节点的最低开销路径，在到所有目的节点的最低开销路径之中，这k条路径具有k个最低开销。下列记号：D(v)：到算法的本次迭代，从源节点到目的节点的最低开销路径的开销；p(v)：从源到v沿着当前最低开销路径的前一节点(v的邻居)；N'：节点子集；如果从源到v的最低开销路径已确知，v在N'中。该集中式路由选择算法由一个初始化步骤和其后的循环组成。循环执行的次数与网络中节点个数相同。一旦终止，该算法就计算出了从源节点u到网络中每个其他节点的最短路径

源节点u的链路状态(LS)算法如下所示↓：

```
初始化：
N' = {u}
for all nodes v：
	如果v是u的邻居：
		D(v) = c(u，v)
	否则：
		D(v) = ∞

while(N' != N)：
	寻找不在N'中的D(w)最小的节点w
	将w添加到N'
	对w中所有的不在N'中的邻居节点v更新D(v)：D(v) = min(D(v)，D(w) + c(w，v))
```

当LS算法终止时，对于每个节点，我们都得到从源节点沿着它的最低开销路径的前一节点。对于每个前一节点，我们又有它的前一节点，以此方式我们可以构建从源节点到所有目的节点的完整路径。通过对每个目的节点存放从u到目的地的最低开销路径上的下一跳节点，在一个节点中的转发表则能够根据此信息而构建

上文实现的链路状态算法在最差情况下复杂性为$O(n^2)$(该算法的一种更复杂的实现是使用堆，能用对数时间而不是线性时间找到最小值D(w)，因而减少其复杂性)

当链路的开销依赖于承载的流量时，如何才能防止这样的振荡(它不只是出现在链路状态算法中，而且也可能出现在任何使用拥塞或基于时延的链路测度的算法中)。一种解决方案可能强制链路开销不依赖于所承载的流量，但那是一种不可接受的解决方案，因为路由选择的目标之一就是要避开高度拥塞(如高时延)的链路。另一种解决方案就是确保并非所有的路由器都同时运行LS算法。这似乎是一个更合理的方案，因为我们希望即使路由器以相同周期运行LS算法，在每个节点上算法执行的时机也将是不同的。有趣的是，研究人员近来已注意到了因特网上的路由器能在它们之间进行自同步。这就是说，即使它们初始时以同一周期但在不同时刻执行算法，算法执行时机最终会在路由器上变为同步并保持之。避免这种自同步的一种方法是，让每台路由器发送链路通告的时间随机化

### 5.2.2 距离向量路由选择算法

**距离向量(DV)算法**是一种迭代的、异步的和分布式的算法，而LS算法是一种使用全局信息的算法。说它是**分布式的**，是因为每个节点都要从一个或多个直接相连邻居接收某些信息，执行计算，然后将其计算结果分发给邻居。说它是**迭代的**，是因为此过程一直要持续到邻居之间无更多信息要交换为止(此算法是自我终止的，即没有计算应该停止的信号，它就停止了)。说它是**异步的**，是因为它不要求所有节点相互之间步伐一致地操作

其基本思想如下：每个节点x以$D_x(y)$开始，对在N中的所有节点y，估计从x到y的最低开销路径的开销。令$D_x=D_x(y): y\in N$是节点x的距离向量，该向量是从x到在N中的所有其他节点y的开销估计向量。使用DV算法，每个节点x维护下列路由选择信息：对于每个邻居v，从x到直接相连邻居v的开销为c(x，v)；节点x的距离向量，即$D_x=D_x(y): y\in N$，包含了x到N中所有目的地y的开销估计值；它的每个邻居的距离向量，即对x的每个邻居v有$D_v=D_v(y): y\in N$

在该分布式、异步算法中，每个节点不时地向它的每个邻居发送它的距离向量副本。当节点x从它的任何一个邻居v接收到一个新距离向量，它保存v的距离向量，然后更新它自己的距离向量如下：$D_x(y)=min_x \left\{ c(x，v) + D_v(y) \right\}$

如果节点x的距离向量因这个更新步骤而改变，节点x接下来将向它的每个邻居发送其更新后的距离向量，这继而让所有邻居更新它们自己的距离向量。只要所有的节点继续以异步方式交换它们的距离向量，每个开销估计$D_x(y)$收敛到$d_x(y)$，$d_x(y)$为从节点x到节点y的实际最低开销路径的开销

距离向量(DV)算法如下所示↓：

```
初始化：
	对于N中所有的目的地y：
		如果y为x的邻居：
			Dx(y) = c(x，y)
		否则：
			Dx(y) = ∞
	对于所有的邻居w：
		Dw(y) = ？
	对于所有邻居w：
		向w发送距离向量Dx={Dx(y) : y in N}

while (true)：
	等待，直到发现直接相连到某个邻居w的链路开销变化，或者直到收到某个邻居w的距离向量
	对N中所有的y：
		Dx(y) = min{c(x，v) + Dv(y)}

	如果对任意y，Dx(y)发生了改变：
		向所有的邻居发送距离向量Dx = {Dx(y) : y in N}
```

LS算法是一种全局算法，在于它要求每个节点在运行Dijkstra算法之前，首先获得该网络的完整信息。DV算法是分布式的，它不使用这样的全局信息。节点具有的唯一信息是它到直接相连邻居的链路开销和它从这些邻居接收到的信息。每个节点等待来自任何邻居的更新，当接收到一个更新时计算它的新距离向量并向它的邻居发布其新距离向量。在实践中许多类似DV的算法被用于多种路由选择协议中，包括因特网的RIP和BGP、ISO IDRP、Novell IPX和早期的 ARPAnet

1. 距离向量算法：链路开销改变与链路故障

假设x-4-y、y-1-z、z-50-x，当x-4-y增加到x-60-y时，发生如下情况↓：

t0时刻，$D_y(x)=min\left\{c(y，x)+D_X(x)，c(y，z)+D_z(x)\right\}=min\left\{60+0，1+5\right\}=6$。此时$D_z(x)=5$,仍为链路变化前的值，所以$D_y(x)$是错误的，首先从y到z，然后从z回到y，遇到了路由选择环路问题。

t1时刻，y将新距离向量通知z，然后$D_z(x)=7$，从z到y，然后从y回到z，然后再从z到y

以类似的方式，y和z将经过多次迭代循环，直到z最终算出从z经由y到x的距离大于50为止。上述问题有时也会称为无穷计数问题

1. 距离向量算法：增加毒性逆转

刚才描述的特定循环的场景可以通过使用一种称为**毒性逆转**的技术而加以避免。其思想较为简单：如果z通过y路由选择到目的地x，则z将通告y，它(即z)到x的距离是无穷大，也就是z将向y通告$D_z(x)=∞$(即使z实际上知道$D_z(x)=5$).只要z经y路由选择到x，z就持续地向y讲述这个善意的小谎言。因为y相信z没有到x的路径，故只要z继续经y路由选择到x(并这样去撒谎)，y将永远不会试图经由z路由选择到x

毒性逆转并没有解决一般的无穷计数问题。涉及3个或更多节点(而不只是两个直接相连的邻居节点)的环路将无法用毒性逆转技术检测到

### 5.2.3 LS与DV路由选择算法的比较

DV和LS算法采用互补的方法来解决路由选择计算问题。在DV算法中，每个节点仅与它的直接相连的邻居交谈，但它为其邻居提供了从它自己到网络中(它所知道的)所有其他节点的最低开销估计。LS算法需要全局信息。因此，当在每台路由器中实现时，每个节点(经广播)与所有其他节点通信，但仅告诉它们与它直接相连链路的开销。我们通过快速比较它们各自的属性来总结所学的链路状态与距离向量算法。其中N是节点(路由器)的集合，而E是边(链路)的集合↓：

* **报文复杂性**：我们已经看到LS算法要求每个节点都知道网络中每条链路的开销。这就要求要发送$O(|N||E|)$个报文。而且无论何时一条链路的开销改变时，必须向所有节点发送新的链路开销。DV算法要求在每次迭代时，在两个直接相连邻居之间交换报文。算法收敛所需时间依赖于许多因素。当链路开销改变时，DV算法仅当在新的链路开销导致与该链路相连节点的最低开销路径发生改变时，才传播已改变的链路开销

* **收敛速度**：LS算法的实现是一个要求$O(|N||E|)$个报文的$O(丨N^2|)$算法。DV算法收敛较慢，且在收敛时会遇到路由选择环路。DV算法还会遭遇无穷计数的问题

* **健壮性**：如果一台路由器发生故障、行为错乱或受到蓄意破坏时情况会怎样呢？对于LS算法，路由器能够向其连接的链路(而不是其他链路)广播不正确的开销。作为LS广播的一部分，一个节点也可损坏或丢弃它收到的任何LS广播分组。但是一个LS节点仅计算自己的转发表；其他节点也自行执行类似的计算。这就意味着在LS算法下，路由计算在某种程度上是分离的，提供了一定程度的健壮性。在DV算法下，一个节点可向任意或所有目的节点通告其不正确的最低开销路径。更一般地，每次迭代时，在DV算法中一个节点的计算会传递给它的邻居，然后在下次迭代时再间接地传递给邻居的邻居。在此情况下，DV算法中一个不正确的节点计算值会扩散到整个网络

## 5.3 因特网中自治系统(AS)内部的路由算法：OSPF

在我们至今为止的算法研究中，我们将网络只看作一个互联路由器的集合。从所有路由器执行相同的路由选择算法以计算穿越整个网络的路由选择路径的意义上来说，一台路由器很难同另一台路由器区别开来。在实践中，该模型和这种一组执行同样路由选择算法的同质路由器集合的观点有一点简单化，有以下两个重要原因↓：

* **规模**：随着路由器数目变得很大，涉及路由选择信息的通信、计算和存储的开销将高得不可实现。当今的因特网由数亿台主机组成。在这些主机中存储的路由选择信息显然需要巨大容量的内存。在所有路由器之间广播连通性和链路开销更新所要求的负担将是巨大的！在如此大量的路由器中迭代的距离向量算法将肯定永远无法收敛！显然，必须采取一些措施以减少像因特网这种大型网络中的路由计算的复杂性

* **管理自治**：因特网是ISP的网络，其中每个ISP都有它自己的路由器网络。ISP通常希望按自己的意愿运行路由器(如在自己的网络中运行它所选择的某种路由选择算法)，或对外部隐藏其网络的内部组织面貌。在理想情况下，一个组织应当能够按自己的愿望运行和管理其网络，还要能将其网络与其他外部网络连接起来

这两个问题都可以通过将路由器组织进**自治系统(AS**)来解决，其中每个AS由一组通常处在相同管理控制下的路由器组成。通常在一个ISP中的路由器以及互联它们的链路构成一个AS。然而，某些ISP将它们的网络划分为多个AS。特别是，某些一级ISP在其整个网络中使用一个庞大的AS，而其他ISP则将它们的ISP拆分为数十个互联的AS。一个自治系统由其全局唯一的AS号(ASN)所标识。就像IP地址那样，AS号由ICANN区域注册机构所分配

在相同AS中的路由器都运行相同的路由选择算法并且有彼此的信息。在一个自治系统内运行的路由选择算法叫作**自治系统内部路由选择协议**

**开放最短路优先(OSPF**)路由选择及其关系密切的协议IS-IS都被广泛用于因特网的AS内部路由选择

OSPF是一种链路状态协议，它使用洪泛链路状态信息和Dijkstra最低开销路径算法。使用OSPF，一台路由器构建了一幅关于整个自治系统的完整拓扑图(即一幅图)。于是，每台路由器在本地运行Dijkstra的最短路径算法，以确定一个以自身为根节点到所有子网的最短路径树。各条链路开销是由网络管理员配置的。管理员也许会选择将所有链路开销设为1，因而实现了最少跳数路由选择，或者可能会选择将链路权值按与链路容量成反比来设置，从而不鼓励流量使用低带宽链路。OSPF不强制使用设置链路权值的策略(那是网络管理员的任务)，而是提供了一种机制(协议)，为给定链路权值集合确定最低开销路径的路由选择

使用OSPF时，路由器向自治系统内所有其他路由器广播路由选择信息，而不仅仅是向其相邻路由器广播。每当一条链路的状态发生变化时(如开销的变化或连接/中断状态的变化)，路由器就会广播链路状态信息。即使链路状态未发生变化，它也要周期性地(至少每隔30min-次)广播链路状态。标准中有这样的说明："链路状态通告的这种周期性更新增加了链路状态算法的健壮性。"OSPF通告包含在OSPF报文中，该OSPF报文直接由IP承载，对OSPF其上层协议的值为89。因此OSPF协议必须自己实现诸如可靠报文传输、链路状态广播等功能。OSPF协议还要检查链路正在运行(通过向相连的邻居发送HELLO报文)，并允许OSPF路由器获得相邻路由器的网络范围链路状态的数据库

OSPF的优点包括下列几方面↓：

* **安全**：能够鉴别OSPF路由器之间的交换(如链路状态更新)。使用鉴别，仅有受信任的路由器能参与一个AS内的OSPF协议，因此可防止恶意入侵者将不正确的信息注入路由器表内。在默认状态下，路由器间的OSPF报文是未被鉴别的并能被伪造。能够配置两类鉴别，即简单的和MD5的(参见[第8章 计算机网络中的安全](8.计算机网络中的安全.md)有关MD5和鉴别的一般性讨论)。使用简单的鉴别，每台路由器配置相同的口令。当一台路由器发送一个OSPF分组，它以明文方式包括了口令。显然，简单鉴别并不是非常安全。MD5鉴别基于配置在所有路由器上的共享秘密密钥。对发送的每个OSPF分组，路由器对附加了秘密密钥的OSPF分组内容计算MD5散列值(参见[第8章 计算机网络中的安全](8.计算机网络中的安全.md)中报文鉴别码的讨论)。然后路由器将所得的散列值包括在该OSPF分组中。接收路由器使用预配置的秘密密钥计算出该分组的MD5散列值，并与该分组携带的散列值进行比较，从而验证了该分组的真实性。在MD5鉴别中也使用了序号对重放攻击进行保护

* **多条相同开销的路径**：当到达某目的地的多条路径具有相同的开销时，OSPF允许使用多条路径(这就是说，当存在多条相等开销的路径时，无须仅选择单一的路径来承载所有的流量)

* **对单播与多播路由选择的综合支持**：多播OSPF(MOSPF)提供对OSPF的简单扩展，以便提供多播路由选择。MOSPF使用现有的OSPF链路数据库，并为现有的OSPF链路状态广播机制增加了一种新型的链路状态通告

* **支持在单个AS中的层次结构**：一个OSPF自治系统能够层次化地配置多个区域。每个区域都运行自己的OSPF链路状态路由选择算法，区域内的每台路由器都向该区域内的所有其他路由器广播其链路状态。在每个区域内，一台或多台区域边界路由器负责为流向该区域以外的分组提供路由选择。最后，在AS中只有一个OSPF区域配置成主干区域。主干区域的主要作用是为该AS中其他区域之间的流量提供路由选择。该主干总是包含本AS中的所有区域边界路由器，并且可能还包含了一些非边界路由器。在AS中的区域间的路由选择要求分组先路由到一个区域边界路由器(区域内路由选择)，然后通过主干路由到位于目的区域的区域边界路由器，进而再路由到最终目的地。

## 5.4 ISP之间的路由选择：BGP

OSPF是一个AS内部路由选择协议。当在相同AS内的源和目的地之间进行分组选路时，分组遵循的路径完全由AS内路由选择协议所决定。然而，当分组跨越多个AS进行路由时，我们需要一个自治系统间路由选择协议。因为AS间路由选择协议涉及多个AS之间的协调，所以AS通信必须运行相同的AS间路由选择协议。在因特网中，所有的AS运行相同的AS间路由选择协议，称为边界网关协议(BGP)

BGP无疑是所有因特网协议中最为重要的(唯一竞争者可能是[4.3 网际协议：IPv4、寻址、IPv6及其他](4.网络层：数据平面.md#43-网际协议ipv4寻址ipv6及其他)中的IP协议)，因为正是这个协议将因特网中数以千计的ISP黏合起来。BGP是一种分布式和异步的协议，与[5.2.2 距离向量路由选择算法](#522-距离向量路由选择算法)中描述的距离向量路由选择协议一脉相承

### 5.4.1 BGP的作用

为了理解BGP的职责所在，考虑一个AS和在该AS中的任意一个路由器。每台路由器具有一张转发表，该转发表在将到达分组转发到出路由器链路的过程中起着主要作用。对于位于相同AS中的目的地而言，在路由器转发表中的表项由AS内部路由选择协议所决定。而对于位于该AS外部的目的地而言情况如何呢？这正是BGP用武之地

在BGP中，分组并不是路由到一个特定的目的地址，相反是路由到CIDR化的前缀，其中每个前缀表示一个子网或一个子网的集合。在BGP的世界中，一个目的地可以采用138.16.68/22的形式，对于这个例子来说包括1024个IP地址。因此，一台路由器的转发表将具有形式为(x，I)的表项，其中x是一个前缀(例如138.16.68/22)，I是该路由器的接口之一的接口号

作为一种AS间的路由选择协议，BGP为每台路由器提供了一种完成以下任务的手段↓：

1. **从邻居AS获得前缀的可达性信息**：特别是，BGP允许每个子网向因特网的其余部分通告它的存在，而BGP确保在因特网中的所有AS知道该子网。如果没有BGP的话，每个子网将是隔离的孤岛，即它们孤独地存在，不为因特网其余部分所知和所达

2. **确定到该前缀的"最好的"路由**：一台路由器可能知道两条或更多条到特定前缀的不同路由。为了确定最好的路由，该路由器将本地运行一个BGP路由选择过程(使用它经过相邻的路由器获得的前缀可达性信息)。该最好的路由将基于策略以及可达性信息来确定

### 5.4.2 通告BGP路由信息

对于每个AS，每台路由器要么是一台**网关路由器**，要么是一台**内部路由器**。网关路由器是一台位于AS边缘的路由器，它直接连接到在其他AS中的一台或多台路由器。内部路由器仅连接在它自己AS中的主机和路由器

在BGP中，每对路由器通过使用179端口的半永久TCP连接交换路由选择信息。每条直接连接以及所有通过该连接发送的BGP报文，称为**BGP连接**。此外，跨越两个AS的BGP连接称为**外部BGP(eBGP)连接**，而在相同AS中的两台路由器之间的BGP会话称为**内部BGP(iBGP)连接**。对于直接连接在不同AS中的网关路由器的每条链路而言，通常有一条eBGP连接。在每个AS中的路由器之间还有多条iBGP连接。注意到iBGP连接并不总是与物理链路对应。为了传播可达性信息，使用了iBGP和eBGP会话

在真实的网络中，从某个给定的路由器到某个给定的目的地可能有多条不同的路径，每条通过了不同的AS序列

### 5.4.3 确定最好的路由

* 介绍BGP术语如下↓：

	* 当路由器通过BGP连接通告前缀时，它在前缀中包括一些**BGP属性**。用BGP术语来说，前缀及其属性称为**路由**。两个较为重要的属性是AS-PATH和NEXT-HOP。AS-PATH属性包含了通告已经通过的AS的列表。为了生成AS-PATH的值，当一个前缀通过某AS时，该AS将其ASN加入AS-PATH中的现有列表。BGP路由器还使用AS-PATH属性来检测和防止通告环路；特别是，如果一台路由器在路径列表中看到包含了它自己的AS，它将拒绝该通告

	* 在AS间和AS内部路由选择协议之间提供关键链路方面，NEXT-PATH属性具有敏感而重要的作用。NEXT-HOP是AS-PATH起始的路由器接口的IP地址每条BGP路由包含3个组件：NEXT-HOP；AS-PATH；目的前缀。在实践中，一条BGP路由还包括其他属性，眼下我们将暂且忽略它。注意到NEXT HOP属性是不属于AS1的某路由器的IP地址；然而，包含该IP地址的子网直接连接到AS1

1. 热土豆路由选择

使用热土豆路由选择，(从所有可能的路由中)选择的路由到开始该路由的NEXT-HOP路由器具有最小开销。在3个AS的例子中，路由器1b将査阅它的AS内部路由选择信息，以找到通往NEXT-HOP路由器2a的最低开销AS内部路径以及通往NEXT-HOP路由器3d的最低开销AS间路径，进而选择这些最低开销路径中具有最低开销的那条。例如，假设开销定义为穿越的链路数。则从路由器1b到路由器2a的最低开销是2，从路由器1b到路由器2d的最低开销是3，因此将选择路由器2a。路由器1b则将査阅它的转发表(由它的AS内部算法所配置)，并且找到通往路由器2a的位于最低开销路径上的接口I。1b则把(x，I)加到它的转发表中

在一台路由器转发表中对于热土豆路由选择增加AS向外前缀的步骤如下所示。注意到下列问题是重要的：当在转发表中增加AS向外前缀时，AS间路由选择协议(BGP)和AS内部路由选择协议(如OSPF)都要用到↓：1.从AS间协议学到经多个网关可达子网x；2.使用来自AS内部协议的路由选择信息，以决定到达每个网关的最低开销路径的开销；3.热土豆路由选择，选择具有最小最低开销的网关；4.从转发表确定通往最低开销网关的接口I在转发表中加入表项(x，I)

热土豆路由选择依据的思想是：对于路由器1b，尽可能快地将分组送出其AS(更明确地说，用可能的最低开销)，而不担心其AS外部到目的地的余下部分的开销。就"热土豆路由选择"名称而言，分组被类比为烫手的热土豆。因为它烫手，你要尽可能快地将它传给另一个人(另一个AS)。热土豆路由选择因而是自私的算法，即它试图减小在它自己AS中的开销，而忽略在其AS之外的端到端开销的其他部分。注意到使用热土豆路由选择，对于在相同AS中的两台路由器，可能对相同的前缀选择两条不同的AS路径

2. 路由器选择算法

在实践中，BGP使用了一种比热土豆路由选择更为复杂但却结合了其特点的算法。对于任何给定的目的地前缀，进入BGP的路由选择算法的输入是到某前缀的所有路由的集合，该前缀是已被路由器学习和接受的。如果仅有一条这样的路由，BGP则显然选择该路由。如果到相同的前缀有两条或多条路由，则顺序地调用下列消除规则直到余下一条路由↓：

1.路由被指派一个本地偏好值作为其属性之一(除了AS-PATH和NEXT-HOP以外)。一条路由的本地偏好可能由该路由器设置或可能由在相同AS中的另一台路由器学习到。本地偏好属性的值是一种策略决定，它完全取决于该AS的网络管理员(我们随后将更为详细地讨论BGP策略问题)。具有最高本地偏好值的路由将被选择

2.从余下的路由中(所有都具有相同的最高本地偏好值)，将选择具有最短AS-PATH的路由。如果该规则是路由选择的唯一规则，则BGP将使用距离向量算法决定路径，其中距离测度使用AS跳的跳数而不是路由器跳的跳数

3.从余下的路由中(所有都具有相同的最高本地偏好值和相同的AS-PATH长度)，使用热土豆路由选择，即选择具有最靠近NEXT-HOP路由器的路由

4.如果仍留下多条路由，该路由器使用BGP标识符来选择路由

使用上述路由选择算法，BGP不再是一种自私的算法，即它先查找具有短AS路径的路由(因而很可能减小端到端时延)

### 5.4.4 IP任播

除了作为因特网的AS间路由选择协议外，BGP还常被用于实现**IP任播服务**，该服务通常用于DNS中。为了说明IP任播的动机，考虑在许多应用中，我们对下列情况感兴趣：1.在许多分散的不同地理位置，替换不同服务器上的相同内容；2.让每个用户从最靠近的服务器访问内容。例如，一个CDN能够更换位于不同国家、不同服务器上的视频和其他对象。类似地，DNS系统能够在遍及全世界的DNS服务器上复制DNS记录。当一个用户要访问该复制的内容，可以将用户指向具有该复制内容的"最近的"服务器。BGP的路由选择算法为做这件事提供了一种最为容易和自然的机制

为使讨论具体，我们描述CDN可能使用IP任播的方式。在IP任播配置阶段，CDN公司为它的多台服务器指派相同的IP地址，并且使用标准的BGP从这些服务器的每台来通告该IP地址。当某台BGP路由器收到对于该IP地址的多个路由通告，它将这些通告处理为对相同的物理位置提供不同的路径(事实上，这时这些通告对不同的物理位置是有不同路径的)。当配置其路由选择表时，每台路由器将本地化地使用BGP路由选择算法来挑选到该IP地址的"最好的"(例如，由AS跳计数确定的最近的)路由。例如，如果一个BGP路由(对应于一个位置)离该路由器仅一AS跳的距离，并且所有其他BGP路由(对应于其他位置)是两AS跳和更多AS跳，则该BGP路由器将选择把分组路由到一跳远的那个位置。在这个初始BGP地址通告阶段后，CDN能够进行其分发内容的主要任务。当某客户请求视频时，CDN向该客户返回由地理上分散的服务器所使用的共同IP地址，而无论该客户位于何处。当该客户想向那个IP地址发送一个请求时，因特网路由器则向那个"最近的"服务器转发该请求分组，最近的服务器是由BGP路由选择算法所定义的

尽管上述CDN的例子很好地诠释了能够如何使用IP任播，但实践中CDN通常选择不使用IP任播，因为BGP路由选择变化能够导致相同的TCP连接的不同分组到达Web服务器的不同实例。但IP任播被DNS系统广泛用于将DNS请求指向最近的根DNS服务器。[2.4 DNS(域名系统)：因特网的目录服务](#24-dns域名系统因特网的目录服务)中讲过，到写书时根DNS服务器有13个IP地址。但对应于这些地址的每一个，有多个DNS根服务器，其中有些地址具有100多个DNS根服务器分散在世界的各个角落。当一个DNS请求向这13个IP地址发送时，使用IP任播将该请求路由到负责该地址的最近的那个DNS根服务器

### 5.4.5 路由选择策略

当某路由器选择到目的地的一条路由时，AS路由选择策略能够胜过所有其他考虑，例如最短AS路径或热土豆路由选择。在路由选择算法中，实际上首先根据本地偏好属性选择路由，本地偏好值由本地AS的策略所确定

用一个简单的例子说明BGP路由选择策略的某些基本概念。假设有6个互联的自治系统：A、B、C、W、X和Y。假设自治系统W、X和Y是接入ISP，而A、B和C是主干提供商网络。我们还要假设A、B和C直接向彼此发送流量，并向它们的客户网络提供全部的BGP信息。所有进入一个接入ISP网络的流量必定是以该网络为目的地，所有离开一个接入ISP网络的流量必定源于该网络。多宿接入ISP是经由两个不同的提供商连到网络的其余部分(这种方法在实践中变得越来越普遍)。但这种桩网络的行为是如何实现和强制实现的呢？X如何防止转发B与C之间的流量呢？这能够通过控制BGP路由的通告方式容易地实现。特别是，X如果(向其邻居B和C)通告它没有通向(除自身以外)任何其他目的地的路径，那么它将起到一个接入ISP的作用。即使X可能知道一条路径(比如说XCY)能到达网络Y，它也将不把该条路径通告给B。由于B不知道X有一条路径到Y，B绝不会经由X转发目的为Y(或C)的流量。这个简单的例子说明了如何使用一条选择的路由通告策略来实现客户/提供商路由选择关系

我们接下来关注一个提供商网络，比如自治系统B。假定B已经(从A处)知道了A有一条到W的路径AW。B因此能将路由AW安装到其路由信息库中。显然，B也想向它的客户X通告路径BAW，这样X知道它能够通过B路由到W。但是，B应该将路径BAW通告给C吗？如果它这样做，则C可以经由BAW将流量引导到W。如果A、B和C都是主干提供商，而B也许正好觉得它不应该承担在A与C之间传送流量的负担(和开销)。B可能有理由认为，确保C能经过A和C之间的直接连接引导A客户的来去流量是A和C的工作(和开销)。目前还没有强制主干ISP之间如何路由选择的官方标准。然而，商业运行的ISP们都遵从的一个经验法则是：任何穿越某ISP主干网的流量必须是其源或目的(或两者)位于该ISP的某个客户网络中；不然的话这些流量将会免费搭车通过该ISP的网络。各个对等协定(用于解决前面提到的问题)通常都是ISP双方进行协商，而且经常是对外保密的

### 5.4.6拼装在一起：在因特网中呈现

尽管本小节不是有关BGP本身的，但它将我们到此为止看到的许多协议和概念结合到一起，包括IP地址、DNS和BGP

假定你只是创建了一个具有若干服务器的小型公司网络，包括一台描述公司产品和服务的公共Web服务器，一台从你的雇员获得他们的电子邮件报文的电子邮件服务器和一台DNS服务器。你当然乐意整个世界能够访问你的Web站点，以得知你的现有产品和服务。此外，你将乐意你的雇员能够向遍及世界的潜在客户发送和接收电子邮件

为了满足这些目标，你首先需要获得因特网连接，要做到这一点，需要与本地ISP签订合同并进行连接。你的公司将有一台网关路由器，该路由器将与本地ISP的一台路由器相连。你的本地ISP也将为你提供一个IP地址范围，例如由256个地址组成的一个/24地址范围。一旦你有了自己的物理连接和IP地址范围，你将在该地址范围内分配IP地址：一个给你的Web服务器，一个给你的电子邮件服务器，一个给你的DNS服务器，一个给你的网关路由器，并将其他IP地址分配给公司网络中的其他服务器和联网设备

除了与一个ISP签订合同外，你还需要与一个因特网注册机构签订合同，以便为你的公司获得一个域名，如在[第2章 应用层](2.应用层.md)中所描述的那样。具体而言，因为外部世界将要联系你的DNS服务器以获得该服务器的IP地址，所以你还需要为注册机构提供你的DNS服务器的IP地址。该注册机构则在.com顶级域名服务器中为你的DNS服务器设置一个表项(域名和对应的IP地址)，如[第2章 应用层](2.应用层.md)所述。在这个步骤完成后，任何知道你的域名的用户将能够经过DNS系统获得你DNS服务器的IP地址

为了使人们能够发现你的Web服务器的IP地址，你需要在你的DNS服务器中包括一个将你的Web服务器的主机名映射到它的IP地址的表项。你还要为公司中其他公共可用的服务器设置类似的表项，包括你的电子邮件服务器。如此一来，如果Alice要浏览你的Web服务器，DNS系统将联系你的DNS服务器，找到你的Web服务器的IP地址，并将其给Alice。Alice则能与你的Web服务器创建一个直接的TCP连接

然而，允许来自世界各地的外部人员访问你的Web服务器，仍然还有一个必要的、决定性的步骤。考虑当Alice做下列事情发生的状况：Alice知道你的Web服务器的IP地址，她向该IP地址发送一个IP数据报(例如一个TCP SYN报文段)。该数据报将通过因特网进行路由，经历了在许多不同的自治系统中的一系列路由器，最终到达你的Web服务器。当任何一个路由器收到该数据报时，将去它的转发表中寻找一个表项来确定转发该数据报的外出端口。因此，每台路由器需要知道你公司的/24前缀(或者某些聚合项)。一台路由器如何知道你公司的前缀呢？如我们刚才看到的那样，它从BGP知道了该前缀。具体而言，当你的公司与本地ISP签订合同并且获得了分配的前缀(即一个地址范围)，你的本地ISP将使用BGP向与之连接的ISP通告你的前缀。这些ISP将依次使用BGP来传播该通告。最终，所有的因特网路由器将得知了你的前缀(或者包括你的前缀的某个聚合项)，因而能够将数据报适当地转发到适当的Web和电子邮件服务器

## 5.5 SDN控制平面

在本节中，我们将深入SDN控制平面，即控制分组在网络的SDN使能设备中转发的网络范围逻辑，以及这些设备和它们的服务的配置与管理。这里的学习建立在前面[4.4 通用转发和SDN(软件定义网络)](4.网络层：数据平面.md#44-通用转发和sdn软件定义网络)中一般化SDN转发讨论的基础上，以及[5.1 概述](#51-概述)。如同[4.4 通用转发和SDN(软件定义网络)](4.网络层：数据平面.md#44-通用转发和sdn软件定义网络)中一样，我们将再次采用在SDN文献中所使用的术语，将网络的转发设备称之为"分组交换机"(或直接称为交换机，理解时带上"分组"二字)，因为能够根据网络层源/目的地址、链路层源/目的地址以及运输层、网络层和链路层中分组首部字段做出转发决定

SDN体系结构具有4个关键特征↓：

* **基于流的转发**：SDN控制的交换机的分组转发工作，能够基于运输层、网络层或链路层首部中任意数量的首部字段值进行。在[4.4 通用转发和SDN(软件定义网络)](4.网络层：数据平面.md#44-通用转发和sdn软件定义网络)中，我们看到了 OpenFlow 1.0抽象允许基于11个不同的首部字段值进行转发。这与我们5.2〜5.4节中学习的基于路由器转发的传统方法形成了鲜明的对照，传统方法中IP数据报的转发仅依据数据报的目的IP地址进行。分组转发规则被精确规定在交换机的流表中；SDN控制平面的工作是计算、管理和安装所有网络交换机中的流表项

* **数据平面与控制平面分离**：数据平面由网络交换机组成，交换机是相对简单(但快速)的设备，该设备在它们的流表中执行"匹配加动作"的规则。控制平面由服务器以及决定和管理交换机流表的软件组成

* **网络控制功能**：位于数据平面交换机外部。考虑到SDN中的"S"表示"软件"，也许SDN控制平面由软件实现并不令人惊讶。然而，与传统的路由器不同，这个软件在服务器上执行，该服务器与网络交换机截然分开且与之远离。控制平面自身由两个组件组成：一个SDN控制器(或网络操作系统)，以及若干网络控制应用程序。控制器维护准确的网络状态信息(例如，远程链路、交换机和主机的状态)；为运行在控制平面中的网络控制应用程序提供这些信息；提供方法，这些应用程序通过这些方法能够监视、编程和控制下面的网络设备。实践中控制器仅是逻辑上集中的，通常在几台服务器上实现，这些服务器提供协调的、可扩展的性能和高可用性

* **可编程的网络**：通过运行在控制平面中的网络控制应用程序，该网络是可编程的。这些应用程序代表了SDN控制平面的"智力"，使用了由SDN控制器提供的API来定义和控制网络设备中的数据平面。例如，一个路由选择网络控制应用程序可以决定源和目的地之间的端到端路径(例如，通过使用由SDN控制器维护的节点状态和链路状态信息，执行Dijkstra算法)。另一个网络应用程序可以执行访问控制，即决定交换机阻挡哪个分组。还有一个应用程序可以用执行服务器负载均衡的方式转发分组

SDN表示了一种意义重大的网络功能的"分类"，即数据平面交换机、SDN控制器和网络控制应用程序是分离的实体，该实体可以由不同的厂商和组织机构所提供。这与SDN之前模式形成了鲜明对照，在SDN之前模式中，交换机/路由器(连同其嵌入的控制平面软件和协议实现)是一个整体，它是垂直、综合的，并且由单一的厂商所销售。在SDN中的这种网络功能分类，可以与大型计算机到个人计算机的早期演化相比拟，前者的硬件、系统软件和应用程序是由单一厂商所提供的，而后者具有各自的硬件、操作系统和应用程序。计算硬件、系统软件和应用程序的分类，无疑已经在所有这三个领域的创新驱动下导致了丰富、开放的生态系统。对SDN的希望是，它也将导致如此丰富的创新

### 5.5.1 SDN控制平面：SDN控制器和SDN网络控制应用程序

SDN控制平面大体划分为两个部分，即SDN控制器和SDN网络控制应用程序。控制器的功能可大体组织为3个层次。我们以一种非典型的自底向上方式考虑这些层次↓：

* **通信层**：SDN控制器和受控网络设备之间的通信。显然，如果SDN控制器要控制远程SDN使能的交换机、主机或其他设备的运行，需要一个协议来传送控制器与这些设备之间的信息。此外，设备必须能够向控制器传递本地观察到的事件(例如，一个报文指示一条附属链路已经激活或停止，一个设备刚刚加入了网络，或一个心跳指示某设备已经启动和运行)。这些事件向SDN控制器提供该网络状态的最新视图。这个协议构成了控制器体系结构的最底层。控制器和受控设备之间的通信跨越了一个接口，它现在被称为控制器的"南向"接口

* **网络范围状态管理层**：由SDN控制平面所做出的最终控制决定(例如配置所有交换机的流表以取得所希望的端到端转发，实现负载均衡，或实现一种特定的防火墙能力)，将要求控制器具有有关网络的主机、链路、交换机和其他SDN控制设备的最新状态信息少交换机的流表包含计数器，其值也可以由网络控制应用程序很好地使用；因此这些值应当为应用程序所用。既然控制平面的终极目标是决定用于各种受控设备的流表，控制器也就可以维护这些表的拷贝。这些信息都构成了由SDN控制器维护的网络范围"状态"的例子

* **对于网络控制应用程序层的接口**。控制器通过它的"北向"接口与网络控制应用程序交互。该API允许网络控制应用程序在状态管理层之间读/写网络状态和流表。当状态改变事件出现时，应用程序能够注册进行通告。可以提供不同类型的API

SDN控制器被认为是"逻辑上集中"的，即该控制器可以被外部视为一个单一、整体的服务(例如，从SDN控制设备和外部的网络控制应用程序的角度看)。然而，出于故障容忍、高可用性或性能等方面的考虑，在实践中这些服务和用于保持状态信息的数据库一般通过分布式服务器集合实现。在服务器集合实现控制器功能时，必须考虑控制器的内部操作(例如维护事件的逻辑时间顺序、一致性、意见一致等)的语义

## 5.6 ICMP：因特网控制报文协议

**因特网控制报文协议(ICMP**)：主机和路由器用来彼此沟通网络层的信息。ICMP最典型的用途是差错报告。例如，当运行一个HTTP会话时，你也许会遇到一些诸如"目的网络不可达"之类的错误报文。这种报文就来源于ICMP。在某个位置，IP路由器不能找到一条通往HTTP请求中所指定的主机的路径，该路由器就会向你的主机生成并发出一个ICMP报文以指示该错误

ICMP通常被认为是IP的一部分，但从体系结构上讲它位于IP之上，因为ICMP报文是承载在IP分组中的。这就是说，ICMP报文是作为IP有效载荷承载的，就像TCP与UDP报文段作为IP有效载荷被承载那样。类似地，当一台主机收到一个指明上层协议为ICMP的IP数据报时(上层协议编码为1)，它分解出该数据报的内容给ICMP，就像分解岀一个数据报的内容给TCP或UDP一样

ICMP报文有一个类型字段和一个编码字段，并且包含引起该ICMP报文首次生成的IP数据报的首部和前8个字节(以便发送方能确定引发该差错的数据报)。注意ICMP报文并不仅是用于通知差错情况

众所周知的ping程序发送一个ICMP类型8编码0的报文到指定主机。看到回显(echo)请求，目的主机发回一个类型0编码0的ICMP回显回答。大多数TCP/IP实现直接在操作系统中支持ping服务器，即该服务器不是一个进程

另一个有趣的ICMP报文是源抑制报文。这种报文在实践中很少使用。其最初目的是执行拥塞控制，即使得拥塞的路由器向一台主机发送一个ICMP源抑制报文，以强制该主机减小其发送速率。我们在[3.5.5 流量控制](3.运输层.md#355-流量控制)已看到，TCP在运输层有自己的拥塞控制机制，不需要利用网络层中的反馈信息，如ICMP源抑制报文

在RFC 4443中为IPv6定义了ICMP的新版本。除了重新组织现有的ICMP类型和编码定义外，ICMPv6还增加了新型IPv6功能所需的新类型和编码。这些包括"分组太大"类型和一个"未被承认的IPv6选项"差错编码

## 5.7 网络管理和SNMP

网络是由许多复杂、交互的硬件和软件部件组成的，既包括构成网络的物理部件的链路、交换机、路由器、主机和其他设备，也包括控制和协调这些设备的许多协议。当一个机构将数以百计或数以千计的这种部件拼装在一起形成一个网络时，保持该网络"运行良好"对网络管理员无疑是一种挑战。我们在[5.5 SDN控制平面](#55-sdn控制平面)中看到，SDN环境中逻辑上集中的控制器能够有助于这种过程。但是网络管理的挑战在SDN出现前很久就已如影相随了，网络管理员使用丰富的网络管理工具和方法来监视、管理和控制该网络

网络管理包括了硬件、软件和人类元素的设置、综合和协调，以监视、测试、轮询、配置、分析、评价和控制网络及网元资源，用合理的成本满足实时性、运营性能和服务质量的要求

### 5.7.1 网络管理框架

网络管理的关键组件如下所示↓：

* **管理服务器**是一个应用程序，通常有人的参与，并运行在网络运营中心(NOC)的集中式网络管理工作站上。管理服务器是执行网络管理活动的地方，它控制网络管理信息的收集、处理、分析和/或显示。正是在这里，发起控制网络行为的动作，人类网络管理员与网络设备打交道

* **被管设备**是网络装备的一部分(包括它的软件)，位于被管理的网络中。被管设备可以是一台主机、路由器、交换机、中间盒、调制解调器、温度计或其他联网的设备。在一个被管设备中，有几个所谓**被管对象**。这些被管对象是被管设备中硬件的实际部分(例如，一块网络接口卡只是一台主机或路由器的一个组件)和用于这些硬件及软件组件的配置参数(例如，像OSPF这样的AS内部路由选择协议)

* 一个被管设备中的每个被管对象的关联信息收集在**管理信息库(MIB**)中，我们将看到这些信息的值可供管理服务器所用(并且在许多场合下能够被设置)。一个MIB对象可以是：一个计数器，例如由于IP数据报首部差错而由路由器丢弃的IP数据报的数量，或一台主机接收到的UDP报文段的数量；运行在一台DNS服务器上的软件版本的描述性信息；诸如一个特定设备功能是否正确的状态信息；或诸如到一个目的地的路由选择路径的特定协议的信息。MIB对象由称为SMI的数据描述语言所定义。使用形式化定义语言可以确保网络管理数据的语法和语义是定义良好的和无二义性的。相关的MIB对象被收集在MIB模块中

* 在每个被管设备中还驻留有**网络管理代理**，它是运行在被管设备中的一个进程，该进程与管理服务器通信，在管理服务器的命令和控制下在被管设备中采取本地动作。网络管理代理类似于[5.1 概述](#51-概述)中的逻辑集中式控制的路由选择代理

* **网络管理框架的最后组件是网络管理协议**：该协议运行在管理服务器和被管设备之间，允许管理服务器查询被管设备的状态，并经过其代理间接地在这些设备上采取行动。代理能够使用网络管理协议向管理服务器通知异常事件(如组件故障或超过了性能阈值)。重要的是注意到网络管理协议自己不能管理网络。恰恰相反，它为网络管理员提供了一种能力，使他们能够管理("监视、测试、轮询、配置、分析、评价和控制")网络。这是一种细微但却重要的区别

### 5.7.2 简单网络管理协议(SNMP)

简单网络管理协议版本2(SNMPv2)是一个应用层协议，用于在管理服务器和代表管理服务器执行的代理之间传递网络管理控制和信息报文。SNMP最常使用的是请求响应模式，其中SNMP管理服务器向SNMP代理发送一个请求，代理接收到该请求后，执行某些动作，然后对该请求发送一个回答。请求通常用于查询(检索)或修改(设置)与某被管设备关联的MIB对象值。SNMP第二个常被使用的是代理向管理服务器发送的一种非请求报文，该报文称为**陷阱报文**。陷阱报文用于通知管理服务器，一个异常情况(例如一个链路接口启动或关闭)已经导致了MIB对象值的改变

SNMPv2定义了7种类型的报文，这些报文一般称为协议数据单元(PDU)。到尽管SNMPPDU能够通过许多不同的运输协议传输，但SNMP PDU通常是作为UDP数据报的载荷进行传输的。标准的确表明UDP是"首选的运输映射"。然而，由于UDP是一种不可靠的运输协议，因而不能确保一个请求或它的响应能够被它希望的目的地接收到。管理服务器用该PDU的请求ID字段为它向代理发送的请求编号；该代理的响应从接收到的请求中获取它的请求ID。因此，该请求ID字段能被管理服务器用来检测丢失的请求或回答。如果在一定时间后还没有收到对应的响应，由管理服务器来决定是否重传一个请求。特别是，SNMP标准没有强制任何特殊的重传过程，即使初始进行重传。它只是要求管理服务器"需要根据重传的频率和周期做岀负责任的动作"。当然，这使人想知道一个"负责任的"协议应当如何动作

## 5.8 小结

我们现在已经完成了进入网络核心的两章旅程，即开始于[第4章 网络层：数据平面](4.网络层：数据平面.md)的网络层数据平面的学习和本章完成的网络层控制平面的学习。我们知道了控制平面是网络范围的逻辑，它不仅控制从源主机到目的主机沿着端到端路径在路由器之间如何转发数据报，而且控制网络层组件和服务器如何配置和管理

我们学习了构建控制平面有两大类方法：传统的每路由器控制(其中在每台路由器中运行算法，并且路由器中的路由选择组件与其他路由器中的路由选择组件通信)和软件定义网络(SDN)控制(其中一个逻辑上集中的控制器计算并向每台路由器分发转发表为它们所用)。我们在[5.2 路由选择算法](#52-路由选择算法)中学习了两种基本的路由选择算法，即链路状态和距离矢量，用于计算图中的最小开销路径；这些算法在每路由器控制和SDN控制中都有应用。这些算法是两种广泛部署的因特网路由选择协议OSPF和BGP的基础，我们在[5.3 因特网中自治系统(AS)内部的路由算法：OSPF](#53-因特网中自治系统as内部的路由算法ospf)和[5.4 ISP之间的路由选择：BGP](#54-isp之间的路由选择bgp)中讨论了这两种协议。我们在[5.5 SDN控制平面](#55-sdn控制平面)中讨论了网络层控制平面的SDN方法，研究了SDN网络控制应用程序、SDN控制器，以及控制器和SDN控制设备之间通信所使用的OpenFlow协议。在[5.6 ICMP：因特网控制报文协议](#56-icmp因特网控制报文协议)和[5.7 网络管理和SNMP](#57-网络管理和snmp)中，我们包括了管理IP网络的某些技术细节：ICMP(互联网控制报文协议)和SNMP(简单网络管理协议)

在完成了网络层学习之后，我们的旅行此时沿着协议栈向下走了一步，即到了链路层。像网络层一样，链路层是每台网络连接的设备的一部分。但我们将在[第6章 链路层和局域网](6.链路层和局域网.md)中看到，链路层的任务是在相同链路或局域网之间更局域化地移动分组。尽管这种任务从表面上看可能比网络层任务简单得多，但我们将看到，链路层涉及许多重要和引人入胜的问题，这些问题会花费我们不少时间
