- [3. Java的基本程序设计结构](#3-java的基本程序设计结构)
	- [3.1 一个简单的Java程序](#31-一个简单的java程序)
	- [3.2 注释](#32-注释)
	- [3.3 数据类型](#33-数据类型)
	- [3.4 变量](#34-变量)
		- [3.4.1 变量初始化](#341-变量初始化)
		- [3.4.2 常量](#342-常量)
		- [3.5 运算符](#35-运算符)
		- [3.5.2 数值类型之间的转换](#352-数值类型之间的转换)
		- [3.5.3 强制类型转换](#353-强制类型转换)
	- [3.8 控制流程](#38-控制流程)
		- [3.8.1 块作用域](#381-块作用域)
		- [3.8.6 中断控制流程语句](#386-中断控制流程语句)
- [4. 对象与类](#4-对象与类)
	- [4.3 用户自定义类](#43-用户自定义类)
		- [4.3.4 从构造器开始](#434-从构造器开始)
		- [4.3.7 基于类的访问权限](#437-基于类的访问权限)
	- [4.5 方法参数](#45-方法参数)
	- [4.6 对象构造](#46-对象构造)
		- [4.6.2 默认域初始化](#462-默认域初始化)
		- [4.6.6 调用另一个构造器](#466-调用另一个构造器)
		- [4.6.7 初始化数据域的方法](#467-初始化数据域的方法)
		- [4.6.8 对象析构与finalize方法](#468-对象析构与finalize方法)
	- [4.7 包](#47-包)
		- [4.7.1 类的导入](#471-类的导入)
		- [4.7.2 静态导入](#472-静态导入)
		- [4.7.3 将类放入包中](#473-将类放入包中)
		- [4.7.4 包作用域](#474-包作用域)
	- [4.8 类路径](#48-类路径)
	- [4.9 文档注释](#49-文档注释)
		- [4.9.1 注释的插入](#491-注释的插入)
		- [4.9.2 类注释](#492-类注释)
		- [4.9.3 方法注释](#493-方法注释)
		- [4.9.4 变量描述](#494-变量描述)
		- [4.9.5 通用注释](#495-通用注释)
		- [4.9.6 包与概述注释](#496-包与概述注释)
		- [4.10 类设计技巧](#410-类设计技巧)
- [5. 继承](#5-继承)
	- [5.1 类、超类和子类](#51-类超类和子类)
		- [5.1.1 定义子类](#511-定义子类)
		- [5.1.2 覆盖方法](#512-覆盖方法)
		- [5.1.3 子类构造器](#513-子类构造器)
		- [5.1.4 继承层次](#514-继承层次)
		- [5.1.5 多态](#515-多态)
		- [5.1.6 理解方法调用](#516-理解方法调用)
		- [5.1.7 阻止继承：final类和方法](#517-阻止继承final类和方法)
		- [5.1.8 强制类型转换](#518-强制类型转换)
		- [5.1.9 抽象类](#519-抽象类)
		- [5.1.10 可见性修饰符](#5110-可见性修饰符)
	- [5.2 Object：所有类的超类](#52-object所有类的超类)
		- [5.2.1 `equals`方法](#521-equals方法)
		- [5.2.2 相等测试与继承](#522-相等测试与继承)
		- [5.2.3 `hashCode`方法](#523-hashcode方法)
		- [5.2.4 `toString`方法](#524-tostring方法)
	- [5.3 泛型数组列表](#53-泛型数组列表)
		- [5.3.1 访问数组列表元素](#531-访问数组列表元素)
		- [5.3.2 类型化与原始数组列表的兼容性](#532-类型化与原始数组列表的兼容性)
	- [5.4 对象包装器与自动装箱](#54-对象包装器与自动装箱)
	- [5.5 参数数量可变的方法](#55-参数数量可变的方法)
	- [5.6 枚举类](#56-枚举类)
	- [5.7 反射](#57-反射)
	- [5.8 继承的设计技巧](#58-继承的设计技巧)
- [6. 接口、lambda表达式与内部类](#6-接口lambda表达式与内部类)
	- [6.1 接口](#61-接口)
		- [6.1.1 接口概念](#611-接口概念)
		- [6.1.2 接口的特性](#612-接口的特性)
		- [6.1.3 接口与抽象类](#613-接口与抽象类)
		- [6.1.4 静态方法](#614-静态方法)
		- [6.1.5 默认方法`default`](#615-默认方法default)
		- [6.1.6 解决默认方法冲突](#616-解决默认方法冲突)
	- [6.2 接口示例](#62-接口示例)
		- [6.2.1 接口与回调](#621-接口与回调)
		- [6.2.2 `Comparator`接口](#622-comparator接口)
		- [6.2.3 对象克隆](#623-对象克隆)
	- [6.3 lambda表达式](#63-lambda表达式)
		- [6.3.2 lambda表达式的语法](#632-lambda表达式的语法)
		- [6.3.3 函数式接口](#633-函数式接口)
		- [6.3.4 方法引用](#634-方法引用)
		- [6.3.5 构造器引用](#635-构造器引用)
		- [6.3.6 变量作用域](#636-变量作用域)
		- [6.3.7 处理lambda表达式](#637-处理lambda表达式)
		- [6.3.8 再谈`Comparator`](#638-再谈comparator)
	- [6.4 内部类](#64-内部类)
		- [6.4.1 使用内部类访问对象状态](#641-使用内部类访问对象状态)
		- [6.4.2 内部类的特殊语法规则](#642-内部类的特殊语法规则)
		- [6.4.4 局部内部类](#644-局部内部类)
		- [6.4.6 匿名内部类](#646-匿名内部类)
		- [6.4.7 静态内部类](#647-静态内部类)
	- [6.5 代理](#65-代理)
		- [6.5.1 何时使用代理](#651-何时使用代理)
		- [6.5.2 创建代理对象](#652-创建代理对象)
		- [6.5.3 代理类的特性](#653-代理类的特性)
- [7. 异常、断言和日志](#7-异常断言和日志)
	- [7.1 处理错误](#71-处理错误)
		- [7.1.1 异常分类](#711-异常分类)
		- [7.1.2 声明受查异常](#712-声明受查异常)
		- [7.1.3 如何抛出异常](#713-如何抛出异常)
		- [7.1.4 创建异常类](#714-创建异常类)
	- [7.2 捕获异常](#72-捕获异常)
		- [7.2.1 捕获异常](#721-捕获异常)
		- [7.2.2 捕获多个异常](#722-捕获多个异常)
		- [7.2.3 再次抛出异常与异常链](#723-再次抛出异常与异常链)
		- [7.2.4 `finally`子句](#724-finally子句)
		- [7.2.5 带资源的`try`语句](#725-带资源的try语句)
		- [7.2.6 分析堆栈轨迹元素](#726-分析堆栈轨迹元素)
	- [7.3 使用异常机制的技巧](#73-使用异常机制的技巧)
	- [7.4 使用断言](#74-使用断言)
		- [7.4.1 断言的概念](#741-断言的概念)
		- [7.4.2 启用和禁用断言](#742-启用和禁用断言)
		- [7.4.3 使用断言完成参数检查](#743-使用断言完成参数检查)
	- [7.5 记录日志](#75-记录日志)
		- [7.5.1 基本日志](#751-基本日志)
		- [7.5.2 高级日志](#752-高级日志)
		- [7.5.3 修改日志管理器配置](#753-修改日志管理器配置)
		- [7.5.4 本地化](#754-本地化)
		- [7.5.5 处理器](#755-处理器)
		- [7.5.6 过滤器](#756-过滤器)
		- [7.5.7 格式化器](#757-格式化器)
		- [7.5.8 日志记录说明](#758-日志记录说明)
	- [7.6 调试技巧](#76-调试技巧)
- [8. 泛型程序设计](#8-泛型程序设计)
	- [8.1 为什么要使用泛型程序设计](#81-为什么要使用泛型程序设计)
	- [8.2 定义简单泛型类](#82-定义简单泛型类)
	- [8.3 泛型方法](#83-泛型方法)
	- [8.4 类型变量的限定](#84-类型变量的限定)
	- [8.5 泛型代码和虚拟机](#85-泛型代码和虚拟机)
		- [8.5.1 类型擦除](#851-类型擦除)
		- [8.5.2 翻译泛型表达式](#852-翻译泛型表达式)
		- [8.5.3 翻译泛型方法-桥方法](#853-翻译泛型方法-桥方法)
		- [8.5.4 调用遗留代码](#854-调用遗留代码)
	- [8.6 约束与局限性](#86-约束与局限性)
		- [8.6.1 不能用基本类型实例化类型参数](#861-不能用基本类型实例化类型参数)
		- [8.6.2 运行时类型查询只适用于原始数组](#862-运行时类型查询只适用于原始数组)
		- [8.6.3 不能创建参数化类型的数组](#863-不能创建参数化类型的数组)
		- [8.6.4 Varargs警告](#864-varargs警告)
		- [8.6.5 不能实例化类型参数](#865-不能实例化类型参数)
		- [8.6.6 不能构造泛型数组](#866-不能构造泛型数组)
		- [8.6.7 泛型类的静态上下文中类型变量无效](#867-泛型类的静态上下文中类型变量无效)
		- [8.6.8 不能抛出或捕获泛型类的实例](#868-不能抛出或捕获泛型类的实例)
		- [8.6.9 可以消除对受查异常的检查](#869-可以消除对受查异常的检查)
		- [8.6.10 注意擦除后的冲突](#8610-注意擦除后的冲突)
	- [8.7 泛型类型的继承规则](#87-泛型类型的继承规则)
	- [8.8 通配符类型](#88-通配符类型)
		- [8.8.1 通配符概念](#881-通配符概念)
		- [8.8.2 通配符的超类型限定](#882-通配符的超类型限定)
		- [8.8.3 无限定通配符](#883-无限定通配符)
		- [8.8.4 通配符捕获](#884-通配符捕获)
	- [8.9 反射和泛型](#89-反射和泛型)
- [9. 集合](#9-集合)
	- [9.1 Java集合框架](#91-java集合框架)
		- [9.1.1 将集合的接口与实现分离](#911-将集合的接口与实现分离)
		- [9.1.2 `Collection`接口](#912-collection接口)
		- [9.1.3 迭代器](#913-迭代器)
		- [9.1.4 泛型实用方法](#914-泛型实用方法)
		- [9.1.5 集合框架中的接口](#915-集合框架中的接口)
	- [9.2 具体的集合](#92-具体的集合)
		- [9.2.1 链表`LinkedList`](#921-链表linkedlist)
		- [9.2.2 数组列表`ArrayList`](#922-数组列表arraylist)
		- [9.2.3 散列集`HashSet`](#923-散列集hashset)
		- [9.2.4 树集`TreeSet`](#924-树集treeset)
		- [9.2.5 队列`Queue`与双端队列`Deque`](#925-队列queue与双端队列deque)
		- [9.2.6 优先级队列`PriorityQueue`](#926-优先级队列priorityqueue)
	- [9.3 映射`Map`](#93-映射map)
		- [9.3.1 基本映射操作](#931-基本映射操作)
		- [9.3.2 更新映射项](#932-更新映射项)
		- [9.3.3 映射视图`Map.Entry`](#933-映射视图mapentry)
		- [9.3.4 弱散列映射`WeakHashMap`](#934-弱散列映射weakhashmap)
		- [9.3.5 链接散列集`LinkedHashSet`与映射`LinkedHashMap`](#935-链接散列集linkedhashset与映射linkedhashmap)
		- [9.3.6 枚举集`EnumSet`与映射`EnumMap`](#936-枚举集enumset与映射enummap)
		- [9.3.7 标识散列映射`IdentityHashMap`](#937-标识散列映射identityhashmap)
	- [9.4 视图与包装器](#94-视图与包装器)
		- [9.4.1 轻量级集合包装器](#941-轻量级集合包装器)
		- [9.4.2 子范围`subXXX`](#942-子范围subxxx)
		- [9.4.3 不可修改的视图`unmodifiableXXX`](#943-不可修改的视图unmodifiablexxx)
		- [9.4.4 同步视图`synchronizedXXX`](#944-同步视图synchronizedxxx)
		- [9.4.5 受查视图`checkedXXX`](#945-受查视图checkedxxx)
		- [9.4.6 关于可选操作的说明](#946-关于可选操作的说明)
	- [9.5 算法](#95-算法)
		- [9.5.1 排序与混排](#951-排序与混排)
		- [9.5.2 二分查找](#952-二分查找)
		- [9.5.3 简单算法](#953-简单算法)
		- [9.5.4 批操作](#954-批操作)
		- [9.5.5 集合与数组的转换](#955-集合与数组的转换)
		- [9.5.6 编写自己的算法](#956-编写自己的算法)
	- [9.6 遗留的集合](#96-遗留的集合)
		- [9.6.1 `Hashtable`类](#961-hashtable类)
		- [9.6.2 枚举`Enumeration<E>`](#962-枚举enumeratione)
		- [9.6.3 属性映射`Properties`](#963-属性映射properties)
		- [9.6.4 栈`Stack<E>`](#964-栈stacke)
		- [9.6.5 位集`BitSet`](#965-位集bitset)
- [10. 图形程序设计](#10-图形程序设计)
- [11. 事件处理](#11-事件处理)
- [12. Swing用户界面组件](#12-swing用户界面组件)
- [13. 部署Java程序](#13-部署java程序)
- [14. 并发](#14-并发)
	- [14.1 什么是线程](#141-什么是线程)
	- [14.2 中断线程](#142-中断线程)
	- [14.3 线程状态](#143-线程状态)
		- [14.3.1 新创建线程`new`](#1431-新创建线程new)
		- [14.3.2 可运行线程`runnable`](#1432-可运行线程runnable)
		- [14.3.3 被阻塞线程`blocked`和等待线程`waiting`、`timed waiting`](#1433-被阻塞线程blocked和等待线程waitingtimed-waiting)
		- [14.3.4 被终止的线程`terminated`](#1434-被终止的线程terminated)
	- [14.4 线程属性](#144-线程属性)
		- [14.4.1 线程优先级](#1441-线程优先级)
		- [14.4.2 守护线程](#1442-守护线程)
		- [14.4.3 未捕获异常处理器](#1443-未捕获异常处理器)
	- [14.5 同步](#145-同步)
		- [14.5.3 锁对象`ReentrantLock`](#1453-锁对象reentrantlock)
		- [14.5.4 条件对象`Condition`](#1454-条件对象condition)
		- [14.5.5 `synchronized`关键字](#1455-synchronized关键字)
		- [14.5.6 同步阻塞](#1456-同步阻塞)
		- [14.5.7 监视器概念](#1457-监视器概念)
		- [14.5.8 `Volatile`变量](#1458-volatile变量)
		- [14.5.9 `final`变量](#1459-final变量)
		- [14.5.10 原子性](#14510-原子性)
		- [14.5.11 死锁](#14511-死锁)
		- [14.5.12 线程局部变量`ThreadLocal<T>`](#14512-线程局部变量threadlocalt)
		- [14.5.13 锁测试与超时](#14513-锁测试与超时)
		- [14.5.14 读/写锁`ReentrantReadWriteLock`](#14514-读写锁reentrantreadwritelock)
		- [14.5.15 为什么弃用`stop`和`suspend`方法](#14515-为什么弃用stop和suspend方法)
	- [14.6 阻塞队列](#146-阻塞队列)
	- [14.7 线程安全的集合](#147-线程安全的集合)
		- [14.7.1 高效的映射、集和队列](#1471-高效的映射集和队列)
		- [14.7.2 映射条目的原子更新](#1472-映射条目的原子更新)
		- [14.7.3 对并发散列映射的批操作](#1473-对并发散列映射的批操作)
		- [14.7.4 并发集视图](#1474-并发集视图)
		- [14.7.5 写数组的拷贝](#1475-写数组的拷贝)
		- [14.7.6 并行数组计算](#1476-并行数组计算)
		- [14.7.7 较早的线程安全集合](#1477-较早的线程安全集合)
	- [14.8 `Callable`与`Future`](#148-callable与future)
	- [14.9 执行器](#149-执行器)
		- [14.9.1 线程池`ExecutorService`](#1491-线程池executorservice)
		- [14.9.2 预定执行`ScheduledExecutorService`](#1492-预定执行scheduledexecutorservice)
		- [14.9.3 控制任务组](#1493-控制任务组)
		- [14.9.4 `Fork-Join`框架](#1494-fork-join框架)
		- [14.9.5 可完成`Future`](#1495-可完成future)
	- [14.10 同步器](#1410-同步器)
		- [14.10.1 信号量](#14101-信号量)
		- [14.10.2 倒计时门栓`CountDownloadLatch`](#14102-倒计时门栓countdownloadlatch)
		- [14.10.3 障栅`CyclicBarrier`](#14103-障栅cyclicbarrier)
		- [14.10.4 交换器`Exchanger`](#14104-交换器exchanger)
		- [14.10.5 同步队列`SynchronousQueue`](#14105-同步队列synchronousqueue)
	- [14.11 线程与Swing](#1411-线程与swing)

# 3. Java的基本程序设计结构

## 3.1 一个简单的Java程序

Java区分大小写

源代码的文件名必须与公共类的名字形同，并用`.java`作为扩展名

编译后会生成`name.class`，运行时命令为`java name`，注意不要加`.class`扩展名

main方法必须声明为public

## 3.2 注释

* 单行注释`// ...`

* 多行注释`/* ... */`

	```Java
	/*
	...
	*/
	```

* 自动生成文档注释

	```Java
	/**
	 * ...
	*/
	```

## 3.3 数据类型

共8种，4种整型、2种浮点类型、char、boolean

* 整型

|类型|存储|范围|
|:-:|:-:|:-:|
|byte|1字节|-128 ~ 127|
|short|2字节|-32 768 ~ 32 767|
|int|4字节|-2 147 483 648<br>~ 2 147 483 647|
|long|8字节|-9 223 372 036 854 775 808<br>~ 9 223 372 036 854 775 807|

long后缀`L`；十六进制前缀`0x`或`0X`；二进制前缀`0b`或`0B`

数字中间可以加`_`以方便阅读，编译器会删除下划线

* 浮点类型

|类型|存储|取值范围|
|:-:|:-:|:-:|
|float|4字节|有效位数6~7位|
|double|8字节|有效位数15位|

float后缀`F`或`f`，没有后缀默认是double；double后缀`D`或`d`

可以用16进制表示浮点数，如`0x1.0p-3`表示$2^{-3}$，p表示指数，而不是用e表示指数；位数用十六进制，指数用十进制，指数的基数是2而不是10

所有的`NaN`都认为是不相同的，可以使用`Double.isNaN(x)`判断是否是`NaN`

* char

转义序列`\u`可以出现在字符常量或字符串之外，其他所有转义序列则不可以。`\u`转义序列会在解析代码之前得到处理，因此一定要注意注释中的`\u...`

最好不要在程序中使用`char`类型

* boolean

整型值和boolean之间不能进行相互转换

## 3.4 变量

### 3.4.1 变量初始化

C和C++区分变量的声明和定义，Java不区分变量的声明和定义

### 3.4.2 常量

利用关键字`final`指示常量，表示该变量只能被赋值一次，习惯上常量名使用全大写

可以使用关键字`static final`设置一个类常量，以在一个类的多个方法中使用

`const`是Java保留的关键字，但目前并没有使用

### 3.5 运算符

`整除/0`会产生一个异常，`浮点数/0`将会得到无穷大或NaN

### 3.5.2 数值类型之间的转换

* 数值类型之间的合法转换：
	* 无信息丢失的转换：
		* `byte`→`short`
		* `short`→`int`
		* `char`→`int`
		* `int`→`long`
		* `int`→`double`
		* `float`→`double`
	* 可能会有精度损失的转换：
		* `int`→`float`
		* `long`→`float`
		* `long`→`double`

* 转换规则：
	1. 如果两个操作中有一个是`double`类型，另一个操作数将会转换为`double`类型
	2. 否则，如果两个操作中有一个是`float`类型，另一个操作数将会转换为`float`类型
	3. 否则，如果两个操作中有一个是`long`类型，另一个操作数将会转换为`long`类型
	4. 否则，两个操作数将被转换为`int`类型

### 3.5.3 强制类型转换

使用`()`进行转换，强制类型转换通过截断小数部分将浮点值转换为整型

## 3.8 控制流程

### 3.8.1 块作用域

不能在嵌套的两个块中声明同名的变量

### 3.8.6 中断控制流程语句

* 带标签的break：
	* 标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号
	* break后紧跟标签
	* 可以将标签应用到任何语句中，包括if语句或块语句等
	* 只能跳出语句块，不能跳入语句块

* 带标签的continue
	* 跳到与标签匹配的循环首部

# 4. 对象与类

## 4.3 用户自定义类

在一个源文件中，只能有一个public类，文件名必须与public类的名字相匹配，但可以有任意数目的非public类

### 4.3.4 从构造器开始

所有的Java对象都是在堆中构造的，构造器总是伴随着new操作符一起使用

### 4.3.7 基于类的访问权限

一个方法可以访问所属类的所有对象的私有数据

## 4.5 方法参数

Java总是采用按值调用，方法得到的是所有参数值的一个拷贝，不能修改传递给它的任何参数变量的内容。但是Java方法参数总共有两种类型：基本数据类型和对象引用。这里对象的引用就类似于C++中的指向对象的指针。即方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。

总结一下就是Java中函数的类参数类似C++中对象的指针，但不是C++中的引用

* Java中函数的参数是按值调用
	* 方法得到的是所有参数值的一个拷贝，不能修改传递给它的任何参数变量的内容。
	* 但是Java中类对象类似于C++中指向对象的指针，因此方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象
	* 类对象参数类似C++中指向对象的指针，不同于C++中的引用

* 方法参数的使用情况
	* 方法不能改变一个基本数据类型的参数
	* 方法可以改变一个对象参数的状态
	* 方法不能让对象参数引用一个新的对象

## 4.6 对象构造

### 4.6.2 默认域初始化

局部变量必须明确初始化，但是如果没有初始化类中的变量，则将会被自动初始化为默认值(数值为0，boolean为false，对象引用为null)

如果一个类没有构造器，那么系统就会提供一个无参数构造器，这个构造器将所有的数据变量设置为默认值。如果类中提供了至少一个构造器，但没有提供无参数构造器，则在构造对象时如果没有提供参数就会被视为不合法

### 4.6.6 调用另一个构造器

关键字`this`引用方法的隐式参数，同时如果构造器的第一个语句形如`this(...)`，这个构造器将调用同一个类的另一个构造器

### 4.6.7 初始化数据域的方法

* 初始化数据变量的方法
	1. 在构造器中设置值
	2. 在声明中赋值(直接赋值或调用函数赋值)
	3. 初始化块：在一个类的声明中，可以包含多个代码块，只要构造类的对象，这些块就会被执行
		* 即使在类的后面定义，仍然可以在初始化块中设置变量，但是，为了避免循环定义，不要读取在后面初始化的变量，建议将初始化块放在变量定义之后
		* 如果对类的静态变量进行初始化的代码比较复杂，那么可以使用静态的初始化块，既将代码放在一个块中，并标记关键字`static`

* 调用构造器的具体处理步骤
	1. 所有数据变量被初始化为默认值(0、false、null)
	2. 按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块
	3. 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体
	4. 执行这个构造器主体

### 4.6.8 对象析构与finalize方法

可以为任何一个类添加finalize方法，finalize方法将在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用finalize方法回收任何短缺的资源，这是因为很难确定这个方法什么时候才能够调用

## 4.7 包

从编译器的角度看，嵌套的包之间没有任何关系

### 4.7.1 类的导入

一个类可以使用所属包中的所有类，以及其他包中的public类

* 访问另一个包中的public类的方法：
	1. 在每个类名之前添加完整的包名
	2. 使用`import`

* `import`语句应该位于源文件的顶部，`package`语句的后面

* 发生命名冲突时，可以使用特定的`import`语句，例子如下：
	```Java
	// java.util与java.sql包中都有Date类
	import java.util.*;
	import java.sql.*;

	import java.util.Date;	// 指定使用特定包中的类
	```

* C++中`#include`与Java中`import`区别：
	* C++除了正在编译的文件以及在头文件中明确包含的文件之外，C++编译器无法查看其他文件内部
	* Java编译器可以查看其他文件的内部，只需要指定查看路径；在Java中，通过显式地给出包名，就可以不使用`import`

* 相似概念对比：

|C++|Java|
|:-:|:-:|
|命名空间|包机制|
|`namespace`|`package`|
|`using`|`import`|

### 4.7.2 静态导入

* `import`不仅可以导入类，还可以导入静态方法和静态变量，例子如下：
	* `import static java.lang.System.*;`：导入类的静态方法和静态变量
	* `import static java.lang.System.out;`：导入特定的方法或变量

### 4.7.3 将类放入包中

* 要想将一个类放入包中，需要将包的名字放在源文件的开头，包中定义类的代码之前

* 如果没有在源文件中放置`package`语句，该源文件中的类就被放置在一个默认包中，默认包没有名字

* 包中文件需要放到与完整的包名匹配的子目录中

* 命令行操作
	* 编译器对文件进行操作，即带有文件分隔符和扩展名`.java`的文件，如`java com/mycompany/PayrollApp.java`
	* Java解释器加载类，即带有`.`分隔符，如`java com.mycompany.PayrollApp`

### 4.7.4 包作用域

* 标记为`public`的类、方法或变量可以被任意的类使用

* 标记为`private`的类、方法或变量只能被定义它们的类使用

* 没有指定`public`或`private`的类、方法或变量可以被同一个包中的所有方法访问

## 4.8 类路径

* 类文件可以存储在JAR文件中。在一个JAR文件中，可以包含多个压缩形式的类文件和子目录

* 多个程序共享类的步骤：
	1. 把类放到一个目录中，该目录是包树状结构的基目录
	2. 将JAR文件放在一个目录中(不一定必须是上一步中的基目录)
	3. 设置类路径。类路径是所有包含类文件的路径的集合，包括：基目录、当前目录、JAR文件

## 4.9 文档注释

### 4.9.1 注释的插入

* javadoc实用程序从下面几个特性中抽取信息，因此应该下面几部分编写注释
	* 包
	* `public`类与接口
	* `public`与`protected`的构造器及方法
	* `public`与`protected`的变量

* 注释格式：
	* 注释应该放置在所描述特性的前面，以`/**`开始，以`'*/`结束，中间是自由格式文本
	* 在自由格式文本中，可以使用HTML修饰符
	* 如果有到其他文件的链接(如图像)，就应该将这些文件放到子目录`doc-files`中

### 4.9.2 类注释

* 类注释必须放在`import`语句之后，类定义之前

### 4.9.3 方法注释

* 可使用标记
	* `@param 变量描述`：可以跨越多行，可以使用HTML标记，一个方法的所有`@param`必须放在一起
	* `@return 描述`：可以跨越多行，可以使用HTML标记
	* `@throws 类描述`：表示该方法可能抛出异常

### 4.9.4 变量描述

* 只需要对公有变量(通常指静态常量)建立文档

### 4.9.5 通用注释

* 可以用在类文档的注释中
	* `@author 姓名`：可以使用多个`@author`标记
	* `@version 文本`：版本条目

* 可以用在所有文档的注释中
	* `@since 文本`：始于，可以是对引入特性的版本描述
	* `@deprecated 文本`：对类、方法或变量添加一个不再使用的注释
	* `@see 引用`：添加一个超链接，如`@see 包名1.包名2.类名#函数名(变量类型列表)`，可以省略包名或类名，此时链接将定位于当前包或当前类；可以为一个特性添加多个`@see`标记，但必须将它们放在一起

### 4.9.6 包与概述注释

* 可以直接将类、方法和变量的注释放置在Java源文件中，只要用`/** ... */`文档注释界定就可以，要想产生包注释，就需要在每一个包目录中添加一个单独的文件。

* 生成包注释需要在每一个包目录中添加一个单独的文件，有两种方法
	1. 提供一个以`package.html`命名的HTML文件。在标记`<body>—</body>`之间的所有文本都会被抽取出来
	2. 提供一个以`package-info.java`命名的Java文件。这个文件必须包含一个初始的以`/**`和`*/`界定的Javadoc注释，跟随在一个包语句之后。它不应该包含更多的代码或注释

* 还可以为所有的源文件提供一个概述性的注释。这个注释将被放置在一个名为`overview.
html`的文件中，这个文件位于包含所有源文件的父目录中。标记`<body>... </body>`之间的所有文本将被抽取出来。当用户从导航栏中选择"Overview"时，就会显示出这些注释内容

### 4.10 类设计技巧

1. 保证数据`private`
2. 对数据初始化
3. 不要在类中过多使用过多的基本类型(用其他的类代替多个相关的基本类型的使用)
4. 不是所有的变量都需要独立的变量访问器和变量更改器
5. 将职责过多的类进行分解
6. 类名和方法名要能够体现它们的职责
7. 优先使用不可变的类

# 5. 继承

## 5.1 类、超类和子类

### 5.1.1 定义子类

```Java
public class Derived extends Base {
	// ...
}
```

* Java使用关键字`extend`代替了C++中的冒号`:`

* 在Java中，所有的继承都是`public`继承，没有C++中的`private`继承和`protected`继承

### 5.1.2 覆盖方法

* 子类中的方法不能直接访问父类中的`private`变量，只有父类中的方法才能够访问父类中的`private`部分。因此如果子类需要访问父类的`private`部分，就需要借助于`public`的接口

* 子类使用`super`关键字调用父类的方法：`super.BaseFunction()`

* `super`与`this`并不相同。`super`不是一个对象的引用，不能将`super`赋给另一个对象变量，`super`只是一个指示编译器调用父类方法的特殊关键字

* 在子类中可以增加变量、增加方法或覆盖父类的方法，但是不能删除继承的任何变量和方法

### 5.1.3 子类构造器

* 由于子类的构造器不能访问父类的私有变量，因此在子类的构造函数中使用`super(参数)`语句调用父类的构造函数

* 使用`super`调用构造器的语句必须是子类构造器的第一条语句

* 如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认(没有参数)的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则Java编译器将报告错误

* 在Java中，不需要将函数声明为虚函数，动态绑定是默认的处理方法。如果不希望让一个方法具有虚函数特性，可以将该函数标记为`final`，见[5.1.7 阻止继承：final类和方法](#517-阻止继承final类和方法)

### 5.1.4 继承层次

* Java不支持多继承。有关Java中多继承功能的实现见[6.1 接口](#61-接口)

### 5.1.5 多态

* 子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换，但不建议，可能会出现问题

### 5.1.6 理解方法调用

* 方法`x.f(args);`的调用过程(x为类型C的一个对象)
	1. 编译器査看对象的声明类型和方法名。假设调用`x.f(param)`，且隐式参数`x`声明为`C`类的对象。需要注意的是：有可能存在多个名字为`f`，但参数类型不一样的方法，编译器将会一一列举所有`C`类中名为`f`的方法和其超类中访问属性为`public`且名为`f`的方法(超类的私有方法不可访问)。至此，编译器已获得所有可能被调用的候选方法
	2. 接下来，编译器将査看调用方法时提供的参数类型。如果在所有名为`f`的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为**重栽解析**
	3. 如果是`private`方法、`static`方法、`final`方法或者构造器， 那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为**静态绑定**。与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现**动态绑定**
	4. 当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与`x`所引用对象的实际类型最合适的那个类的方法。假设`x`的实际类型是`D`，它是`C`类的子类。如果`D`类定义了方法`f(param)`就直接调用它；否则，将在`D`类的超类中寻找`f(param)`，以此类推
	* 每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个**方法表**，其中列出了所有方法的签名和实际调用的方法。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。在前面的例子中，虚拟机搜索`D`类的方法表，以便寻找与调用`f(param)`相匹配的方法。这个方法既有可能是`D.f(param)`，也有可能是`X.f(param)`，这里的`X`是`D`的超类。这里需要提醒一点，如果调用`super.f(param)`，编译器将对隐式参数超类的方法表进行搜索

### 5.1.7 阻止继承：final类和方法

* 不允许扩展的类被称为final类，定义类的时候使用了`final`修饰符就表明这个类是final类

* 类中的方法也可以被声明为`final`，这样子类就不能覆盖这个方法。final类中的所有方法自动地成为final方法，但变量并不是final变量(final变量是常量，构造对象后就不允许改变它的值了)

* 将方法或类声明为final的主要目的是确保它们不会在子类中改变语义

### 5.1.8 强制类型转换

* 对象引用的转换语法与数值表达式的类型转换相似，仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了

* 进行类型转换的唯一原因是：在暂时忽视对象的实际类型之后，使用对象的全部功能

* 将一个子类的引用赋给一个父类变量，编译器是允许的。将一个父类的引用赋给一个子类变量，必须进行类型转换，才能通过运行时的检查

* 类型转换失败时会抛出一个`ClassCastException`异常。如果没有捕获这个异常，程序就会终止

* 在进行类型转换前，先使用`instanceof`进行检查是否能够转换：`if (a instanceof BaseClass)`

* Java的类型转换类似C++的dynamic_cast，即java中的`Derived x = (Derived) y;`等价于C++中的`Derived* x = dynamic_cast<Derived*>(y);`。区别在于转换失败时java会抛出异常，C++会返回`null	`。
	* 或者说Java的类型转换类似于C++中使用dynamic_cast转换对象的引用，这样转换失败后都会抛出异常

### 5.1.9 抽象类

* 使用`abstract`关键字定义一个函数为抽象函数，包含抽象函数的类必须被声明为抽象类，不过类即使不含抽象方法，也可以将类声明为抽象类

* 除了抽象函数外，抽象类还可以包含具体数据和具体函数

* 抽象类不能被实例化，但是可以定义一个抽象类的对象变量，但该变量只能引用非抽象子类的对象

* Java的抽象函数类似C++的纯虚函数
	* Java：`abstract`关键字
	* C++：在成员函数末尾添加`=0`

* 要想通过父类变量声明，指向子类实例来调用函数，就不可以省略定义父类中的抽象函数，而直接调用子类中定义的函数。因为编译器只允许调用在类中声明过的函数

### 5.1.10 可见性修饰符

* Java中的`protected`部分对所有子类及同一个包中的所有其他类可见

* 子类只能访问子类对象中的父类声明为`protected`部分，而不能访问其他父类对象中的部分

|访问修饰符|可见性|
|:-:|:-:|
|`private`|仅对本类可见|
|`protected`|对本包及所有子类可见|
|`public`|对所有类可见|
|无修饰符|对本包可见|

## 5.2 Object：所有类的超类

* Object类是Java中所有类的始祖，在Java中每个类都是由它扩展而来的。如果没有明确指出父类，Object就被认为是这个类的父类

* Object类型的变量只能用于作为各种值的通用持有者。要想对其中的内容进行具体的操作，还需要清楚对象的原始类型，并进行相应的类型转换

* 在Java中，只有基本类型不是对象，例如，数值、字符和布尔类型的值都不是对象。所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类

### 5.2.1 `equals`方法

* Object类中的`equals`方法用于检测一个对象是否等于另外一个对象。在Object类中，这个方法将判断两个对象是否具有相同的引用

### 5.2.2 相等测试与继承

* Java语言规范要求`equals`方法具有如下特性：
	1. 自反性：`x.equals(x) == true`
	2. 对称性：`x.equals(y) == y.equals(x)`
	3. 传递性：若`x.equals(y) == true && y.equals(z) == true`，则`x.equals(z) == true`
	4. 一致性：如果x和y引用的对象没有发生变化，反复调用`x.equals(y)`应该返回同样的结果
	5. 对于任意非空引用`x`，`x.equals(null) == false`

* 编写`equals`方法的建议
	1. 本类`this`为`className`类；显式参数命名为`OtherObject`，稍后需要将它转换成另一个叫做`other`的变量
	2. 检测`this`与`otherObject`是否引用同一个对象：`if (this == otherObject) return true;`
	3. 检测`otherObject`是否为`null`，如果为`null`，返回`false`：`if (otherObject == null) return false;`
	4. 比较`this`与`otherObject`是否属于同一个类
		* 如果`equals`的语义在每个子类中有所改变，则使用`geiClass()`检测：`if (getClass() != otherObject.getClasee()) return false;`
		* 如果所有的子类都拥有统一的语义，就使用`instanceof`检测：`if (!(otherObject instanceof ClassName)) return false;`
	5. 将`otherObject`转换为相应的类类型变量：`className Other = (className) otherObject;`
	6. 对所有需要比较的变量进行比较：使用`==`比较基本类型变量，使用`equals`比较对象变量。如果所有的变量都匹配，就返回true，否则返回false。
	* 如果在子类中重新定义`equals`，就要在其中包含调用`super.equals(other);`
	* 对于数组类型的变量，可以使用静态的`Arrays.equals`方法检测相应的数组元素是否相等
	* 为了避免发生类型错误，覆盖Object类的`equals`方法，可以使用`@Override`对覆盖父类的方法进行标记：`@Override public boolean equals(Object Other);`

### 5.2.3 `hashCode`方法

* 由于`hashCode`方法定义在Object类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址

* 如果重新定义`equals`方法，就必须重新定义`hashCode`方法，以便将对象插入到散列表中

* `hashCode`方法应该返回一个整型数值，并合理地组合实例域的散列码，以便能够让各个不同的对象产生的散列码更加均匀

* `Object.hashCode()`是`null`安全的，如果参数为`null`则会返回0

* `Object.hash()`可以对各个参数调用`Object.hashCode()`，并组合这些散列值

* `equals()`与`hashCode()`的定义必须一致，如果`x.equals(y) == true`，那么`x.hashCode() == y.hashCode()`

### 5.2.4 `toString`方法

* `toString()`方法用于返回表示对象值的字符串

## 5.3 泛型数组列表

* Java允许在运行时确定数组的大小
    * `int actualSize = ...;`
    * `Employee[] a = new Employee[actualSize];`

* `ArrayList`类：采用类型参数的泛型类
    * 声明与构造：`ArrayList<Employee> staff = new ArrayList<>;`
    * 指定大小：`ArrayList<Employee> staff = new ArrayList<>(capacity);`
    * 将存储容量削减到当前大小：`staff.trimToSize();`

* Java中的`ArrayList`类似C++中的`vector`，但是Java没有重载`[]`运算符。同时C++赋值是值拷贝，Java赋值是让两个变量指向同一个数组

### 5.3.1 访问数组列表元素

* 添加元素：`staff.add(obj);`；`staff.add(index, obj)`

* 删除元素：`staff.remove(index);`

* 确保数组列表在不重新分配存储空间的情况下能够保存给定数量的元素：`staff.ensureCapacity(capacity);`

* 赋值：`staff.set(index, obj);`

* 访问：`staff.get(index);`

### 5.3.2 类型化与原始数组列表的兼容性

* 没有泛型类时，原始的ArrayList使用如下所示：
    * `public void update(ArrayList list) {...}`
        * 可以将一个类型化的`ArrayList`传递给`update`方法而不需要进行任何类型转换
        * 也可以将一个`ArrayList`对象传递给`update`方法
    * `public ArrayList find() {...}`
        * 将一个原始`ArrayList`赋给类型化的`ArrayList`会得到一个警告：`ArrayList<Employee> result = employee.find();`
        * 使用类型转换并不能避免出现警告：`ArrayList<Employee> result = (ArrayList<Employee>)employee.find();`，这样会得到另外一个警告，指出类型转换有误
        * 一旦确保不会造成严重的后果，可以用`@SuppressWarnings("unchecked")`标注来标记这个变量能够接受类型转换：`@SuppressWarnings("unchecked") ArrayList<Employee> result = (ArrayList<Employee>)employee.find();`

## 5.4 对象包装器与自动装箱

|类型|包装器|
|:-:|:-:|
|`int`|`Integer`|
|`long`|`Long`|
|`float`|`Float`|
|`double`|`Double`|
|`short`|`Short`|
|`byte`|`Byte`|
|`char`|`Character`|
|`void`|`Void`|
|`boolean`|`Boolean`|

* 所有的基本类型都有一个与之对应的类，称为包装器
    * `Integer`、`Long`、`Float`、`Double`、`Short`、`Byte`派生于公共的超类`Number`
    * 对象包装器是不可变的，一旦构造了包装类，就不允许更改包装在其中的值
    * 对象包装器类是`final`，不能定义它们的子类
    * 泛型中需要使用包装器类，不能使用基本类型

* 自动装箱/拆箱
    * 自动装箱：将一个基本类型赋值给一个包装器类时，会自动将基本类型转换为包装器类
    * 自动拆箱：将一个包装器类赋值给一个基本类型时，会自动将包装器类转换为基本类型
    * 在算术表达式中也能自动装箱/拆箱
    * `==`运算符也可以应用于包装器对象，只不过检测的是对象是否指向同一个存储区域，因此比较包装器类是否相等时最好使用`equals()`方法
    * 由于包装器类引用可以为`null`，因此自动装箱有可能抛出一个`NullPointerException`异常
    * 如果在一个条件表达式中混合使用`Integer`和`Double`类型，`Integer`就会拆箱，提升为`double`，再装箱为`Double`
    * 装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。虚拟机只是执行这些字节码

* 如果需要一个修改数值参数值的方法，就需要使用在org.omg.CORBA包中定义的持有者类型，包括`IntHolder`、`BooleanHolder`等。每个持有者类型都包含一个公有值域，通过它可以访问存储在其中的值

## 5.5 参数数量可变的方法

* 自定义可变参数的函数：

	```Java
	public static double max(double... values) {
		double res = Double.NEGATIVE_INFINITY;
		for (double v : values)
			if (v > res)
				res = v;
		return res;
	}

	double m = max(3.1, 40.4, -5);
	// 编译器将 new double[] {3.1, 40.4, -5}传递给max方法
	// 如果参数不是基本类型，则传递的是object[]
	```

* 允许将一个数组传递给可变参数函数的最后一个参数，因此可以将已经存在且最后一个参数是数组的函数重新定义为可变参数的方法，而不会破坏任何已经存在的代码

## 5.6 枚举类

* 枚举类：
	* 定义：`public enum Size {SMALL, MEDIUM, LARGE, EXTRA_LARGE};`
	* 使用：`Size i == Size.SMALL;`

* 在比较两个枚举类型的值时，永远不需要调用`equals`，而直接使用`==`就行

* 可以在枚举类型中添加一些构造器、函数和变量。构造器只是在构造枚举常量的时候被调用

* 所有枚举类都是`Enum`的子类，它们继承了这个类的许多方法
	* `toString()`：返回枚举常量名，如`Size.SMALL.toString() == "SMALL"`
	* `valueOf()`：`toString()`的逆函数，是静态函数，如`Enum.valueOf(Size.class, "SMALL") == Size.SMALL`
	* `values()`：静态函数，返回一个包含全部枚举值的数组
	* `ordinal()`：返回枚举类声明中枚举常量的位置，从0开始计数

## 5.7 反射

* 反射库提供了一个工具集，以便编写能够动态操纵Java代码的程序。这项功能被大量地应用于JavaBeans中，是Java组件的体系结构
	* 用途：在运行时分析类的能力、在运行时查看对象、实现通用的数组操作代码、利用Method对象(类似C++中的函数指针)

这一节后面没看

## 5.8 继承的设计技巧

1. 将公共操作和变量放在父类
2. 不要使用`protected`变量，不过`protected`函数对于指示那些不提供一般用途而应在子类中重新定义的方法很有用
3. 使用继承实现"is-a"关系
4. 除非所有继承的方法都有意义，否则不要使用继承
5. 在覆盖方法时，不要改变预期的行为
6. 使用多态，而非对多种类型进行检测
7. 不要过多地使用反射

# 6. 接口、lambda表达式与内部类

## 6.1 接口

### 6.1.1 接口概念

* 定义：接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义

* 例子：`Arrays`类中的`sort`方法承诺可以对对象数组进行排序，但要求满足对象所属的类必须实现了`Comparable`接口，`Comparable`接口代码如下
	```Java
	public interface Comparable {
		int compareTo(Object other);
	}
	```
	* 即任何实现`Comparable`接口的类都需要包含`compareTo`方法，并且这个方法的参数必须是一个Object对象，返回一个整型数值
	* 在Java SE5.0中，`Comparable`接口已经改进为泛型类型
	```Java
	public interface Comparable<T> {
		int compareTo(T other);
	}
	```
	* 语言标准规定，对于任意的x和y，实现必须能够保证`sgn(x.compareTo(y)) == -sgn(y.compareTo(x))`
	* 如果存在一种通用算法，它能够对两个不同的子类对象进行比较，则应该在父类中提供一个`compareTo`方法，并将这个方法声明为`final`

* 可见性：接口中的所有函数自动地属于`public`，因此在接口中声明方法时，不必提供关键字`public`

* 接口限制：接口中可以包含多个方法，可以定义常量，但是不能含有成员变量，Java SE8之后才可以在接口中实现方法(当然这些方法不能引用成员变量)。提供成员变量和方法实现的任务应该由实现接口的那个类来完成

* 实现接口步骤：
	1. 将类声明为实现给定的接口：`class Employee implements Comparable`
	2. 对接口中的所有方法进行定义：接口声明中不需要`public`，但是在类中实现时需要`public`

* 实现接口的意义：Java是一种强类型语言，在调用方法的时候，编译器会检查方法是否存在。因此如果实现了接口，就可以确定对应的方法存在

### 6.1.2 接口的特性

* 接口不是类，不能使用`new`运算符实例化一个接口

* 虽然不能构造接口的对象，但能够声明接口的变量，接口变量必须引用实现了接口的类对象

* 如同使用`instanceof`检查一个对象是否属于某个特定类一样，可以使用`instanceof`检查一个对象是否实现了某个特定的接口

* 接口可以被扩展，允许存在多条从具有较高通用性的接口到较高专用性的接口的链

* 接口中不能包含实例变量或静态方法，但是可以包含常量。接口中的变量将被自动设为`public static final`

* 每个类只能拥有一个父类，但可以实现多个接口。使用`,`将实现的各个接口分隔开：`class Employee implements Cloneable, Comparable`

### 6.1.3 接口与抽象类

* 使用抽象类表示通用属性存在一个问题：每个类只能扩展于一个类，但每个类可以实现多个接口

* C++支持多重继承，Java不支持多重继承

### 6.1.4 静态方法

* 在Java SE8中，允许在接口中添加静态方法

* 目前为止，通常的做法是将静态方法放在伴随类中，在标准库中，存在成对出现的接口和使用工具类，如Collection/Collections或Path/Paths。这些伴随类中实现了相应接口的部分或所有方法，但这个技术已经过时，可以直接在接口中实现方法，不过使用静态方法进行重构不现实

* 实现自己的接口时，不再需要为实用工具方法另外提供一个伴随类

### 6.1.5 默认方法`default`

* 可以为接口方法提供一个默认实现，必须用`default`修饰符标记这样一个方法

* 默认方法可以调用任何其他方法

* 默认方法的一个重要用法是"接口演化"，为接口添加一个非默认方法不能保证"源代码兼容"

### 6.1.6 解决默认方法冲突

1. 父类优先：如果父类提供了一个具体方法，同名且具有相同参数类型的默认方法全被忽略
	* 不要使用默认接口重新定义Object类中的某个方法，此时这个默认实现会永远被忽略
2. 接口冲突：如果一个接口提供了一个默认方法，另一个接口提供了一个同名且参数类型(不论是否是默认参数)相同的方法，必须覆盖这个方法来解决冲突
	* 只要至少有一个接口提供了一个实现，编译器就会报告错误，需要通过覆盖解决二义性
	* 如果两个接口都没有为共享方法提供默认实现，那么就不存在冲突。实现类有两个选择：实现这个方法；或不实现方法(此时这个类就是抽象类)

## 6.2 接口示例

### 6.2.1 接口与回调

* 回调：指出某个特定事件发生时应该采取的动作

* 在C++中，可以通过提供函数名实现回调；在Java中通过某个类的对象实现回调，调用者需要知道调用哪个方法，因此可以通过接口实现

### 6.2.2 `Comparator`接口

* `Array.sort`方法除了使用`Comparable`接口的类之外，还可以使用一个数组和一个比较器作为参数，比较器是实现了`Comparator`接口的类的实例

```Java
public interface Comparator<T> {
	int compare(T first, T Second);
}

Arrays.sort(data, new ComparatorClass);
```

### 6.2.3 对象克隆

* `Cloneable`接口指示类提供了一个安全的`clone`方法

* 直接赋值是浅拷贝，为一个包含对象引用的变量建立副本时，原变量和副本都是同一个变量的引用，任何一个变量改变都会影响另一个变量

* 如果共享的对象是不可变的，那么浅拷贝是安全的

* Object类的`clone`方法是`protected`，逐个变量的进行拷贝，如果对象包含子对象的引用，此时就是浅拷贝

* 可以通过重新定义`clone`方法实现深拷贝，对于每一个类，需要确定：
	1. 默认的`clone`方法是否满足要求
	2. 是否可以在可变的子对象上调用`clone`来修补默认的`clone`方法
	3. 是否不该使用`clone`
	* 如果选择前两项，就需要实现`Cloneable`接口，并重新定义`clone`方法，指定`public`访问修饰符
	* `Cloneable`接口的出现与接口的正常使用没有关系，`Cloneable`接口没有指定`clone`方法，这个方法是从Object类继承的。这个接口只是作为一个标记，如果一个对象请求克隆，但没有实现这个接口，就会生成一个受查异常

* 标记接口：`Cloneable`是Java提供的标记接口之一，标记接口的通常通途是确保一个类实现一个或一组特定的方法。标记接口不包含任何方法，唯一的作用是允许在类型查询中使用`instanceof`

* 即使`clone`的默认(浅拷贝)实现能够满足要求，还是需要实现`Cloneable`接口，将`clone`重新定义为`public`，再调用`super.clone()`

* 如果在一个对象上调用`clone`，但这个对象没有实现`Cloneable`接口，Object类的`clone`方法就会抛出一个`CloneNotSupportedException`异常

	* 在`clone`方法中最好保留`throws`说明符，这样就允许子类在不支持克隆时选择抛出一个`CloneNotSupportException`

## 6.3 lambda表达式

* lambda表达式是一个可传递的代码块以及必须传入代码的变量规范，可以在以后执行一次或多次

### 6.3.2 lambda表达式的语法

* 语法：`(参数列表) -> 表达式`
	* 参数：
		* 没有参数仍要提供空括号：`() -> {for (int i = 100; i >= 0; --i) System.out.println(i);}`
		* 如果可以推导出一个lambda表达式的参数类型，则可以忽略类型，只写形参名：`Comparator<String> comp = (first, second) -> first.length() - second.length(); // first与second都是String`
		* 如果方法只有一个参数，而且这个参数的类型可以推导得出，那么可以省略参数类型与`()`：`ActionListener listener = event -> System.out.println("...");`
	* 表达式：多个表达式可以使用`{}`，并可以包含显式的`return`语句
	* 返回值：
		* 无需指定lambda表达式的返回类型：返回类型会通过上下文推导得出
		* 如果一个lambda表达式只在某些分支返回一个值，而在另外一些分支不返回值，这是不合法的

### 6.3.3 函数式接口

* lambda表达式与封装代码块的接口是兼容的

* 函数式接口：只有一个抽象方法的接口，需要这种接口时，就可以提供一个lambda表达式
	* 例：`Array.sort(data, (first, second) -> first.length() - second.length());`：`Array.sort`方法会接收实现了`Comparator<String>`的某个类的对象，在这个对象上调用`compare`方法会执行这个lambda表达式

* lambda表达式可以转换为接口
	* 如：java.util.function包中定义了许多通用的函数式接口，其中一个接口`BiFunction<T, U, R>`描述了参数类型为T和U且返回类型为R的函数，使用如下：`BiFunction<String, String, Integer> comp = (first, second) -> first.length9) - second.length();`

### 6.3.4 方法引用

* 方法引用放置在参数的位置上代替参数，表示使用该方法对参数进行类似lambda函数的操作。类似于C++中的函数指针

1. `object::instanceMethod`：等价于提供方法参数的lambda表达式
	* `System.out::println`等价于`x -> System.out.println(x)`
2. `Class::staticMethod`：等价于提供方法参数的lambda表达式
	* `Math::pow`等价于`(x, y) -> Math.pow(x, y)`
3. `Class::instanceMethod`：第一个参数会成为方法的目标，
	* `String::compareToIgnoreCase`等价于`(x, y) -> x.compareToIgnoreCase(y)`

* 如果有多个同名的重载方法，编译器就会尝试从上下文中找出指定的方法

* 类似于lambda表达式，方法引用不能独立存在，总是会转换为函数式接口的实例

* 可以在方法引用中使用`this`与`super`

### 6.3.5 构造器引用

* 构造器引用与方法引用类似，只不过方法名为`new`。如`Person::new`是`person`构造器的一个引用，编译器根据上下文推导出是哪一个构造器

* 可以用数组类型建立构造器引用，如`int[]::new`，它有一个参数，即数组的长度
	* `int[]::new`等价于`x -> new int[x]`
	* Java无法构造泛型类型T的数组，`new T[n]`会产生错误，因为这会改为`new Object[n]`。可以使用数组构造器克服限制，例子如下：
		* 原：`Object[] people = stream.toArray();`
		* 优化后：`Person[] people = stream.toArray(Person[]::new);`

### 6.3.6 变量作用域

* 在lambda表达式中访问外围方法或类中的变量

* lambda表达式的构成：代码块、参数、自由变量的值(非参数而且不在代码块中定义的变量)
	* 捕获：表示lambda表达式的数据结构必须存储自由变量的值，即该变量被lambda表达式捕获
	* 要确保所捕获的值是明确定义的，并且只能引用值不会改变的变量，不能修改捕获的变量(不管是lambda表达式内部还是外部)，即lambda表达式中捕获的变量实际上是最终变量。实际上的最终变量值是指这个变量初始化之后就不会再为它赋新值

* lambda表达式的体与嵌套块有相同的作用域，同样适用于命名冲突和遮蔽的有关规则。在lambda表达式中声明与局部变量同名的参数或变量是不合法的

* lambda表达式中的`this`关键字指创建这个lambda表达式的方法的`this`参数

### 6.3.7 处理lambda表达式

* 使用lambda表达式的重点是延迟执行，可能的原因如下：
	* 在一个单独的线程中运行代码
	* 多次运行代码
	* 在算法的适当位置运行代码(如排序中的比较操作)
	* 发生某种情况时执行代码(如点击按钮、数据到达等)
	* 只在必要时才运行代码

* 要接受lambda表达式，需要选择(偶尔可能需要提供)一个函数式接口，常用函数式接口如下↓

|函数式接口|参数类型|返回类型|抽象方法名|描述|其他方法|
|:-:|:-:|:-:|:-:|:-:|:-:|
|`Runnable`|无|`void`|`run`|作为无参数和返回值的动作运行||
|`Supplier<T>`|无|`T`|`get`|提供一个`T`类型的值||
|`Consumer<T>`|`T`|`void`|`accept`|处理一个`T`类型的值|`andThen`|
|`BiConsumer<T, U>`|`T`、`U`|`void`|`accept`|处理`T`和`U`类型的值|`andThen`|
|`Function<T, R>`|`T`|`R`|`apply`|有一个`T`类型参数的函数|`compose`、`andThen`、`identity`|
|`BiFunction<T, U, R>`|`T`、`U`|`R`|`apply`|有`T`和`U`类型参数的函数|`addThen`|
|`UnaryOperator<T>`|`T`|`T`|`apply`|类型`T`上的一元操作符|`compose`、`andThen`、`identity`|
|`BinaryOperator<T>`|`T`、`T`|`T`|`apply`|类型`T`上的二元操作符|`andThen`、`maxBy`、`minBy`|
|`Predicate<T>`|`T`|`boolean`|`test`|布尔值函数|`and`、`or`、`negate`、`isEqual`|
|`BiPredicate<T, U>`|`T`、`U`|`boolean`|`test`|有两个参数的布尔值函数|`and`、`or`、`negate`|

* 基本类型`int`、`long`和`double`有特殊化规范可以减少自动装箱，特殊化规范如下所示↓，其中`p`、`q`为`int`、`long`、`double`，`P`、`Q`为`Int`、`Long`、`Double`

|函数式接口|参数类型|返回类型|抽象方法名|
|:-:|:-:|:-:|:-:|
|`BooleanSupplier`|`none`|`boolean`|`getAsBoolean`|
|`pSupplier`|`none`|`p`|`getAsP`|
|`pConsumer`|`p`|`void`|`accept`|
|`ObjPConsumer<T>`|`T`、`p`|`void`|`accept`|
|`pFUnction<T>`|`p`|`T`|`apply`|
|`pToQFunction`|`p`|`q`|`applyAsQ`|
|`ToPFunction<T>`|`T`|`p`|`applyAsP`|
|`ToPBiFunction<T, U>`|`T`、`U`|`p`|`applyAsP`|
|`PUnaryOperator`|`p`|`p`|`applyAsP`|
|`pBinaryOperator`|`p`、`p`|`p`|`applyAsP`|
|`pPredicate`|`p`|`boolean`|`test`|

* 如果设计接口，其中只有一个抽象方法，可以用`@FunctionalInterface`注解来标记这个接口，优点如下：
	1. 如无意中增加了另一个非抽象方法，编译器会产生一个错误消息
	2. javadoc页中会指出该接口是一个函数式接口
	* 该注解并不是必须使用，根据定义，任何有一个抽象方法的接口都是函数式接口 。不过使用该注解是一个很好的做法

### 6.3.8 再谈`Comparator`

* `Comparator`接口包含很多方便的静态方法来创建比较器，这些方法可以用于lambda表达式或方法引用

* 静态`comparing`方法取一个"键提取器"函数，将类型`T`映射为一个可比较的类型，对要比较的对象应用这个函数，然后对返回的键完成比较。如：`Arrays.sort(people, Comparator.comparing(Person::getName));`

* 可以把比较器与`thenComparing`方法串起来，如：`Arrays.sort(people, Comparator.comparing(Person::getLastName).thenComparing(Person::getFirstName));`

* 这些方法有很多变体，可以为`comparing`和`thenComparing`方法提取的键指定一个比较器，如：`Arrays.sort(people, Comparator.comparing(Person::getName, (s, t) -> Integer.compare(s.length(), t.length())));`
	* `comparing`和`thenComparing`方法都有变体形式，可以避免`int`、`long`或`double`值的装箱，如可将上式优化为：`Arrays.sort(people, ComparatorInt(p -> p.getName().length()));`

* 如果键函数可以返回`null`，可能就要用到`nullFirst`和`nullLast`适配器
	* 这些适配器会修改现有的比较器，从而在遇到`null`值时不会抛出异常，而是将这个值标记为小于或大于正常值
	* `nullFirst`方法需要一个比较器。`naturalOrder`方法可以为任何实现了`Comparable`的类建立一个比较器
	* `Arrays.sort(people, comparing(Person::getMiddleName, nullFirst(naturalOrder())));`
	* 静态`reverseOrder`方法会提供自然顺序的逆序。要让比较器逆序比较，可以使用`reversed`实例方法，如：`naturalOrder().reversed()`等价于`reverseOrder()`

## 6.4 内部类

* 定义：内部类是定义在另一个类中的类

* 使用内部类的原因：
	* 内部类方法可以访问该类定义所在的作用域中的数据，包括私有数据
	* 内部类可以对同一个包中的其他类隐藏起来
	* 当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷

* C++中有嵌套类，一个被嵌套的类包含在外部类的作用域内。嵌套是一种类之间的关系，而不是对象之间的关系。嵌套类的优点在于命名控制和访问控制

### 6.4.1 使用内部类访问对象状态

* 一个内部类位于外部类的内部，并不意味着每个外部类对象都有一个内部类实例。内部类对象是由外部类的方法构造

* 内部类皆可以访问自身的数据域，也可以访问创建他的外部类对象的数据域
	* 内部类的对象有一个隐式引用，指向了创建它的外部类对象。这个引用在内部类的定义中是不可见的
	* 外部类的引用在构造器中设置，编译器修改了所有的内部类的构造器，添加一个外部类引用的参数

* 内部类访问外部类私有变量的机制
	* 编译器会在外部类中添加静态方法，该方法将返回的私有变量作为参数传递给它的内部类。内部类方法访问外部类中的私有变量即为调用该方法
	* 调用外部类添加的方法需要拥有包可见性，因此可以把攻击代码放在被攻击类的包中去访问私有变量
	* 因此如果内部类访问了外部类的私有变量，就有可能通过附加在外部类所在包中的其他类访问它们

* 只有内部类可以是`private`类，常规类只可以具有包可见性或公有可见性

### 6.4.2 内部类的特殊语法规则

* 在内部类中外部类的引用为`OuterClassName.this`
	* 更加明确地编写内部对象的构造器语法：`outerObject.new InnerClass(param...);`
	* 在外部类的作用域之外，引用内部类的语法：`OuterClass.InnerClass`

* 内部类声明中的所有静态变量都必须是`final`：因为希望一个静态变量只有一个实例，不过对于每个外部对象，会分别有一个单独的内部类实例。如果这个变量不是`final`，它可能就不是唯一的

* 内部类不能有`static`方法

* 编译器会将内部类翻译成用`$`分隔外部类名与内部类名的常规类文件，而虚拟机对此一无所知

### 6.4.4 局部内部类

* 可以在方法中定义局部类

* 访问限制：局部类不能用`public`或`private`访问说明符进行声明，它的作用域被限定在声明这个局部类的块中

* 局部类对代码块外部可以完全地隐藏起来

* 局部类不仅能够访问外部类，还可以访问局部变量，不过只能访问事实上的`final`变量(即一旦赋值就绝不会改变的变量)
	* 局部类为了能够访问局部变量，局部类在局部变量释放之前将局部变量用所在方法的局部变量进行备份
	* 当创建一个对象的时候，局部变量就会被传递给构造器，并存储在编译器添加的一个变量中。编译器必须检测对局部变量的访问，为每一个变量创建相应的数据变量，并将局部变量拷贝到构造器中，以便将这些变量初始化为局部变量的副本

### 6.4.6 匿名内部类

* 定义：只创建局部内部类的一个对象，就不必为局部内部类命名，这种类就称为匿名内部类

* 习惯用匿名内部类实现事件监听器和其他回调。当然如今最好还是使用lambda表达式

* 如果构造函数的`()`后面跟一个`{`，正在定义的就是匿名内部类。语法如下↓：
	```Java
	SuperType data = new SuperType() {
		// 类中各种定义与实现
	};

	// SuperType可以是接口，此时内部类就需要实现这个接口
	// SuperType也可以是一个类，此时内部类就要扩展它
	```

* 由于匿名类没有类名，而构造器的名字必须与类名相同，因此匿名类不能有构造器。取而代之的是将构造器参数传递给父类构造器
	* 在内部类实现接口的时候，不能有任何构造函数，还要提供一组括号，语法如下↓：
	```Java
	new Interface() {
		// 类中定义与实现
	}
	```

* 双括号初始化
	* 使用场景：构造一个数组列表，并将它传递到一个方法，如果不再需要这个数组列表，最好让它作为一个匿名列表
	* 外层括号建立了`ArrayList`的一个匿名子类，内层括号则是一个对象构造块(见[4.6.7 初始化数据域的方法](#467-初始化数据域的方法))
	* 语法如下↓：
	```Java
	// 扩展形式
	ArrayList<String> data = new ArrayList<>();
	data.add("a");
	data.add("b");
	function(data);

	// 双括号初始化形式
	function(new ArrayList<String>() {{add("a"); add("b");}});
	```

* 获取当前类名：
	* 非静态函数：使用`getClass()`
		* 调用`getClass()`函数时调用的是`this.getClass()`
	* 静态函数：静态函数没有`this`指针，因此应该使用`new Object(){}.getClass().getEnclosingClass()`
		* `new Object(){}`会建立一个Object的一个匿名子类的一个匿名对象，`getEnclosingClass`会得到其外部类，也就是包含这个静态方法的类

### 6.4.7 静态内部类

* 用途：为了把一个类隐藏在另一个类的内部，并不需要内部类引用外部类对象，此时可以将内部类声明为`static`，以便取消产生的引用

* 只有内部类可以声明为`static`。静态内部类的对象除了没有生成它的外部类对象的引用特权外，与其他所有内部类完全一样

* 与常规内部类不同，静态内部类可以有静态变量和方法

* 访问语法：`OuterClass.InnerClass`

## 6.5 代理

* 用途：利用代理可以在运行时创建一个实现了一组给定接口的新类。只有在编译时无法确定需要实现哪个接口时才有必要使用

### 6.5.1 何时使用代理

* 使用场景：一个表示接口的class对象(有可能只包含一个接口)，它的确切类型在编译时无法确定。要想构造一个实现这些接口的类，就需要使用`newInstance`方法或[反射](#57-反射)找出这个类的构造器。但是不能实例化一个接口，需要在程序处于运行状态时定义一个新类
	* 路由对远程服务器的方法调用
	* 在程序运行期间，将用户接口事件与动作关联起来
	* 为了调试，跟踪方法应用

* 代理类具有的方法：指定接口所需要的全部方法、Object类中的全部方法
	* 不能在运行时定义这些方法的新代码，而是需要提供一个调用处理器。调用处理器是实现了`InvocationHandler`接口的类对象。在这个接口中只有一个方法：`Object invoke(Object proxy, Method method, Object[] args)`
	* 无论何时调用代理对象的方法，调用处理器的`invoke`方法都会被调用，并向其传递`Method`对象和原始的调用参数

### 6.5.2 创建代理对象

* 创建代理对象需要使用`Proxy`类的`newProxyInstance`方法，参数如下：
	1. 一个类加载器，用`null`表示使用默认的类加载器
	2. 一个Class对象数组，每个元素都是需要实现的接口
	3. 一个调用处理器

### 6.5.3 代理类的特性

* 代理类是在程序运行过程中创建的，然而一旦被创建，就变成了常规类，与虚拟机中的任何其他类没有什么区别

* 所有的代理类都扩展于`Proxy`类，一个代理类只有一个实例变量，就是调用处理器。它定义在`Proxy`超类中。为了履行代理对象的职责，所需要的任何附加数据都必须存储在调用处理器中。

* 所有的代理类都覆盖了Object类中的方法`toString`、`equals`和`hashCode`。如同所有的代理方法一样，这些方法仅仅调用了调用处理器的`invoke`。Object类中的其他方法(如`clone`和`getClass`)没有被重新定义

* 对于特定的类加载器和预设的一组接口来说，只能有一个代理类。即如果使用同一个类加载器和接口数组调用两次`newProxyInstance`方法的话，那么只能够得到同一个类的两个对象，也可以利用`getProxyClass`方法获得这个类，语法为：`Class proxyClass = Proxy.getProxyClass(null, interfaces);`

* 代理类一定是`public`和`final`。如果代理类实现的所有接口都是`public`，代理类就不属于某个特定的包；否则所有非`public`的接口都必须属于同一个包，同时代理类也属于这个包

* 可以通过调用Proxy类中的`isProxyClass`方法检测一个特定的Class对象是否代表一个代理类

# 7. 异常、断言和日志

## 7.1 处理错误

* 程序中可能出现的错误和问题：
	1. 用户输入错误
	2. 设备错误
	3. 物理限制
	4. 代码错误

* 在Java语言中，处理系统错误的机制：
	* 抛出异常
	* 使用断言：测试和调试阶段所使用的工具
	* 日志：在程序的整个声明周期都可以使用的工具

### 7.1.1 异常分类

* 在Java中，异常对象都是派生于`Throwable`类的一个实例
	* `Throwable`层次结构
		* `Error`：描述了Java运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象
		* `Exception`
			* `RuntimeException`：由程序错误导致的异常，如错误的类型转换、数组访问越界、访问`null`指针
			* `IOException`等：其他异常。程序本身没有问题，但由于当I/O错误这类问题导致的异常，如试图在文件尾部后面读取数据、试图打开一个不存在的文件、试图根据给定的字符串查找Class对象，但这个字符串表示的类并不存在

* 非受查异常与受查异常：
	* 非受查异常：派生于`Error`类或`RuntimeException`类的所有异常
	* 受查异常：所有其他的异常

* 虽然`RuntimeException`名称中带有"运行时"，但是所有的异常都发生在运行时

* C++异常与Java异常对应关系如下所示↓：

|C++|Java|注释|
|:-:|:-:|:-:|
|`logic_error`|`RuntimeException`|程序中的逻辑错误|
|`runtime_error`|非`RuntimeException`异常|由于不可预测的原因所引发的异常|

### 7.1.2 声明受查异常

* 受查异常：所有派生于`Error`类或`RuntimeException`类之外的异常

* 一个方法必须声明所有可能抛出的受查异常，而非受查异常要么不可控制(`Error`)，要么就应该避免发生(`RuntimeException`)
	* 方法应该在其首部声明所有可能抛出的异常，示例：`public FileInputStream(String name) throws FileNotFoundException`
	* 如果一个方法有可能抛出多个受查异常类型，那么就必须在方法的首部列出所有的异常类，每个异常类之间用`,`隔开 ，示例：`public Image loadImage(String s) throws FileNotFoundException, EOFException`
	* 不需要声明Java的内部错误，即从`Error`继承的错误，任何代码都具有抛出这些异常的能力，对其没有任何控制力

* 应该抛出异常的情况：
	1. 调用一个抛出受查异常的方法
	2. 程序运动过程中发现错误，并且利用`throws`语句抛出一个受查异常
	3. 程序出现错误
	4. Java虚拟机和运行时库出现的内部错误

* 继承关系中的异常：
	* 如果在子类中覆盖了超类的一个方法，子类方法中声明的受查异常不能比超类方法中声明的异常更通用，即子类方法中可以抛出更特定的异常，或根本不抛出异常
	* 如果超类方法没有抛出任何受查异常，子类也不能抛出任何受查异常

* 如果一个方法声明将会抛出一个异常，则实际可能抛出这个异常或这个异常的任意一个子类的异常

* C++(`throw`)与Java(`throws`)区别：
	* C++编译器不处理任何异常规范，`throw`说明符在运行时执行，而不是在编译是执行。但是如果函数抛出的异常没有出现在`throw`列表中，就会调用`unexpected`函数，该函数的默认处理方式是终止程序的运行
	* 在C++中，如果没有给出`throw`说明，函数可能会抛出任何异常；在Java中，没有`throws`说明符的方法将不能抛出任何受查异常

### 7.1.3 如何抛出异常

* 抛出异常步骤：找到一个合适的异常类、创建这个类的一个对象、将对象抛出。语法如下↓所示：
	```Java
	String function() throws EOFException {
		// ...
		if (发生异常)
			throw new EOFException();

		return aString;
	}
	```

* 一旦方法抛出了异常，这个方法就不能返回到调用者，即不必处理返回的默认值或错误代码

* 在Java中，只能抛出`Throwable`子类的对象，而在C++中，却可以抛出任何类型的值

### 7.1.4 创建异常类

* 习惯上，定义的类应该包含两个构造器，一个是默认的构造器，另一个是带有详细描述信息的构造器。实例如下↓：

```Java
class FileFormatException extends IOException {
	public FileFormatException() {}
	public FileFormatException(String gripe) {
		super(gripe);
	}
}
```

## 7.2 捕获异常

### 7.2.1 捕获异常

* 如果某个异常发生的时候没有在任何地方进行捕获，那程序就会终止执行，并在控制台上打印出异常信息，其中包括异常的类型和堆栈的内容

* 对于图形界面程序(applet和应用程序)，在捕获异常之后，也会打印出堆栈的信息，但程序将返回到用户界面的处理循环中

* 捕获异常语法如下↓：
	* 如果在`try`语句块中的任何代码抛出了一个在`catch`子句中说明的异常，那么程序将跳过`try`语句块的其余代码，并将执行`catch`子句中的处理器代码
	* 如果在`try`语句块中没有抛出任何异常，那么程序将跳过`catch`子句
	* 如果方法中的任何代码抛出了一个在`catch`子句中没有声明的异常类型，那么这个方法就会立刻退出
	```Java
	try {
		// ...
	} catch (ExceptionType e) {
		// ...
	}
	```

* 编译器严格执行`throws`说明符。如果调用了一个抛出受查异常的方法，就必须对它进行处理，或者继续传递
	* 通常应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常继续进行传递
	* 如果想传递一个异常，就必须在方法的首部添加一个`throws`说明符，以便告知调用者这个方法可能会抛出异常

* 如果编写一个覆盖父类的没有抛出异常的方法，那么子类的方法就必须捕获方法代码中出现的每一个受查异常。不允许在子类的`throws`说明符中出现超过父类方法所列出的异常类范围

### 7.2.2 捕获多个异常

* 在一个`try`语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理，示例如下↓：
	```Java
	try {
		// ...
	} catch (FileNotFoundException e) {
		// ...
	} catch (UnknownHostException e) {
		// ...
	} catch (IOException e) {
		// ...
	}
	```

* 异常对象可能包含与异常本身有关的信息
	* 可以尝试通过`e.getMessage()`得到详细的错误信息
	* 可以尝试通过`e.getClass().getName()`得到异常对象的实际类型

* 在Java SE 7中，同一个`catch`子句可以捕获多个异常类型，只有当捕获的异常类型彼此之间不存在子类关系时才需要这个特性。示例如下↓：
	```Java
	try {
		// ...
	} catch (FileNotFoundException | UnknownHostException e) {
		// ...
	} catch (IOException e) {
		// ...
	}
	```

* 捕获多个异常时，异常变量隐含为`final`变量，同时生成的字节码值包含一个对应公共`catch`子句的代码块

### 7.2.3 再次抛出异常与异常链

* 在`catch`子句中可以抛出一个异常，这样可以改变异常的类型
	* 当使用`catch`子句捕获到异常时，可以将原始异常设置为新异常的"原因"。在重新捕获新异常之后，可以通过新异常重新得到原始异常。语法示例如下↓：
	```Java
	try {
		// ...
	} catch (SQLException e) {
		Throwable se = new ServletException("init String");
		se.initCause(e);	// 设置原因
		throw se;	// 重新抛出异常
	}

	// 当重新捕获异常 se 后，可以重新得到原始异常 e
	Throwable e = se.getCause();
	```

* 如果在一个方法中发生了一个受查异常，而不允许抛出它，那么就可以通过上述包装技术，捕获这个异常，并将它包装成一个运行时异常

* 外围方法声明问题：如下述代码↓：
	```Java
	public void updateRecord() throws SQLException {
		// ...

		try {
			// ...
		} catch (Exception e) {
			// ...
			throw e;
		}
	}
	```
	* 在Java SE 7之前：`catch`子句中重新抛出的异常类型为`Exception`，比外围方法`updateRecord`抛出的异常类型`SQLException`范围更大，因此该语法是不合法的
	* 在Java SE 7之后：编译器会跟踪异常`e`来自`try`语句块，如果该`try`语句块中仅有的受查异常是`SQLException`，且异常`e`在`catch`子句中未改变，则将外围方法抛出的异常声明为`SQLException`是合法的

### 7.2.4 `finally`子句

* 不管是否有异常被捕获，`finally`子句中的代码都被执行，语法示例如下↓：
	```Java
	try {
		// 1
		// 抛出异常的代码
		// 2
	} catch (IOException e) {
		// 3
	} finally {
		// 4
	}
	// 5
	```
	* 代码没有抛出异常：执行1、2、4、5
	* 抛出`catch`子句中捕获的异常：执行1、3、4、5
	* 抛出`catch`子句中没有捕获的异常：执行1、4，并将异常抛给该方法的调用者

* `try`语句块可以只有`finally`子句，而没有`catch`子句

* 当`finally`语句块中包括`return`语句时：如果利用`return`语句从`try`语句块中退出，在方法返回前，`finally`子句的内容将被执行，如果`finally`语句块中也含有`return`语句，此时`finally`中的返回值将覆盖`try`语句块中的返回值

* 如果`try`语句块中抛出一个`catch`子句没有捕获的异常，并且在执行`finally`语句时又抛出一个新的异常，此时`finally`子句所抛出的异常将会覆盖`try`语句块抛出的异常，先抛出的异常将会丢失

### 7.2.5 带资源的`try`语句

* 对于如下原始代码模式，如果资源属于一个实现了`AutoCloseable`接口的类，Java SE 7为这种模式代码提供了一个快捷方法，代码如下所示↓：
	* `AutoCloseable`接口有一个方法`void close() throws Exception`
	```Java
	/* 原始代码模式 */

	// 打开资源
	try {
		// ...
	} finally {
		// 关闭资源
	}

	/* 带资源的 try 语句最简形式 */
	try (Resource res = ...) {
		// ...
	}
	```

* 在上述带资源的`try`语句最简形式中，`try`语句块退出时，会自动调用`res.close()`

* 还可以指定多个资源，中间用`;`分隔，语法为：`try(Resource res1 = ...; Resource res2 = ...) {}`

* 如果`try`语句块中抛出一个异常，同时`close()`方法也抛出一个异常，此时重新抛出`try`语句块中的异常，`close()`方法抛出的异常会被抑制，并由`addSuppressed()`方法添加到原来的异常

* 如果对`close()`方法抛出的异常感兴趣，可以调用`getSuppressed()`方法得到从`close()`方法抛出的并且被抑制的异常列表

* 带资源的`try`语句也可以有`catch`子句和一个`finally`子句，这些子句会在关闭资源之后执行

### 7.2.6 分析堆栈轨迹元素

* 堆栈轨迹：一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置，可以在程序中访问堆栈轨迹，代码示例如下↓：
	```Java
	// 使用 printStackTrack 方法
	Throwable t = new Throwable();
	StringWriter out = new StringWriter();
	t.printStackTrace(new PrintWriter(out));
	String description = out.toString();

	// 使用 getStackTrace 方法
	Throwable t = new Throwable();
	StackTraceElement[] frames = t.getStackTrace();
	for (StackTraceElement frame : frames)
		// 分析 frame
	```
	* 可以调用`Throwable`类的`printStackTrace`方法访问堆栈轨迹的文本描述信息
	* 另一种更灵活的方式是使用`getStackTrace`方法，它会得到`StackTraceElement`对象的一个数组，可以在程序中分析这个对象数组。`StackTraceElement`类含有能够获得文件名的方法，`toString`方法将产生一个格式化的字符串，其中包含所获得的信息

* 静态的`Thread.getAllStackTrace`方法可以产生所有线程的堆栈轨迹，示例代码如下↓：
	```Java
	Map<Thread, StackTraceElement[]> map = Thread.getAllStackTracks();
	for (Thread t : map.ketSet()) {
		StackTraceElement[] frames = map.get(t);
		// 分析 frames
	}
	```
	* map见[9. 集合](#9-集合)，线程见[14. 并发](#14-并发)

## 7.3 使用异常机制的技巧

1. 异常处理不能代替简单的测试：捕获异常所花费的时间大大超过了执行简单的测试，因此应只在异常情况下使用异常机制
2. 不要过分地细化异常
3. 利用异常层次结构
	* 不要只抛出`RuntimeException`异常，应该寻找更加适当的子类或创建自己的异常类
	* 不要只捕获`Throwable`异常，否则会使程序代码更难读、更难维护
	* 考虑受查异常与非受查异常的区别。受查异常本来就非常庞大。不要为逻辑错误抛出这些异常
	* 将一种异常转换成另一种更加适合的异常时不要犹豫
4. 不要压制异常。如果一个方法中的某个异常出现概率特别小，可以关闭该异常，即在调用该方法时，捕获该异常并不进行任何处理
5. 在检查错误时，"苛刻"比放任更好。有时传递异常比捕获异常更好，让高层次的方法通知用户发生了错误，或者放弃不成功的命令更加适宜
	* 早抛出，晚捕获

## 7.4 使用断言

### 7.4.1 断言的概念

* 断言机制：允许在测试期间向代码中插入一些检查语句。当代码发布时，这些插入的检测语句将会被自动地移走

* 语法：`assert 条件;`与`assert 条件: 表达式`
	* 对条件进行检测，如果结果为`false`，则抛出一个`AssertionError`异常
	* 在`assert 条件: 表达式`中，表达式将被传入`AssertionError`的构造器，并转换成一个消息字符串。`表达式`部分的唯一目的是产生一个消息字符串，`AssertionError`对象并不存储表达式的值，因此不可能在以后得到它

* C语言中的`assert`宏将断言中的条件转换成一个字符串，当断言失败时，这个字符串将会被打印出来。在Java中，条件并不会自动地成为错误报告中的一部分，如果希望看到这个条件，就必须将它以字符串的形式传递给`AssertionError`对象

### 7.4.2 启用和禁用断言

* 在默认情况下，断言被禁用。在启用或禁用断言是不需要重新编译程序。启用或禁用断言是类加载器的功能。当断言被禁用时，类加载器将跳过断言代码，因此不会降低程序运行的速度

* 开启断言：
	* 可以在运行程序时用`-enableassertions`或`-ea`选项启用，如：`java -enableassertions MyApp`
	* 也可以在某个类或整个包中使用断言，如：`java -ea:MyClass -ea:com.mycompany.mylib... MyApp`将开启`MyClass`类以及在`com.mycompany.mylib...`包和它的子包中的所有类的断言。选项`-ea`开启默认包中的所有类的断言

* 禁用断言
	* 也可以用选项`-disableassertions`或`-da`禁用某个特定类和包的断言，如：`java -ea:... -da:MyClass MyApp`

* 有些类不是由类加载器加载，而是直接由虚拟机加载。可以使用这些开关有选择的启用或禁用那些类中的断言。但是启用和禁用所有断言的`-ea`和`-da`开关不能应用到那些没有类加载器的"系统类"上。对于这些系统类来说，需要使用`-enablesystemassertions`或`-esa`开关启用断言

* 在程序中也可以控制类加载器的断言状态

### 7.4.3 使用断言完成参数检查

* 使用断言的场景：
	* 断言失败是致命的、不可恢复的错误
	* 断言检查只用于开发和测试段
	* 不能使用断言向程序的其他部分通告发生了可恢复性的错误，并且不应该作为程序向用户通告问题的手段。断言只应该用于在测试阶段确定程序内部的错误位置

## 7.5 记录日志

* 记录日志API的优点
	* 可以很容易地取消全部日志记录，或者仅仅取消某个级别的日志，而且打开和关闭这个操作也很容易
	* 可以很简单地禁止日志记录的输出，因此将这些日志代码留在程序中的开销很小
	* 日志记录可以被定向到不同的处理器，用于在控制台中显示，用于存储在文件中等
	* 日志记录器和处理器都可以对记录进行过滤。过滤器可以根据过滤实现器指定的标准丢弃那些无用的记录项
	* 日志记录可以采用不同的方式格式化，例如纯文本或XML
	* 应用程序可以使用多个日志记录器，他们使用类似包名的具有层次结构的名字，如`com.mycompany.myapp`
	* 在默认情况下，日志系统的配置由配置文件控制。如果有需要的话，应用程序可以替换这个配置

### 7.5.1 基本日志

* 生成简单的日志，可以使用全局日志记录器并调用其`info`方法：`Logger.getGlobal().info("abc");`

* 取消所有的日志：在适当的地方(如`main`开始)调用`Logger.getGlobal().setLevel(Level.OFF);`

### 7.5.2 高级日志

* 在一个应用程序中，可以自定义日志记录器。可以调用`getLogger`方法创建或获取记录器：`private static final Logger myLogger = Logger.getLogger("abc");`

* 未被任何变量引用的日志记录器可能会被垃圾回收。为了防止这种情况发生，要像上述例子一样，用一个静态变量存储日志记录器的一个引用

* 与包名类似，日志记录器名也具有层次结构

* 与包名相比，日志记录器的层次性更强。对于包来说，一个包的名字与其父包的名字之间没有语义关系；但是日志记录器的父子之间将共享某些属性。例如如果对`com.mycompany`日志记录器设置了日志级别，它的子记录器也会继承这个级别

* 日志记录器级别通常有以下七个级别：`SEVERE`、`WARNING`、`INFO`、`CONFIG`、`FINE`、`FINER`、`FINEST`
	* 在默认情况下，只记录前三个级别
	* 可以设置其他的级别，例如：`logger.setLevel(Level.FINE);`，此时`FINE`和更高级别的记录都可以记录下来
	* 可以使用`Level.ALL`开启所有级别的记录，或者使用`Level.OFF`关闭所有级别的记录

* 记录方式：`logger.fine(message);`或`logger.log(Level.FINE, message);`

* 默认的日志配置记录了`INFO`或更高级别的所有记录，因此应使用`CONFIG`、`FINE`、`FINER`和`FINEST`级别类记录有助于诊断，但是对于程序员没有太大意义的调试信息

* 如果将记录级别设计为`INFO`或者更低，则需要修改日记处理器的配置。默认的日志处理器不会处理低于`INFO`级别的信息

* 默认的日志记录将显示包含日志调用的类名和方法名，如同堆栈所显示的那样。但是如果虚拟机对执行过程进行了优化，就得不到准确的调用信息。此时可以调用`logp`方法获得调用类和方法的确切位置，这个方法的签名为：`void logp(Level l, String className, String methodName, String message);`

* 记录日志的常见用途是记录那些不可预料的异常，可以使用`void throwing(String className, String methodName, Throwable t)`和`void log(Level l, String message, Throwable t)`方法提供日志记录中包含的异常描述内容，典型用法如下↓：
	```Java
	// void throwing(String className, String methodName, Throwable t)
	if (...) {
		IOException exception = new IOException("...");
		logger.throwing("com.mycompany.mylib.Reader", "read", exception);
		throw exception;
	}

	// void log(Level l, String message, Throwable t)
	try {
		// ...
	} catch (IOException e) {
		Logger.getLogger("com.mycompany.myapp").log(Level.WARNING, "Reading image", e);
	}
	```
	* 调用`throwing`可以记录一条`FINER`级别的记录和一条以`THROW`开始的信息

### 7.5.3 修改日志管理器配置

* 可以通过编辑配置文件来修改日志系统的各种属性
	* 在默认情况下，配置文件存在于：`jre/lib/logging.properties`
	* 要想使用另一个配置文件，就要将`java.util.logging.config.file`特性设置为配置文件的存储位置，并用下列命令启动应用程序：`java -Djava.util.logging.config.file=configFile MainClass`

* 日志管理器在VM启动过程中初始化，这在`main`执行之前完成。如果在`main`中调用`System.setProperty("java.util.logging.config.file", file)`，也会调用`LogManager.readConfiguration()`来重新初始化日志管理器

* 修改默认的日志记录级别：
	* 要想修改默认的日志记录级别，就需要编辑配置文件，并修改以下命令行：`.level=INFO`
	* 可以通过添加以下内容来指定自己的日志记录级别：`com.mycompane.myapp.level=FINE`，即在日志记录器后面添加后缀`.level`

* 日志记录并不将消息发送到控制台上，这是处理器的任务。另外处理器也有级别。要想在控制台上看到`FINE`级别的消息，就需要进行下列设置：`java.util.logging.ConsoleHandler.lever=FINE`

* 在日志管理器配置的属性设置不是系统属性，因此用`-Dcom.mycompany.myapp.level=FINE`启动应用程序不会对日志记录器产生任何影响

* 日志属性文件由`java.util.logging.LogManager`类处理
	* 可以通过将`java.util.logging.manager`系统属性设置为某个子类的名字类指定一个不同的日志管理器
	* 在保存标准日志管理器的同时，还可以从日志属性文件跳过初始化
	* 还有一种方式是将`java.util.logging.config.class`系统属性设置为某个类名，该类再通过其他方式设定日志管理器属性

### 7.5.4 本地化

* 在本地化日志消息时需要牢记的一些要点：
	* 本地化的应用程序包含资源包中的本地特定信息。资源包有各个地区的映射集合组成。如某个资源包可能将字符串"readingFile"映射成英文的"Reading file"
	* 一个程序可以包含多个资源包，一个用于菜单，其他的用于日志消息
		* 每个资源包都有一个名字
		* 要想将映射添加到一个资源包中，需要为每个地区创建一个文件
		* 英文消息映射位于`com/mycompany/logmessages_en.properties`文件中
		* 可以将这些文件与应用程序的类文件放在一起，以便`ResourceBundle`类自动地对它们进行定位
		* 这些文件都是纯文本文件，
	* 在请求日志记录器时，可以指定一个资源包：`Logger logger = Logger.getLogger(loggerName, "com.mycompany.logmessages");`，然后为日志消息指定资源包的关键字，而不是实际的日志消息字符串：`logger.info("readingFile");`
	* 通常需要在本地化的消息中添加一些参数，因此消息应该包括占位符`{0}`、`{1}`等。例如要想在日志消息中包含文件名，就应该用下述方式包括占位符：`Reading file {0}.`，然后通过调用下述方法想占位符传递具体的值：`logger.log(Level.INFO, "readingFile", fileName);`

### 7.5.5 处理器

* 在默认情况下，日志记录器将记录发送到`ConsoleHandler`中，并由它输出到`System.err`流中。特别是日志记录器还会将记录发送到父处理器中，而最终的处理器(命名为"")有一个`ConsoleHandler`

* 与日志记录器一样，处理器也有日志记录级别。对于一个要被记录的日志记录，它的日志记录级别必须高于日志记录器和处理器的阈值。日志管理器配置文件设置的默认控制台处理器的日志记录级别为：`java.util.logging.ConsoleHandler.level=INFO`
	* 要想记录`FINE`级别的日志，就必须修改配置文件中的默认日志记录级别和处理器级别
	* 另外还可以绕过配置文件，安装自己的处理器，代码示例如下↓：
	```Java
	Logger logger = Logger.getLogger("com.mycompany.myapp");
	logger.setLevel(Level.FINE);
	logger.setUseParentHandlers(false);
	Handler handler = new ConsoleHandler();
	handler.setLevel(Level.Fine);
	logger.addHandler(handler);
	```
	* 在默认情况下，日志记录器将记录发送到自己的处理器和父处理器。上述日志记录器是原始日志记录器(命名为"")的子类，而原始日志记录器将会把所有等于或高于`INFO`级別的记录发送到控制台。然而，并不想两次看到这些记录，因此应该将`useParentHandlers`属性设置为`false`

* 要想将日志记录发送到其他地方，就要添加其他的处理器。日志API为此提供了两个很有用的处理器，`SocketHandler`与`FileHandler`
	* `SocketHandler`将记录发送到特定的主机和端口
	* `FileHandler`可以收集文件中的记录
		* 直接将记录发送到默认文件的处理器示例：`FileHandler handler = new FileHandler(); logger.addHandler(handler);`
		* 这些记录被发送到用户主目录的`javan.log`文件中，n是文件名的唯一编号
		* 在默认情况下，记录被格式化为XML

* 可以通过设置日志管理器配置文件中的不同参数，或者利用其他的构造器来修改文件处理器的默认行为。日志管理器配置文件中的文件处理器配置参数如下表所示↓：

|配置属性|描述|默认值|
|:-:|:-:|:-:|
|`java.util.logging.FileHandler.level`|处理器级别|`Level.ALL`|
|`java.util.logging.FileHandler.append`|控制处理器应该追加到一个已经存在的文件尾部；还是应该为每个运行的程序打开一个新文件|`false`|
|`java.util.logging.FileHandler.limit`|在打开另一个文件之前允许写入一个文件的近似最大字节数(0表示无限制)|在`FileHandler`类中为`0`(表示无限制)；在默认的日志管理器配置文件中为50000|
|`java.util.logging.FileHandler.pattern`|日志文件名的模式，参见下表的模式变量|`%h/java%u.log`|
|`java.util.logging.FileHandler.count`|在循环序列中的日志记录数量|`1`(不循环)|
|`java.util.logging.FileHandler.filter`|使用的过滤器类|没有使用过滤器|
|`java.util.logging.FileHandler.encoding`|使用的字符编码|平台的编码|
|`java.util.logging.FileHandler.formatter`|记录格式器|`java.util.logging.XMLFormatter`|

* 日志记录文件模式变量

|变量|描述|
|:-:|:-:|
|`%h`|系统属性`user.home`的值|
|`%t`|系统临时目录|
|`%u`|用于解决冲突的唯一编号|
|`%g`|为循环日志记录生成的数值(当使用循环功能且模式不包括`%g`时，使用后缀`%g`)|
|`%%`|`%`字符|

* 多个应用程序(或者同一个应用程序的多个副本)使用同一个日志文件
	* 应该开启`append`标志
	* 另外，应该在文件名模式中使用`％u`，以便每个应用程序创建日志的唯一副本

* 开启文件循环功能：日志文件以`myapp.log.0`、`myapp.log.1`、`myapp.log.2`，这种循环序列的形式出现。只要文件超出了大小限制，最旧的文件就会被删除，其他的文件将重新命名， 同时创建一个新文件，其编号为0

* 可以将日志记录作为辅助文档提供给技术支持员工。如果程序的行为有误，用户就可以返回查看日志文件以找到错误的原因，在这种情况下，应该开启`append`标志， 或使用循环日志，也可以两个功能同时使用

* 可以通过扩展`Handler`类或`StreamHandler`类自定义处理器

### 7.5.6 过滤器

* 在默认情况下，过滤器根据日志记录的级别进行过滤
	* 每个日志记录器和处理器都可以有一个可选的过滤器来完成附加的过滤
	* 可以通过实现`Filter`接口并定义`boolean isLoggable(LogRecord record)`方法来自定义过滤器

* 在`boolean isLoggable(LogRecord record)`方法中，可以对日志记录进行分析，返回`true`表示这些记录应该包含在日志中

* 通过调用`setFilter`方法将一个过滤器安装到一个日志记录器或处理器中。同一时刻最多只能有一个过滤器

### 7.5.7 格式化器

* `ConsoleHandler`类和`FileHandler`类可以生成文本和XML格式的日志记录

* 可以通过扩展`Formatter`类并覆盖`String format(LogRecord record)`方法以自定义格式
	* 在`format`方法中，有可能会调用`String formatMessage(LogRecord record)`方法。这个方法对记录中的部分消息进行格式化、参数替换和本地化应用操作

* 许多文件格式(如XML)需要在已格式化的记录的前后加上一个头部和尾部，在示例中需要覆盖下面两个方法：`String getHead(Handler h)`、`String getTail(Handler h)`

* 调用`setFormatter`方法将格式化器安装到处理器中

### 7.5.8 日志记录说明

1. 为一个简单的应用程序，选择一个日志记录器，并把日志记录器命名为与主应用程序包一样的名字，如`com.mycompany.myprog`
	* 可以通过调用`Logger logger = Logger.getLogger("com.mycompany.myprog");`方法得到日志记录器
	* 可以利用一些日志操作将下述的静态域添加到类中：`private static final logger = Logger.getLogger("com.myconpany.myprog");`
2. 默认的日志配置将级别等于或高于`INFO`级别的所有消息记录到控制台
	* 用户可以覆盖默认的配置文件。但是正如前面所述，改变配置需要做相当多的工作。因此最好在应用程序中安装一个更加适宜的默认配置
	* 下列代码确保将所有的消息记录到应用程序特定的文件中。可以将这段代码放置在应用程序的`main`方法中。代码如下所示↓：
	```Java
	if (System.getProperty("java.util.logging.config.class") == null &&
		System.getProperty("java.util.logging.config.file") == null) {
		try {
			Logger.getLogger("").setLevel(level.ALL);
			final int LOG_ROTATION_COUNT = 10;
			Handler handler = new FileHandler("%h/myapp.log", 0, LOG_ROTATION_COUNT);
			Logger.getLogger("").addHandler(handler);
		} catch (IOException e) {
			logger.log(level.SEVERE, "Can't create log file handler", e);
		}
	}
	```

3. 现在可以记录自己想要的内容了。但需要牢记：所有级别为`INFO`、`WARNING`和`SEVERE`的消息都将显示到控制台上
	* 因此，最好只将对程序用户有意义的消息设置为这几个级别
	* 将程序员想要的日志记录，设定为`FINE`是一个很好的选择

## 7.6 调试技巧

1. 使用`System.out.println("x=" + x);`或`Logger.getGlobal().info("x=" + x);`打印或记录任意变量的值
2. 可以在每一个类中放置一个单独的`main`方法，分别为每个文件调用Java虚拟机进行运行测试
3. 常见单元测试框架[JUnit](http://junit.org)
4. 日志代理是一个子类的对象，它可以截获方法调用，并进行日志记录，然后调用超类中的方法
5. 利用`Throwable`类提供的`printStackTrace`方法，可以从任何一个异常对象中获得堆栈情况；也可以在代码的任何位置插入`Thread.dumpStack();`以获得堆栈轨迹
6. 一般来说，堆栈轨迹显示在`System.err`上
	* 可以利用`printStackTrace(PrintWriter s)`方法将堆栈轨迹发送到一个文件中
	* 可以采用`String out = new StringWriter(); new Throwable().printStackTrace(new PrintWriter(out)); String description = out.toString();`将堆栈轨迹捕获到一个字符串中
7. 将一个程序中的错误信息保存在一个文件中是非常有用的
	* 捕获错误信息：错误信息被发送到`System.err`中，而不是`System.out`中。因此不能通过运行`java MyProgram > errors.txt`获取错误信息，而是采用`java MyProgram 2> errors.txt`捕获错误流
	* 在同一个文件中同时捕获`System.err`和`System.out`：`java MyProgram 1> errors.txt 2>&1`
8. 让非捕获异常的堆栈轨迹出现在`System.err`中并不是一个很理想的方法，比较好的方式是将这些内容记录到一个文件中

	* 可以调用`Thread.setDefaultUncaughtExceptionHandler`方法改变非捕获异常的处理器
9. 要想观察类的加载过程，可以用`-verbose`标志启动Java虚拟机，这种方法有助于诊断由于类路径引发的问题
10. `-Xlint`选项告诉编译器对一些普遍容易出现的代码问题进行检査

	* 术语`lint`最初用来描述一种定位C程序中潜在问题的工具，现在通常用于描述查找可疑但不违背语法规则的代码问题的工具
11. Java虚拟机增加了对Java应用程序进行监控和管理的支持。它允许利用虚拟机中的代理装置跟踪内存消耗、线程使用、类加载等情况。这个功能对于像应用程序服务器这样大型的、长时间运行的Java程序来说特别重要
12. 可以使用`jmap`实用工具获得一个堆的转储，其中显示了堆中的每个对象。使用命令如下↓：
	```
	jmap -dump:format=b, file=dumpFileNameProcessID
	jhat dumpFileName
	```
	* 然后，通过浏览器进人localhost:7000，将会运行一个网络应用程序，借此探查转储对象时堆的内容
13. 如果使用`-Xprof`标志运行Java虚拟机，就会运行一个基本的剖析器来跟踪那些代码中经常被调用的方法。剖析信息将发送给System.out。输出结果中还会显示哪些方法是由即时编译器编译的

# 8. 泛型程序设计

## 8.1 为什么要使用泛型程序设计

* 在Java SE 7及以后的版本中，构造函数中可以省略泛型类型：`ArrayList<String> files = new ArrayList<>()`。省略的类型可以从变量的类型推断得出

* 类型参数使得程序具有更好的可读性和安全性

## 8.2 定义简单泛型类

* 一个泛型类就是具有一个或多个类型变量的类，泛型类示例代码如下所示↓：
	```Java
	public class Pair<T> {
		private T first;
		private T second;

		public Pair() {first = null; second = null;}
		public Pair(T first, T second) {this.first = first; this.second = second;}

		public T getFirst() {return first;}
		public T getSecond() {return second;}

		public void setFirst(T newValue) {first = newValue;}
		public void setSecond(T newValue) {second = newValue;}
	}
	```

* 泛型类可以有多个类型变量，例如：`public class Pair<T, U> {...}`

* 类定义中的类型变量指定方法的返回类型以及域和局部变量的类型

* 常见类型变量命名规则
	* 类型变量使用大写形式，且比较短
	* 使用`E`表示集合的元素类型
	* 使用`K`和`V`分别表示映射的键与值的类型
	* 使用`T`、`U`和`S`表示任意类型

* 用具体的类型替换类型变量就可以实例化泛型类型，如：`Pair<String>`

	* 即泛型类可以看做普通类的工厂

## 8.3 泛型方法

* 在普通类中定义带有类型参数的简单方法
	* 类型变量放在修饰符后面，返回类型的前面
	* 代码示例如下↓：
	```Java
	class className {
		public static <T> T getMiddle(T... a) {
			return a[a.length / 2];
		}
	}
	```

* 泛型方法可以定义在普通类中，也可以定义在泛型类中

* 调用一个泛型方法
	* 在方法名前的尖括号中放入具体的类型，如：`String middle = className.<String>getMiddle("a", "b", "c");`
	* 大多数情况下，方法调用中可以省略类型参数，编译器有足够的能够推断出所调用的方法，如：`String middle = className.getMiddle(3.14, 2, 3);`。但上述调用会有错误，编译器将会自动打包参数为1个Double和2个Integer对象，而后寻找这些类的共同超类型。事实上；找到2个这样的超类型：`Number`和`Comparable`接口，其本身也是一个泛型类型。在这种情况下，可以采取的补救措施是将所有的参数写为double值

* 在C++中将类型参数放在方法名后面，有可能会导致语法分析的歧义。如：`g(f<a, b>(c))`可以理解为"用`f<a, b>(c)`的结果调用`g`"，或者理解为"用两个布尔值`f<a`和`b>(c)`调用`g`"

## 8.4 类型变量的限定

* 可以通过对类型变量设置限定以实现对类型变量加以约束，如：`public static <T extends Comparable> T min(T[] a) {}`
	* 但是`Comparable`接口本身就是一个泛型类型，因此上述编译器会产生警告。[8.8 通配符类型](#88-通配符类型)介绍了如何在`Comparable`接口中适当地使用类型参数
	* 在C++中不能对模板参数的类型加以限制
	* 使用关键字`extends`而不是`implements`。`<T extends U>`表示T是U的子类型。T和U可以是类，也可以是接口
	* 一个类型变量或通配符可以有多个限定，限定类型用`&`分割，类型变量之间用`,`分割。如：`<T extends Comparable & Serializable>`
	* 在Java的继承中，可以根据需要拥有多个接口超类型，但限定中至多有一个类。如果用一个类作为限定，它必须是限定列表中的第一个
## 8.5 泛型代码和虚拟机

* 虚拟机没有泛型类型对象，所有对象都属于普通类

### 8.5.1 类型擦除

* 无论何时定义一个泛型类型，都自动提供了一个相应的原始类型。原始类型的名字就是删去类型参数后的泛型类型名。擦除类型变量，并替换为限定类型(没有限定的变量就用Object)

* 原始类型如果没有限定泛型类型，就用Object替换，结果是一个普通的类。代码如下所示↓：
	```Java
	// 泛型类型
	public class Pair<T> {
		private T first;
		private T second;

		public Pair() {first = null; second = null;}
		public Pair(T first, T second) {this.first = first; this.second = second;}

		public T getFirst() {return first;}
		public T getSecond() {return second;}

		public void setFirst(T newValue) {first = newValue;}
		public void setSecond(T newValue) {second = newValue;}
	}

	// 原始类型
	public class Pair {
		private Object first;
		private Object second;

		public Pair() {first = null; second = null;}
		public Pair(Object first, Object second) {this.first = first; this.second = second;}

		public Object getFirst() {return first;}
		public Object getSecond() {return second;}

		public void setFirst(Object newValue) {first = newValue;}
		public void setSecond(Object newValue) {second = newValue;}
	}
	```

* 原始类型如果有限定的类型变量，则使用第一个限定的类型变量类替换原始类型。代码如下所示↓：
	```Java
	// 泛型类型
	public class Interval<T extends Comparable & Serializable> implements Serializable {
		private T lower;
		private T upper;

		public Interval(T first, T second) {
			if (first.compareTo(second) <= 0) {
				lower = first;
				upper = second;
			} else {
				lower = second;
				upper = first;
			}
		}
	}

	// 原始类型
	public class Interval implements Serializable {
		private Comparable lower;
		private Comparable upper;

		public Interval(Comparable first, Comparable second) {...}
	}

	// 如果原始类型声明为
	class Interval<T extends Serializable & Comparable> {}
	// 则原始类型用 Serializable 替换 T，编译器在必要时要向 Comparable 插入强制类型转换
	```

* 为了提高效率，应该将标签接口(没有方法的接口)放在边界列表的末尾

### 8.5.2 翻译泛型表达式

* 当程序调用泛型方法时，在擦除返回类型之后，编译器会插入强制类型转换
	* 如下述代码，擦除`getFirst`的返回类型后将返回Object类型。编译器自动插入`Employee`的强制类型转换。即编译器把这个方法调用翻译为两条虚拟机指令：①对原始方法`Pair.getFirst`的调用；②将返回的Object类型强制转换为`Employee`类型
	```Java
	Pair<Employee> buddies = ...;
	Employee buddy = buddies.getFirst();
	```

* 当存取一个泛型成员变量时也要插入强制类型转换。如`Employee buddy = buddies.first`也会在结果字节码中插入强制类型转换

### 8.5.3 翻译泛型方法-桥方法

* 类型擦除也会出现在泛型方法中，如`public static <T extends Comparable> T min(T[] a)`在类型擦除后只留下限定类型`Comparable`，即`public static Comparable min(Comparable[] a)`

* 桥方法：方法擦除带来了两个问题，如下述代码所示↓：
	```Java
	// 泛型类型
	public class Pair<T> {
		private T second;

		public T getSecond() {return second;}

		public void setSecond(T newValue) {second = newValue;}
	}

	class DateInterval extends Pair<LocalDate> {
		public void setSecond(LocalData second) {
			if (second.compareTo(getFirst()) >= 0)
				super.setSecond(second);
			// ...
		}
	}

	// 原始类型
	public class Pair {
		private Object second;

		public Object getSecond() {return second;}

		public void setSecond(Object newValue) {second = newValue;}
	}

	class DateInterval extends Pair {
		public void setSecond(LocalData second) {...}	// DateInterval中定义的方法
		// DateInterval 还存在从 Pair 类继承而来的 public void setSecond(Object second) 方法
	}
	```
	* 如果对上述代码进行如下所述代码调用时↓：
	```Java
	DateInterval interval = new DateInterval(...);
	Pair<LocalDate> pair interval;
	pair.setSecond(aDate);
	```
	* 这里希望对`setSecond`的调用具有多态性，并调用最合适的那个方法。由于`pair`引用`DateInterval`对象，所以应该调用`DateInterval.setSecond`。问题在于类型擦除与多态发生了冲突。要解决这个问题，就需要编译器在`DateInterval`类中生成一个桥方法：`public void setSecond(Object second) {setSecond(Data) second;}`
	* 对于`pair.setSecond(aDate)`调用，变量`pair`已经声明为类型`Pair<LocalDate>`，并且这个类型只有一个简单的方法`setSecond`，即`setSecond(Object)`。虚拟机用`pair`引用的对象调用这个方法。这个对象是`DateInterval`类型的，因而将会调用`DateInterval.setSecond(Object)`方法。这个方法是合成的桥方法。它调用`DateInterval.setSecond(Date)`

* 桥方法不仅用于泛型类型，在一个方法覆盖父类方法时可以指定一个更严格的返回类型，代码如下所示↓
	```Java
	public class Employee implements Cloneable {
		public Employee clone() throws CloneNotSupportedException {...}
	}
	```
	* `Object.clone()`和`Employee.clone()`方法被说成具有协变的放回类型。实际上，`Employee`类有两个克隆方法：通过代码定义的`Employee clone()`和生成的桥方法`Object clone()`。合成的桥方法调用了新定义的方法

* Java泛型转换：
	* 虚拟机中没有泛型，只有普通的类和方法
	* 所有的类型参数都用它们的限定类型替换
	* 通过合成桥方法来保持多态
	* 为保持类型安全性，在必要时插入强制类型转换

### 8.5.4 调用遗留代码

* 注解`@SuppressWarnings("unchecked")`会关闭对方法中所有代码的检查
	* 注释可以放在生成警告的代码所在的方法之前，代码如下所示↓：
	```Java
	@SuppressWarnings("unchecked")
	Dictionary<Integer, Components> labelTable = slider.getLabelTable();
	```
	* 注释也可以标注整个方法
	```Java
	@SuppressWarnings("unchecked")
	public void configureSlider() {...}
	```

## 8.6 约束与局限性

使用Java泛型时需要考虑一些限制，大多数限制都是由类型擦除引起的

### 8.6.1 不能用基本类型实例化类型参数

* 不能用类型参数代替基本类型，因此没有`Pair<double>`，只有`Pair<Double>`
	* 原因是类型擦除，擦除后`Pair`类含有Object类型的域，而Object不能存储double值
	* 当包装器类型不能接受替换时，可以使用独立的类和方法处理它们

### 8.6.2 运行时类型查询只适用于原始数组

* 虚拟机中的对象总有一个特定的非泛型类型，因此所有的类型查询只产生原始类型
	* `instanceof`类型测试：`if (a instanceof Pair<String>)`会产生编译器错误，实际上仅仅测试`a`是否是任意类型的一个`Pair`
	* 强制类型转换：`Pair<String> p = (Pair<String>) a;`会得到一个警告，仅仅会测试`a`是否是任意类型的一个`Pair`
	* 试图查询一个对象是否属于某个泛型类型时，倘若使用`instanceof`会得到一个编译器错误，如果使用强制类型转换会得到一个警告

* `getClass`方法总是返回原始类型，代码示例如下↓：
	```Java
	Pair<String> stringPair = ...;
	Pair<Employee> employeePair = ...;

	stringPair.getClass() == employeePair.getClass();
	// 该表达式的值结果是true，因为两次调用 getClass 都将返回 Pair.class
	```

### 8.6.3 不能创建参数化类型的数组

* 不能实例化参数化类型的数组，如`Pair<String> table = new Pair<String>[10];`就会报错。原因如下：
	* 擦除之后，`table`的类型是`Pair[]`，可以把它转换为`Object[]`：`Object[] objarray = table;`
	* 数组会记住他的元素类型，如果试图存储其他类型的元素，如`objarray[0] = "a";`，此时就会抛出一个`ArrayStoreException`异常
	* 对于泛型类型，擦除会使这种机制无效，`objarray[0] = new Pair<Employee>();`能够通过数组存储检查，不过仍会导致一个类型错误。出于这个原因，不允许创建参数化类型的数组

* 不允许创建参数化类型的数组，但是声明参数化类型的数组变量仍是合法的，如：`Pair<String>[]`。只是不能用`new Pair<String>[10]`初始化这个变量

* 可以声明通配类型的数组，然后进行类型转换：`Pair<String> [] table = (Pair<String>[]) new Pair<?>[10];`。但是结果将是不安全的。如果在`table[0]`中存储一个`Pair<Employee>`，然后将`table[0].getFirst()`作为参数调用一个String方法，会得到一个`ClassCastException`异常

* 如果需要收集参数化类型对象，只有一种安全而有效的方法：使用`ArrayList:ArrayList<Pair<String>>`

### 8.6.4 Varargs警告

* 向参数个数可变的方法传递一个泛型类型的实例，代码如下所示↓：
	```Java
	public static <T> void addAll(Collection<T> coll, T... ts) {
		for (t : ts)
			cool.add(t);
	}

	Collection<Pair<String>> table = ...;
	Pair<String> pair1 = ...;
	Pair<String> pair2 = ...;
	addAll(table, pair1, pair2);
	```
	* 参数`ts`实际上是一个数组，包含提供的所有实参
	* 为了调用`addAll`方法，Java虚拟机必须建立一个`Pair<String>`数组，这就违反了前文所述规则。不过对于这种情况，规则有所放松，只会得到一个警告，而不是错误
	* 可以采用两种方法来抑制这个警告：①为包含`addAll`调用的方法增加注解`@SuppressWarnings("unchecked")`；②在Java SE 7中，可以用`@SafeVarargs`直接标注`addAll`方法。对于只需要读取参数数组元素的所有方法，都可以使用这个注释，这仅限于最常见的用例。代码如下所示↓：
		```Java
		@SafeVarargs
		public static <T> void addAll(Collection<T> coll, T... ts)
		```

* 可以使用`@SafeVarargs`标注来消除创建泛型数组的有关限制，方法如下：`@SafeVarargs static <E> E[] array(E... array) {return array;}`
	* 此时可以调用：`Pair<String>[] table = array(pair1, pair2)`
	* 虽然方便，但此代码存在风险，如：`Object[] objarray = table; objarray[0] = new Pair<Employee>();`能顺利运行而不会出现`ArrayStoreException`异常(因为数组存储只会检查擦除后的类型)，但在处理`table[0]`时会在别处得到一个异常

### 8.6.5 不能实例化类型参数

* 不能使用像是`new T(...)`、`new T[...]`或`T.class`这样的表达式中的类型变量，如下述`Pair<T>`构造器就是非法的：`public Pair() {first = new T(); second = new T();}`

* 类型擦除将`T`改变成`Object`，且本意肯定不希望调用`new Object()`

* 在Java SE 8之后，最好的解决办法是让调用者提供一个构造器表达式，如：`Pair<String> p = Pair.makePair(String::new);`
	* `makePair`方法接受一个`Supplier<T>`，这是一个函数式接口，表示一个无参数而且返回类型为`T`的函数，代码如下所示↓：
	```Java
	Public static <T> Pair<T> makePair(Supplier<T> constr) {
		return new Pair<>(constr.get(), constr.get());
	}
	```

* 比较传统的解决方法是通过反射调用`Class.newInstace`方法来构造泛型对象，但是细节有点复杂
	* 不能调用`first = T.class.newInstance();`：表达式`T.class`是不合法的，因为它会擦除为`Object.class`
	* 必须像如下代码一样设计API以便得到一个Class对象↓：
	```Java
	public static <T> Pair<T> makePair(Class<T> cl) {
		try {
			return new Pair<>(cl.newInstance(), cl.newInstance());
		} catch(Exception ex) {
			return null;
		}
	}

	Pair<String> p = Pair.makePair(String.class);
	```
	`Class`类本身是泛型，如`String.class`是一个`Class<String>`的实例(事实上它是唯一的实例)，因此`makePair`方法能够推断出pair的类型

### 8.6.6 不能构造泛型数组

* 就像不能实例化一个泛型实例一样，也不能实例化数组

* 数组会填充`null`值，构造时看上去是安全的。不过数组本身也有类型，用来监控存储在虚拟机中的数组。这个类型会被擦除，因此`public static <T extends Comparable> T[] minmax(T[] a) {T[] mm = new T[2]; ...}`是错误的，类型擦除会让这个方法永远构造`Comparable[2]`数组

* 如果数组仅作为一个类的私有实例域，那么可以将这个数组声明为`Object[]`，并在获取元素时进行类型转换，代码如下所示↓：
	```Java
	public class ArrayList<E> {
		private Object[] elements;

		@SuppressWarnings("unchecked") public E get(int n) {return (E) elements[n];}
		public void set(int n, E e) {elements[n] = e;}	// 不需要类型转换
	}

	// 实际的实现比上述代码更加复杂
	public class ArrayList<E> {
		private E[] elements;

		public ArrayList() {elements = (E()) new Object[10];}
		// 这里强制类型转换 E[] 是一个假象
		// 而类型擦除使其无法察觉
	}
	```

* 当需要返回泛型数组时，掩盖类型会有运行时错误结果，代码如下所示↓：
	```Java
	public static <T extends Comparable> T[] minmax(T... a) {
		Object[] mm = new Object[2];
		// ...
		return (T[]) mm;
	}
	```
	当调用`String[] ss = ArrayAlg.minmax("a", "b", "c");`，编译时不会有任何警告，当`Object[]`引用赋给`Comparable[]`变量时，将会发生`ClassCastException`异常

	* 在这种情况下，可以让用户提供一个数组构造器表达式，代码如下所示↓：
	```Java
	public static <T extends Comparable> T[] minmax(IntFunction<T[]> constr, T... a) {
		T[] mm = constr.apply(2);
		// ...
	}

	String[] ss = ArrayAlg.minmax(String[]::new, "a", "b", "c");
	// 构造器表达式 String::new 指示一个函数，给定所需的长度，会构造一个指定长度的 String 数组
	```
	* 比较老式的方法是利用反射，调用`Array.newInstance`，代码如下所示↓：
	```Java
	public static <T extends Comparable> T[] minmax(T... a) {
		T[] mm = (T[]) Array.newInstance(a.getClass().getComponentType(), 2);
	}
	```
	`ArrayList`类的`toArray`方法需要生成一个`T[]`数组，但没有成分类型，因此由两种不同的形式：`Object[] toArray`与`T[] toArray(T[] result)`。第二个方法接收一个数组参数，如果数组足够大，就使用这个数组，否则用`result`成分类型构造一个足够大的新数组

### 8.6.7 泛型类的静态上下文中类型变量无效

* 不能在静态变量或方法中引用类型变量，代码如下所示↓：
	```Java
	public class Singleton<T> {
		private static T singleInstance;	// Error

		public static T getSingleInstance() {	// Error
			if (singleInstance == null)
				// 构造 T 的新实例
			return singleInstance;
		}
	}
	```
	* 如果上述代码能够运行，类型擦除后，只剩下`Singleton`类，它只包含一个`singleInstance`变量，无法生成不同的实例，如`Single<Random>`与`Single<JFileChooser>`等

### 8.6.8 不能抛出或捕获泛型类的实例

* 即不能抛出也不能捕获泛型类对象

* 泛型类扩展`Throwable`都是不合法的，如下所示定义就不能正常编译：`public class Problem<T> extends Throwable`

* `catch`子句中不能使用类型变量，如下所示代码将不能编译↓：
	```Java
	public static <T extends Throwable> void function(Class<T> t) {
		try {
			// ...
		} catch (T e) {	// Error：无法捕获类型变量
			Logger.global.info(...)
		}
	}
	```

* 在异常规范中使用类型变量是允许的，如下所示代码是合法的↓：
	```Java
	public static <T extends Throwable> void function(T t) throws T {
		try {
			// ...
		} catch (Throwable realCause) {
			t.initCause(realCause);
			throw t;
		}
	}
	```

### 8.6.9 可以消除对受查异常的检查

* Java异常处理的一个基本原则是必须为所有受查异常提供一个处理器，不过可以利用泛型消除这个限制。关键代码如下所示↓：
	```Java
	@SuppressWarnings("unchecked")
	public static <T extends Throwable> void throwAs(Throwable e) throws T {
		throw (T) e;
	}
	```

* 假设上述方法包含在类`Block`中，如果调用`Block.<RuntimeException>throwAs(t)`，(通过将类型变量设置为`RuntimeException`)编译器就会认为`t`是一个非受查异常。下述代码会把所有异常都转换为编译器所人为的非受查异常，代码如下所示↓：
	```Java
	try {
		// ...
	} catch (Throwable t) {
		Block.<RuntimeException>throwAs(t);
	}
	```

* 将上述代码包装在一个抽象类中
	* 用户可以覆盖`body`方法来提供一个具体的动作
	* 调用`toThread`时，会得到`Thread`类的一个对象，它的`run`方法不会介意受查异常
	```Java
	public abstract class Block {
		public abstract void body() throws Exception;

		public Thread toThread() {
			return new Thread() {
				public void run() {
					try {
						body();
					} catch (Throwable t) {
						Block.<RuntimeException>throwAs(t);
					}
				}
			};
		}

		@SuppressWarnings("unchecked")
		public static <T extends Throwable> void throwAs(Throwable e) throws T {
			throw (T) e;
		}
	}
	```
	* 测试程序如下所示，它会抛出一个受查异常↓：
	```Java
	public class Test {
		public static void main(String[] args) {
			new Block() {
				public void body() throws Exception {
					Scanner in = new Scanner(new File("abc"), "UTF-8");
					while (in.hasNext())
						System.out.println(in.next);
				}
			}
			.toThread().start();
		}
	}
	```
	* 运行测试程序时，如果没有提供名为abc的文件，就会得到一个栈轨迹，其中包含一个`FileNotFoundException`
	* 正常情况下，必须捕获线程`run`方法中的所有受查异常，把它们"包装"到非受查异常中，因为`run`方法声明为不抛出任何受查异常
	* 但是在上述代码中并没有做这种"包装"，只是抛出异常，并"哄骗"编译器，让它认为这不是一个受查异常

* 通过使用泛型类、擦除和`@SuppressWarnings`注解，就能消除Java类型系统的部分基本限制

### 8.6.10 注意擦除后的冲突

* 当泛型类型被擦除时，无法创建引发冲突的条件，代码如下所示↓：
	```Java
	public class Pair<T> {
		public boolean equals(T value) {
			return first.equals(value) && second.equals(value);
		}
	}
	```
	* 考虑一个`Pair<String>`，从概念上讲，它有两个`equals`方法：定义在`Pair<T>`中的`boolean equals(String)`与从`Object`中继承的`boolean equals(Object)`。但是`boolean equals(T)`方法擦除后就是`boolean equals(Object)`，与`Object.equals`方法发生冲突
	* 补救的办法重新命名引发错误的方法

* 泛型规范说明还有另一个原则：要想支持擦除的转换，就需要强行限制一个类或类型变量不能同时成为 同一个接口的 不同参数化的 两个接口类型的子类
	* 下述代码就是非法的↓：
	``` Java
	class Employee implements Comparable<Employee> {...}
	class Manager extents Employee implements Comparable<Manager> {...}	// Error
	```
	* `Manager`会实现`Comparable<Employee>`和`Comparable<Manager>`，这是同一接口的不同参数化
	* 该限制与类型擦除的关系并不十分明确，下述非泛型版本就是合法的↓
	```Java
	class Employee implements Comparable {...}
	class Manager extends Employee implements Comparable {...}
	```

## 8.7 泛型类型的继承规则

* 无论`S`与`T`有什么联系，通常`Pair<S>`与`Pair<T>`没有什么联系，因此下述代码是不合法的↓：
	```Java
	Manager[] topHonchos = ...;
	Pair<Employee> result = ArrayAlg.minmax(topHonchos);	// Error
	```
	* 但是可以将一个`Manager[]`数组赋给一个类型为`Employee[]`的变量，代码如下所示↓：
	```Java
	Manager[] managerBuddies = ...;
	Employee[] employeeBuddies = managerBuddies;
	```
	* 数组带有特别的保护，如果试图将一个低级别的雇员存储到`employeeBuddies[0]`，虚拟机将会抛出`ArrayStoreException`异常

* 可以将参数化类型转换为一个原始类型，如：`Pair<Employee>`是原始类型`Pair`的子类型。但是转换成原始类型之后，还有可能产生错误，代码如下所示↓：
	```Java
	Pair<Manager> managerBuddies = new Pair<>(...);
	Pair rawBuddies = managerBuddies;	// 可行
	rawBuddies.setFirst(new File("..."));	// 编译时仅会报一个 warning
	```
	* 后续通过 `rawBuddies.getFirst` 获得该对象并赋值给`Manager`变量时，与通常一样会抛出`ClassCastException`异常

* 泛型类可以扩展或实现其他的泛型类

	* 如`ArrayList<T>`类实现`List<T>`接口，这意味着一个`ArrayList<Manager>`可以被转换为一个`List<Manager>`。但是一个`ArrayList<Manager>`不是一个`ArrayList<Employee>`或`List<Employee>`

## 8.8 通配符类型

### 8.8.1 通配符概念

* 定义：通配符类型中，允许类型参数变化
	* 如通配符类型`Pair<? extends Employee>`表示任何泛型`Pair`类型，他的类型参数是`Employee`的子类，如`Pair<Manager>`，但不是`Pair<String>`
	* 类型`Pair<Manager>`是`Pair<? extends Employee>`的子类型

* 使用通配符不会通过`Pair<? extends Employee>`的引用破坏`Pair<Manager>`，代码如下所示：
	```Java
	Pair<Manager> managerBuddies = new Pair<>(...);
	Pair<? extends Employee> wildcardBuddies = managerBuddies;	// 可行
	wildcardBuddies.setFirst(lowlyEmployee);	// 编译错误
	```
	* 上述代码中类型`Pair<? extends Employee>`方法类似于`? extends Employee getFirst`与`void setFirst(? extends Employee)`
	* `void setFirst(? extends Employee)`：编译器只知道需要某个`Employee`的子类型，但不知道具体是什么类型，编译器拒绝传递任何特定的类型，因此将不可能调用`setFirst`方法
	* `? extends Employee getFirst()`：将`getFirst`的返回值赋给一个`Employee`的引用完全合法
	* 引入有限定的通配符可以区分安全的访问器方法和不安全的更改器方法

### 8.8.2 通配符的超类型限定

* 通配符限定与类型变量限定十分相似，但通配符还可以指定一个超类型限定
	* 如：`? super Manager`限制为`Manager`的所有超类型

* 带有超类型限定的通配符行为与[8.8.1 通配符概念](#881-通配符概念)中的相反，可以为方法提供参数，但不能使用返回值，代码示例如下，仅为示例作用，并不是Java真正的语法↓：
	* `void setFirst(? super Manager)`：编译器无法知道具体类型，因此不能接受类型为`Employee`或`Object`的参数，只能传递`Manager`类型的对象或`Manager`子类型对象
	* `? super Manager getFirst()`：不能保证返回对象的类型，只能把它赋给一个`Object`

* 带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取

* 通配符的一种常见用法：`<T extends Comparable<? super T>>`

### 8.8.3 无限定通配符

* 还可以使用无限定通配符，如：`Pair<?>`，好像与原始的`Pair`类型一样，但是有很大不同
	* `? getFirst()`：返回值只能赋给一个`Object`
	* `void setFirst(?)`：只能调用`setFirst(null)`，不能通过`Object`调用。`Pair<?>`和`Pair`本质的不同在于：可以用任意的`Object`对象调用原始`Pair`类的`setObject`方法

### 8.8.4 通配符捕获

* 通配符不是类型变量，因此不能在编写代码中使用`?`作为一种类型。此时可以使用一个辅助函数。代码如下所示↓：
	```Java
	// 辅助函数
	public static <T> void swapHelper(Pair<T> p) {
		T t = p.getFirst();
		p.serFirst(p.getSecond());
		p.setSecond(t);
	}

	// 使用通配符的函数
	public static void swap(Pair<?> p) {
		swapHelper(p);
	}
	```
	* 在这种情况下，`swapHelper`方法的参数`T`捕获通配符，他不知道是哪种类型的通配符，但是这是一个明确的类型，并且`<T>swapHelper`的定义只有在`T`指出类型时才有明确的含义

* 通配符捕获只有在有许多限制的情况下才是合法的。编译器必须能够确信通配符表达的是单个、确定的类型

	* 如：`ArrayList<Pair<T>>`中的`T`永远不能捕获`ArrayList<Pair<?>>`中的通配符。数组列表可以保存两个`Pair<?>`，分别针对`?`的不同类型

## 8.9 反射和泛型

* 反射允许在运行时分析任意的对象。如果对象是泛型类的实例，关于泛型类型参数则得不到太多信息，因为它们会被擦除

这一节后面没看

# 9. 集合

## 9.1 Java集合框架

### 9.1.1 将集合的接口与实现分离

* Java集合类库将接口与实现分离。当在程序中使用集合时，一旦构建了集合就不需要知道究竟使用了哪种实现。因此只有在构建集合对象时，使用具体的类才有意义

* 可以使用接口类型存放集合的引用

* 名字以`Abstract`开头的类，如`AbstractQueue`等。这些类是为类库实现者而设计的。如果想实现自己的队列类，扩展`AbstractQueue`类要比实现`Queue`接口中的所有方法轻松得多

### 9.1.2 `Collection`接口

* 在Java类库中，集合类的基本接口是`Collection`接口，这个接口有两个基本方法，如下代码所示↓：
	```Java
	public interface Collection<E> {
		boolean add(E element);
		Iterator<E> iterator();
		// ... 除了这两个方法之外，还有几个方法，将在稍后介绍
	}
	```
	* `add`：向集合中添加元素，返回该操作是否改变了集合
	* `iterator`：返回一个实现了`Iterator`接口的对象。可以用这个迭代器对象依次访问集合中的元素。详见[9.1.3 迭代器](#913-迭代器)

### 9.1.3 迭代器

* `Iterator`接口包含四个方法，代码如下所示↓：
	```Java
	public interface Iterator<E> {
		E next();
		boolean hasNext();
		void remove();
		default void forEachRemaining(Consumer<? super E> action);
	}
	```
	* `next`：通过反复调用`next`方法，可以逐个访问集合中的每个元素。但是如果到达了集合的末尾，`next`方法将抛出一个`NoSuchElementException`异常、
	* `hasNext`：如果迭代器对象还有多个供访问的元素，这个方法就返回`true`
	* `remove`：删除上次调用`next`方法时返回的元素
		* 如果想要删除指定位置上的元素，就需要越过这个元素
		* 对`next`方法和`remove`方法的调用具有相互依赖性。如果调用`remove`之前没有调用`next`将是不合法的。如果这样做，将会抛出一个`IllegalStateException`异常
		* 如果想删除两个相邻的元素，不能直接调用两次`remove`方法，而是应该调用一次`remove`方法后，先调用`next`方法越过将要删除的元素，再第二次调用`remove`方法

* for each循环
	* 编译器简单地将for each循环翻译为带有迭代器的循环
	* for each循环可以与任何实现了`Iterable`接口的对象一起工作，这个接口只包含一个抽象方法，代码如下所示↓：
	```Java
	public interface Iterable<E> {
		Iterator<E> iterator;
		// ...
	}
	```
	* `Collection`接口扩展了`Iterable`接口，因此对于标准类库中的任何集合都可以使用for each循环
	* 在Java SE 8中，甚至不用写循环，可以调用`forEachRemaining`方法并提供一个lambda表达式(以处理一个元素)。将对迭代器的每一个元素调用这个lambda表达式，直到再没有元素为止。语法为：`iterator.forEachRemaining(element -> 元素操作代码);`
	* 元素被访问的顺序取决于集合类型

* Java集合类库中的迭代器与其他类库中的迭代器在概念上有着重要的区别
	* C++的标准模版库，迭代器是根据数组索引建模的。如果给定这样一个迭代器，就可以查看指定位置上的元素，就像知道数组索引`i`就可以査看数组元素`a[i]`一样。不需要查找元素，就可以将迭代器向前移动一个位置。这与不需要执行査找操作就可以通过`i++`将数组索引向前移动一样
	* Java迭代器查找操作与位置变更是紧密相连的。查找一个元素的唯一方法是调用`next`，而在执行查找操作的同时，迭代器的位置随之向前移动。因此，应该将Java迭代器认为是位于两个元素之间。当调用`next`时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用
	* 可以将`Iterator.next`与`InputStream.read`看作为等效的。从数据流中读取一个字节，就会自动地"消耗掉"这个字节。下一次调用`read`将会消耗并返回输入的下一个字节。用同样的方式，反复地调用`next`就可以读取集合中所有元素

### 9.1.4 泛型实用方法

* `java.util.Collection<E>`方法如下所示↓：

|`java.util.Collection<E>`方法名|作用|
|:-:|:-:|
|`Iterator<E> iterator()`|返回一个用于访问结合中每个元素的迭代器|
|`int size()`|返回当前存储在结合中的元素个数|
|`boolean isEmpty()`|如果集合中没有元素，返回`true`|
|`boolean contains(Object obj)`|如果集合中包含了一个与`obj`相等的对象，返回`true`|
|`boolean containsAll(Collection<?> other)`|如果这个集合包含`other`集合中的所有元素，返回`true`|
|`boolean add(Object element)`|将一个元素添加到集合中。如果由于这个调用改变了集合，返回`true`|
|`boolean addAll(Collection<? extends E> other)`|将`other`集合中的所有元素添加到这个集合。如果由于这个调用改变了集合，返回`true`|
|`boolean remove(Object obj)`|从这个集合中删除等于`obj`的对象。如果有匹配的对象被删除，返回`true`|
|`boolean removeAll(Collection<?> other)`|从这个集合中删除`other`集合中存在的所有元素。如果由于这个调用改变了集合，返回`true`|
|`default boolean removeIf(Predicate<? super E> filter)`|从这个集合删除`filter`返回`true`的所有元素。如果由于这个调用改变了集合，返回`true`|
|`void clear()`|从这个集合中删除所有的元素|
|`boolean retainAll(Collection<?> other)`|从这个集合中删除所有与`other`集合中的元素不同的元素。如果由于这个调用改变了集合，返回`true`|
|`Object[] toArray()`|返回这个集合的对象数组|
|`<T> T[] toArray(T[] arrayToFill)`|返回这个集合的对象数组。如果`arrayToFill`足够大，就将集合中的元素填入这个数组中。剩余空间填补`null`；否则分配一个新数组，其成员类型与`arrayToFill`的成员类型相同，其长度等于集合的大小，并填充集合元素|

* `java.util.Iterator<E>`方法如下所示↓：

|`java.util.Iterator<E>`方法名|作用|
|:-:|:-:|
|`boolean hasNext()`|如果存在可访问的元素，返回`true`|
|`E next()`|返回将要访问的下一个对象。如果已经到达了集合的尾部，将抛出一个`NoSuchElementException`|
|`void remove()`|删除上次访问的对象。这个方法必须紧跟在访问一个元素之后执行。如果上次访问之后，集合已经发生了变化，这个方法将抛出一个`IllegalStateException`|

### 9.1.5 集合框架中的接口

* Iterable -> Collection ->
	* List：有序集合，可以用迭代器访问元素，也可以随机访问
	* Set：不允许增加重复的元素
		* SortedSet：提供用于排序的比较器对象，定义了可以得到集合子集视图的方法，有关内容见[9.4 视图与包装器](#94-视图与包装器)
			* NavigableSet：包含一些用于搜索和遍历有序集的方法
	* Queue -> Deque

* Map
	* SortedMap：提供用于排序的比较器对象，定义了可以得到集合子集视图的方法，有关内容见[9.4 视图与包装器](#94-视图与包装器)
		* NavigableMap：包含一些用于搜索和遍历有序映射的方法

* Iterator ->
	* ListIterator：定义了一个方法用于在迭代器位置前面增加一个元素

* RandomAccess：标记接口，不包含任何方法，可以通过`instanceof`来测试一个特定的集合是否支持高效的随机访问

## 9.2 具体的集合

* 本节介绍Java类库中的集合，为简单起见，省略了将在[14. 并发](#14-并发)中介绍的线程安全集合

* 实现了`Collection`接口的集合描述及继承关系如下所示↓：

|集合类型|描述|
|:-:|:-:|
|`ArrayList`|可以动态增长和缩减的索引序列|
|`LinkedList`|可以在任何位置进行高效地插入和删除操作的有序序列|
|`ArrayDeque`|用循环数组实现的双端队列|
|`HashSet`|没有重复元素的无序集合|
|`TreeSet`|有序集合|
|`EnumSet`|包含枚举类型值的集合|
|`LinkedHashSet`|可以记住元素插入次序的集合|
|`PriorityQueue`|允许高效删除最小元素的集合|

* Abstract Collection
	* AbstractList
		* AbstractSequentialList
			* LinkedList
		* ArrayList
	* AbstractSet
		* HashSet
			* LinkedHashSet
		* EnumSet
		* TreeSet
	* AbstractQueue
		* PriorityQueue
	* ArrayQueue

* 实现了`Map`接口的集合描述及继承关系如下所示↓：

|集合类型|描述|
|:-:|:-:|
|`HashMap`|存储键值对的数据结构|
|`TreeMap`|键有序排列的映射表|
|`EnumMap`|键属于枚举类型的映射表|
|`LinkedHashMap`|可以记住键值对添加次序的映射表|
|`WeakHashMap`|其值无用武之地后可以被垃圾回收器回收的映射表|
|`IdentityHashMap`|用`==`而不是用`equals`比较键的映射表|

* AbstractMap
	* HashMap
		* LinkedHashMap
	* TreeMap
	* EnumMap
	* WeakHashMap
	* IdentityHashMap

### 9.2.1 链表`LinkedList`

* 在Java中，所有链表实际上都是双向链表

* `java.util.List<E>`方法如下所示↓：

|`java.util.List<E>`方法名|作用|
|:-:|:-:|
|`ListIterator<E> listIterator()`|返回一个列表迭代器，以便用来访问列表中的元素|
|`ListIterator<E> listIterator(int index)`|返回一个列表迭代器，以便用来访问列表中的元素，即调用`next`与调用list.get(index)会产生同一个元素|
|`void add(int i, E element)`|在给定位置添加一个元素|
|`void addAll(int i, Collection<? extends E> elements)`|将某个集合中的所有元素添加到给定位置|
|`E remove(int i)`|删除给定位置的元素并返回这个元素|
|`E get(int i)`|获取给定位置的元素|
|`E set(int i, E element)`|用新元素取代给定位置的元素，并返回原来那个元素|
|`int indexOf(Object element)`|返回与指定元素相等的元素在列表中第一次出现的位置，如果没有这样的元素将返回`-1`|
|`int lastIndexOf(Object element)`|返回与指定元素相等的元素在列表中最后一次出现的位置，如果没有这样的元素将返回`-1`|

* `java.util.ListIterator<E>`方法如下所示↓：
	* `add`方法只依赖于迭代器的位置；而`remove`方法依赖于迭代器的状态，即`remove`前调用的是`next`还是`previous`，删除`next`或`previous`上次访问的元素
	* 如果迭代器发现它对应的集合被另一个迭代器修改了，或是被该集合自身的方法修改了，就会抛出一个`ConcurrentModificationException`异常

|`java.util.ListIterator<E>`方法名|作用|
|:-:|:-:|
|`void add(E newElement)`|在当前位置前添加一个元素。不返回`boolean`类型的值，假定添加操作总会改变链表|
|`void set(E newElement)`|用新元素取代`next`或`previous`上次访问的元素。如果在`next`或`previous`上次调用之后列表结构被修改了，将抛出一个`IllegalSateException`异常|
|`boolean hasPrevious()`|当反向迭代列表时，还有可供访问的元素，返回`true`|
|`E previous()`|返回越过的对象。如果已将到达了列表的头部，就抛出一个`NoSuchElementException`异常|
|`int nextIndex()`|返回下一次调用`next`方法时将返回的元素索引|
|`int previousIndex()`|返回下一次调用`previous`方法时将返回的元素索引|

* `java.util.LinkedList<E>`方法如下所示↓：

|`java.util.LinkedList<E>`方法名|作用|
|:-:|:-:|
|`LinkedList()`|构造一个空链表|
|`LInkedList(Collection<? extends E> elements)`|构造一个链表，并将集合中所有的元素添加到这个链表中|
|`void addFirst(E element)`、</br>`void addLast(E element)`|将某个元素添加到列表的头部或尾部|
|`E getFirst()`、</br>`E getLast()`|返回列表头部或尾部的元素|
|`E removeFirst()`、</br>`E removeLast()`|删除并返回列表头部或尾部的元素|

### 9.2.2 数组列表`ArrayList`

* `List`接口用于描述一个有序集合，并且集合中每个元素的位置十分重要
	* 有两种访问元素的协议；一种是用迭代器，另一种是用`get`和`set`方法随机访问。随机访问不适用于`LinkedList`，但适用于`ArrayList`

* `ArrayList`封装了一个动态再分配的对象数组

* `ArrayList`与`Vector`：
	* `Vector`类的所有方法都是同步的，可以由两个线程安全地访问一个`Vector`对象。但是如果由一个线程访问`Vector`，代码要在同步操作上耗费大量的时间
	* `ArrayList`方法不是同步的，因此在不需要同步时使用`ArrayList`，而不是`Vector`

### 9.2.3 散列集`HashSet`

* 散列表可以快速地查找所需要的对象
	* 散列表为每个对象计算一个散列码，具有不同数据成员的对象将产生不同的散列码。如果自定义类，就要负责实现这个类的`hashCode`方法。自己实现的`hashCode`方法应该与`equals`方法兼容，即如果`a.equals(b) == true`，则`a`与`b`必须具有相同的散列码
	* 在Java中，散列表用链表数组实现。每个列表被称为桶。要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引
	* 在Java SE 8中，桶满时会从链表变为平衡二叉树以提高性能
	* 桶数：如果想更多地控制散列表的运行性能，就要指定一个初始的桶数。桶数使之用于收集具有相同散列值的桶的数目。通常将桶数设置为预计元素个数的75%~150%。尽管还没有确凿的证据，但最好将桶数设置为一个素数，以防止键的集聚。标准类库中使用的桶数是2的幂，为散列表提供任何值都将被自动地转换为2的下一个幂
	* 如果散列表太满，就需要再散列。装填因子决定何时对散列表进行再散列。当表中超过装填因子的位置已经填入元素时，这个表就会用双倍的桶数自动地进行再散列。对于大多数应用程序来说，装填因子为0.75是比较合理的
	* 散列集迭代器将一次访问所有的桶，访问它们的顺序是随机的。只有不关心集合中元素的顺序时才应该使用`HashSet`
	* 在更改散列集中的元素时，如果元素的散列码发生了改变，元素在数据结构中的位置也会发生变化

* `java.util.HashSet<E>`方法如下所示↓：

|`java.util.HashSet<E>`方法名|作用|
|:-:|:-:|
|`HashSet()`|构造一个空散列表|
|`HashSet(Collection<? extends E> elements)`|构造一个散列表，并将集合中的所有元素添加到这个散列集中|
|`HashSet(int initialCapacity)`|构造一个空的具有指定容量(桶数)的散列集|
|`HashSet(int initialCapacity, float loadFactor)`|构造一个具有指定容量和装填因子(一个0.0~1.0之间的数值，确定散列表填充的百分比，当大于这个百分比时，散列表进行再散列)的空散列集|

### 9.2.4 树集`TreeSet`

* 树集是一个有序集合，可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现
	* 排序是使用红黑树实现的
	* 将一个元素添加到树中要比添加到散列表中慢，比检查数组或链表中的重复元素快
	* 要使用树集，必须能够比较元素。这些元素必须实现`Comparable`接口([6.1.1 接口概念](#611-接口概念))或构造集时必须提供一个`Comparator`([6.2.2 `Comparator`接口](#622-comparator接口)、[6.3.8 再谈`Comparator`](#638-再谈comparator))
	* 树的排序必须是全序，即任意两个元素必须是可比的，并且只有在两个元素相等时结果才为0
	* 从Java SE 6起，`TreeSet`类实现了`NavigableSet`接口。这个接口增加了几个便于定位元素以及反向遍历的方法

* `java.util.TreeSet<E>`方法如下所示↓：

|`java.util.TreeSet<E>`方法名|作用|
|:-:|:-:|
|`TreeSet()`</br>`TreeSet(Comparator<? super E> comparator)`|构造一个空树集|
|`TreeSet(Collection<? super extends E> elements)`</br>`TreeSet(SortedSet<E> s)`|构造一个树集，并添加一个集合或有序集中的所有元素(对于有序集，使用相同的顺序)|

* `java.util.SortedSet<E>`方法如下所示↓：

|`java.util.SortedSet<E>`方法名|作用|
|:-:|:-:|
|`Comparator<? super E> comparator()`|返回用于对元素进行排序的比较器。如果元素用`Comparable`接口的`compareTo`方法进行比较则返回`null`|
|`E first()`</br>`E last()`|返回有序集中的最小元素或最大元素|

* `java.util.NavigableSet<E>`方法如下所示↓：

|`java.util.NavigableSet<E>`方法名|作用|
|:-:|:-:|
|`E higher(E value)`</br>`E lower(E value)`|返回大于`value`的最小元素或小于`value`的最大元素，如果没有这样的元素则返回`null`|
|`E ceiling(E value)`</br>`E floor(E value)`|返回大于等于`value`的最小元素或小于等于`value`的最大元素，如果没有这样的元素则返回`null`|
|`E pollFirst()`</br>`E pollLast()`|删除并返回这个集中的最大元素或最小元素，这个集为空时返回`null`|
|`Iterator<E> descendingIterator()`|返回一个按照递减顺序遍历集中元素的迭代器|

### 9.2.5 队列`Queue`与双端队列`Deque`

* 队列可以让人们有效地在尾部添加一个元素，在头部删除一个元素。不支持在队列中间添加元素
	* 双端队列：有两个端头的队列。可以让人们有效地在头部和尾部同时添加或删除元素
	* 在Java SE 6中引入了`Deque`接口，并由`ArrayDeque`和`LinkedList`类实现。这两个类都提供了双端队列，并且在必要时可以增加队列的长度
	* [14. 并发](#14-并发)将会介绍优先队列和有限双端队列

* `java.util.Queue<E>`方法如下所示↓：

|`java.util.Queue<E>`方法名|作用|
|:-:|:-:|
|`bool add(E element)`</br>`boolean offer(E element)`|如果队列没有满，将指定的元素添加到这个双端队列的尾部并返回`true`。如果队列满了，`add`将抛出一个`IllegalStateException`，`offer`将返回`false`|
|`E remove()`</br>`E poll()`|如果队列不空，删除并返回这个队列头部的元素。如果队列是空的，`remove`将抛出`NoSuchElementException`，`poll`返回`null`|
|`E element()`</br>`E peek()`|如果队列不空，返回这个队列头部的元素，但不删除。如果队列是空的，`element`将抛出`NoSuchElementException`，`peek`返回`null`|

* `java.util.Deque<E>`方法如下所示↓：

|`java.util.Deque<E>`方法名|作用|
|:-:|:-:|
|`void addFirst(E element)`</br>`void addLast(E element)`</br>`boolean offerFirst(E element)`</br>`boolean offerLast(E element)`|将给定对象添加到双端队列的头部或尾部。如果队列满了，`add...`将抛出一个`IllegalStateException`，`offer...`将返回`false`|
|`E removeFirst()`</br>`E removeLast`</br>`E peekFirst()`</br>`E peekLast()`|如果队列非空，返回队列头部的元素，但不删除。如果队列空了，`remove...`将抛出一个`NoSuchElementException`，而`peek...`将返回`null`|

* `java.util.ArrayDeque<E>`方法如下所示↓：

|`java.util.ArrayDeque<E>`方法名|作用|
|:-:|:-:|
|`ArrayDeque()`</br>`ArrayDeque(int initialCapacity)`|用初始容量16或给定的初始容量构造一个无限双端队列|

### 9.2.6 优先级队列`PriorityQueue`

* 优先级队列使用堆实现，对数执行`add`和`remove`操作，可以让最小的元素移动到根
	* 元素可以按照任意的顺序插入，却总是按照排序的顺序进行检索。无论何时调用`remove`方法，总会获得当前优先级队列中最小的元素
	* 与`TreeSet`一样，一个优先级队列即可以保存实现了Comparable接口的类对象，也可以保存在构造器中提供的`Comparator`对象

* `java.util.PriorityQueue<E>`方法如下所示↓：

|`java.util.PriorityQueue<E>`方法名|作用|
|:-:|:-:|
|`PriorityQueue()`</br>`PriorityQueue(int initialCapacity)`|构造一个用于存放`Comparable`对象的优先级队列|
|`PriorityQueue(int initialCapacity, Comparator<? super E> c)`|构造一个优先级队列，并用指定的比较器对元素进行排序|

## 9.3 映射`Map`

### 9.3.1 基本映射操作

* Java类库为映射提供了两个通用的实现：`HashMap`和`TreeMap`。这两个类都实现了`Map`接口
	* `HashMap`：对键进行散列，速度稍微快一些
	* `TreeMap`：用键的整体顺序对元素进行排序，速度稍微慢一些

* `java.util.Map<K, V>`方法如下所示↓：

|`java.util.Map<K, V>`方法名|作用|
|:-:|:-:|
|`V get(Object key)`|获取与键对应的值；返回与键对应的对象，如果在映射中没有这个对象则返回`null`，键可以为`null`|
|`default V getOrDefault(Object key, V defaultValue)`|获得与键关联的值；返回与键关联的对象，或者如果未在映射中找到这个键，则返回`defaultValue`|
|`V put(K key, V value)`|将键值对插入到映射中。如果这个键已经存在，新的对象将取代与这个键对应的旧对象。这个方法将返回键对应的旧值。如果这个键以前没有出现过则返回`null`。键可以为`null`，但值不能为`null`|
|`void putAll(Map<? extend K, ? extend V> entries)`|将给定映射中的所有条目添加到这个映射中|
|`boolean containsKey(Object Key)`|如果在映射中已经有这个值，返回`true`|
|`boolean containsValue(Object value)`|如果映射中已经有这个值，返回`true`|
|`default void forEach(BiConsumer<? super K, ? super V> action)`|对这个映射中的所有键值对应用这个动作(多为lambda函数)|

* `java.util.HashMap<K, V>`方法如下所示↓：

|`java.util.HashMap<K, V>`方法名|作用|
|:-:|:-:|
|`HashMap()`</br>`HashMap(int initialCapacity)`</br>`HashMap(int initialCapacity, float loadFactor)`|用给定的容量和装填因子构造一个空散列映射(装填因子是一个0.0~1.0之间的数值。这个数值决定散列表填充的百分比。一旦到了这个比例，就要将其再散列到更大的表中)。默认的装填因子是0.75|

* `java.util.TreeMap<K, V>`方法如下所示↓：

|`java.util.TreeMap<K, V>`方法名|作用|
|:-:|:-:|
|`TreeMap()`|为实现`Comparable`接口的键构造一个空的树映射|
|`TreeMap(Comparator<? super K> c)`|构造一个树映射，并使用一个指定的比较器对键进行排序|
|`TreeMap(Map<? extends K, ? extends V> entries)`|构造一个树映射，并将某个映射中的所有条目添加到树映射中|
|`TreeMap(SortedMap<? extends K, ? extends V> entries)`|构造一个树映射，将某个有序映射中的所有条目添加到树映射中，并使用与给定的有序映射相同的比较器|

* `java.util.SortedMap<K, V>`方法如下所示↓：

|`java.util.SortedMap<K, V>`方法名|作用|
|:-:|:-:|
|`Comparator<? super K> comparator()`|返回对键进行排序的比较器。如果键是用`Comparable`接口的`compareTo`方法进行比较的，返回`null`|
|`K firstKey()`</br>`K lastKey()`|返回映射中最小元素和最大元素|

### 9.3.2 更新映射项

* `java.util.Map<K, V>`方法如下所示↓：

|`java.util.Map<K, V>`方法名|作用|
|:-:|:-:|
|`default V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction)`|如果`key`与一个非`null`值关联，将函数应用到`v`和`value`，将`key`与结果关联，或者如果结果为`null`，则删除这个键。否则，将`key`与`value`关联，返回`get(key)`|
|`default V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)`|将函数应用到`key`和`get(key)`。将`key`与结果关联，或者如果结果为`null`，则删除这个键。返回`get(key)`|
|`default V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)`|如果`key`与一个非`null`值`v`关联，将函数应用到`key`和`v`，将`key`与结果关联，或者如果结果为`null`，则删除这个键。返回`get(key)`|
|`default V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction)`|如果`key`与一个`null`值关联，则将函数应用到`key`。将`key`与结果关联，或者如果结果为`null`，则删除这个键。返回`get(key)`|
|`default void replaceAll(BiFunction<? super K, ? super V, ? extends V> function)`|在所有映射项上应用函数。将`key`与非`null`结果关联，对于`null`结果，则将相应的`key`删除|

### 9.3.3 映射视图`Map.Entry`

* 映射的视图：实现了`Collection`接口或某个子接口的对象
	* 有三种视图：键集、值集合(不是一个集)、键值对集
	* 键和键值对可以构成一个集，因为映射中一个键只能有一个副本
	* 键集`keySet`不是`HashSet`或`TreeSet`，而是实现了`Set`接口的另外某个类的对象。`Set`接口扩展了`Collection`接口

* `java.util.Map<K, V>`方法如下所示↓：

|`java.util.Map<K, V>`方法名|作用|
|:-:|:-:|
|`Set<Map.Entry<K, V>> entrySet()`|返回`Map.Entry`对象(映射中的键值对)的一个集视图。可以从这个集中删除元素，它们将从映射中删除，但是不能增加任何元素|
|`Set<K> keySet()`|返回映射中所有键的一个集视图。可以从这个集中删除元素，键和相关联的值将从映射中删除，但是不能增加任何元素|
|`Collection<V> values()`|返回映射中所有值的一个集合视图。可以从这个集合中删除元素，所删除的值及相应的键将从映射中删除，不过不能增加任何元素|

* `java.util.Map.Entry<K, V>`方法如下所示↓：

|`java.util.Map.Entry<K, V>`方法名|作用|
|:-:|:-:|
|`K getKey()`</br>`V getValue()`|返回这一条目的键或值|
|`V setValue(V newValue)`|将相关映射中的所有值改为新值，并返回原来的值|

### 9.3.4 弱散列映射`WeakHashMap`

* 垃圾回收器跟踪活动的对象，只要映射对象是活动的，其中的所有桶也是活动的，他们不能被回收，因此需要由程序负责从长期存活的映射表中删除那些无用的值，或者使用`WeakHashMap`完成这件事

* 当对键的唯一引用来自`WeakHashMap`散列条目时，这一数据结构将与垃圾回收器协同工作一起删除键值对

* `WeakHashMap`内部运行情况：`WeakHashMap`使用弱引用保存键。`WeakReference`对象将引用保存到另外一个对象中，在这里，就是散列键。对于这种类型的对象，垃圾回收器用一种特有的方式进行处理。通常，如果垃圾回收器发现某个特定的对象已经没有他人引用了，就将其回收。然而，如果某个对象只能由`WeakReference`引用，垃圾回收器仍然回收它，但要将引用这个对象的弱引用放入队列中。`WeakHashMap`将周期性地检查队列，以便找出新添加的弱引用。一个弱引用进入队列意味着这个键不再被他人使用，并且已经被收集起来。于是，`WeakHashMap`将删除对应的条目

### 9.3.5 链接散列集`LinkedHashSet`与映射`LinkedHashMap`

* `LinkedHashSet`和`LinkedHashMap`类用来记住插入元素项的顺序。这样就可以避免在散列表中的项从表面上看是随机排列的。当条目插入到表中时，就会并入到双向链表中

* `LinkedHashMap`将用访问顺序，而不是插入顺序对映射条目进行迭代
	* 每次调用`get`或`put`，受到影响的条目将从当前的位置删除，并放到条目链表的尾部
	* 只有条目在链表中的位置会受到影响，而散列表中的桶不会受影响。一个条目总位于与键散列值对应的桶中

* `java.util.LinkedHashMap<K, V>`中的`protected boolean removeEldestEntry(Map.Entry<K, V> eldest)`方法：如果想删除`eldest`元素，并同时返回`true`，就应该覆盖这个方法。`eldest`参数是预期要删除的条目。这个方法将在条目添加到映射中之后调用。其默认的实现将返回`false`。即在默认情况下，旧元素没有被删除。然而，可以重新定义这个方法，以便有选择地返回`true`。例如，如果最旧的条目符合一个条件，或者映射超过了一定大小，则返回`true`

### 9.3.6 枚举集`EnumSet`与映射`EnumMap`

* `EnumSet`是一个枚举类型元素集的高效实现
	* 由于枚举类型只有有限个实例，所以`EnumSet`内部用位序列实现。如果对应的值在集中，则相应的位被置为1
	* `EnumSet`类没有公共的构造器，可以使用静态工厂方法构造这个集
	* 可以使用`Set`接口的常用方法来修改`EnumSet`
	* 类型参数`E extends Enum<E>`表示`E`是一个枚举类型。所有的枚举类型都扩展于泛型`Enum`类

* `EnumMap`是一个键类型为枚举类型的映射，它可以直接且高效地用一个值数组实现
	* 在使用时，需要在构造器中指定键类型

* `java.util.EnumSet<E extends Enum<E>>`方法如下所示↓：

|`java.util.EnumSet<E extends Enum<E>>`方法名|作用|
|:-:|:-:|
|`static <E extends Enum<E>> EnumSet<E> allOf(Class<E> enumType)`|返回一个包含给定枚举类型的所有值的集|
|`static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> enumType)`|返回一个空集，并有足够的空间保存给定的枚举类型所有的值|
|`static <E extends Enum<E>> EnumSet<E> range(E from, E to)`|返回一个包含`from`~`to`之间的所有值(包括两个边界元素)的集|
|`static <E extends Enum<E>> EnumSet<E> of(E value)`</br>`static <E extends Enum<E>> EnumSet<E> of(E value, E... values)`|返回包括给定值的集|

* `java.util.EnumMap<K extends Enum<K>, V>`中的`EnumMap(Class<K> keyType)`方法：构造一个键位给定类型的空映射

### 9.3.7 标识散列映射`IdentityHashMap`

* `IdentityHashMap`类中，键的散列值不是用`hashCode`函数计算的，而是用`System.identityHashCode`方法计算
	* `System.identityHashCode`方法根据对象的内存地址来计算散列码
	* 在对两个对象进行比较时，`IdentityHashMap`类使用`==`而不是`equals`
	* 不同的键对象，即使内容相同，也被视为是不同的对象
	* 在实现对象遍历算法(如对象串行化)时，这个类非常有用，可以用来跟踪每个对象的遍历状况

* `java.util.IdentityHashMap<K, V>`中的`IdentityHashMap()`与`IdentityHashMap(int expectedMaxSize)`方法：构造一个空的标识散列映射集，其容量是大于`1.5 * expectedMaxSize`的2的最小次幂(`expectedMaxSize`的默认值是21)

* `java.lang.System`中的`static int identityHashCode(Object obj)`方法：返回`Object.hashCode`计算出来的相同散列码(根据对象的内存地址产生)，即使`obj`所属的类已经重新定义了`hashCode`方法也是如此

## 9.4 视图与包装器

* 视图：通过使用视图可以获得其他的实现了`Collection`接口和`Map`接口的对象
	* 如：映射类的`keySet`方法([9.3.3 映射视图`Map.Entry`](#933-映射视图mapentry))返回一个实现`Set`接口的类对象，这个类的方法对原映射进行操作。而不是创建一个新集，将映射中的所有键都填进去，然后返回这个集

### 9.4.1 轻量级集合包装器

* `Arrays.asList()`：
	* 该静态方法将返回一个包装了普通Java数组的List包装器，可以将数组传递给一个期望得到列表或集合参数的方法
	* 如：`Card[] cardDeck = new Card[52]; List<Card> cardList = Arrays.asList(cardDeck);`
	* 返回的对象不是`ArrayList`，它是一个视图对象，带有访问底层数组的`get`和`set`方法。改变数组大小的所有方法(如与迭代器相关的`add`和`remove`方法)都会抛出一个`UnsupportedOperationException`异常
	* 该方法可以接收可变数目的参数，如：`List<String> names = Arrays.asList("a", "b", "c");`

* `Collections.nCopies(n, anObject)`：
	* 该方法调用将返回一个实现了`List`接口的不可修改的对象，并给人一种包含`n`个元素，每个元素都像是`anObject`的错觉
	* 存储代价很小

* `Collections.singleton(anObject)`：
	* 该方法将返回一个视图对象，该对象实现了`Set`接口(与上述`nCopies`方法不同)。返回的对象实现了一个不可修改的单元素集，而不需要付出建立数据结构的开销
	* `singletonList`方法与`singletonMap`方法类似

* 类似地，对于集合框架中的每一个接口，还有一些方法可以生成空集、列表、映射等。特别是集的类型可以推导得出：`Set<String> deepThoughts = Collections.emptySet();`

### 9.4.2 子范围`subXXX`

* 可以为很多集合建立子范围视图
	* 如：`List group2 = staff.subList(10, 20);`
	* 第一个索引包含在内，第二个索引则不包含在内
	* 可以将任何操作应用于子范围，并且能够自动地反映整个列表的情况

* 对于有序集和映射，可以使用排序顺序而不是元素位置建立子范围：
	* `SortedSet`接口声明了三个方法：`SortedSet<E> subSet(E from, E to)`、`SortedSet<E> headSet(E to)`与`SortedSet<E> tailSet(E from)`，这些方法将返回大于等于`from`且小于`to`的所有元素子集
	* `SortedMap`接口声明了类似的方法：`SortedMap<K, V> subMap(K from, K to)`、`SortedMap<K, V> headMap(K to)`与`SortedMap<K, V> tailMap(K from)`，这些方法返回映射视图，该映射包含键落在指定范围内的所有元素

* Java SE 6引入的`NavigableSet`接口赋予子范围操作更多的控制能力，可以指定是否包括边界：`NavigableSet<E> subSet(E from, boolean fromInclusive, E to, boolean toInclusive)`、`NavigableSet<E> headSet(E to, boolean toInclusive)`与`NavigableSet<E> tailSet(E from, boolean fromInclusive)`

### 9.4.3 不可修改的视图`unmodifiableXXX`

* `Collections`可以产生集合的不可修改视图。这些视图对现有集合增加了一个运行时的检查。如果发现试图对集合进行修改，就会抛出一个异常，同时这个集合将保持未修改的状态
	* 方法为：`Collections.unmodifiableXXX`，其中`XXX`可以为：`Collection`、`List`、`List`、`Set`、`SortedSet`、`NavigableSet`、`Map`、`SortedMap`或`NavigableMap`
	* 每个方法都定义于一个接口，如`Collections.unmodifiableList`与`ArrayList`、`LinkedList`或任何实现了`List`接口的其他类一起协同工作
	* `Collections.unmodifiableList`方法将返回一个实现`List`接口的类对象，可以调用`List`接口中的所有方法，但是所有的更改器方法(如`add`等)已经被重新定义为抛出一个`UnsupportedOperationException`异常，而不是将调用传递给底层集合

* 不可修改视图并不是集合本身不可修改。仍然可以通过集合的原始引用对集合进行修改。并且仍然可以让集合的元素调用更改器方法

* 由于视图只是包装了接口而不是实际的集合对象，所以只能访问接口中定义的方法
	* 如`LinkedList`类中的`addFirst`和`addLast`方法，它们都不是`List`接口的方法，不能通过不可修改视图进行访问

* `unmodifiableCollection`方法(与本节稍后讨论的`synchronizedCollection`([9.4.4 同步视图`synchronizedXXX`](#944-同步视图synchronizedxxx))和`checkedCollection`([9.4.5 受查视图`checkedXXX`](#945-受查视图checkedxxx))方法一样）将返回一个集合，它的`equals`方法不调用底层集合的`equals`方法。相反，它继承了`Object`类的`equals`方法，这个方法只是检测两个对象是否是同一个对象。如果将集或列表转换成集合，就再也无法检测其内容是否相同了。视图就是以这种方式运行的，因为内容是否相等的检测在分层结构的这一层上没有定义妥当。视图将以同样的方式处理`hashCode`方法
	* 然而，`unmodifiableSet`类和`unmodifiableList`类却使用底层集合的`equals`方法和
`hashCode`方法

### 9.4.4 同步视图`synchronizedXXX`

* 如果由多个线程访问集合，就必须确保集不会被意外地破坏。类库使用视图机制来确保常规集合的线程安全，而不是实现线程安全的集合类
	* 如：`Collection`类的静态`synchronizedMap`方法可以向任何一个映射表转换成具有同步访问方法的`Map`：`Map<String, Employee> map = Collections.synchronizedMap`。此时就可以由多线程访问`map`对象，如`get`和`put`这类方法都是同步操作

[14. 并发](#14-并发)将详细地讨论数据结构的同步访问

### 9.4.5 受查视图`checkedXXX`

* 受查视图用来对泛型类型发生问题时提供调试支持
	* 下述代码定义了一个安全列表：`List<String> safeString = Collections.checkedList(strings, String.class);`。视图的`add`方法将检测插入的对象是否属于给定的类。如果不属于给定的类，就立即抛出一个`ClassCastException`。这样做的好处是错误可以在正确的位置得以报告

* 受查视图受限于虚拟机可以运行的运行时检查。如对于`ArrayList<Pair<String>>`，由于虚拟机有一个单独的"原始"`Pair`类，所以无法阻止插入`Pair<Date>`

### 9.4.6 关于可选操作的说明

* 通常视图有一些局限性，即可能只可以读、无法改变大小、只支持删除而不支持插入，这些与映射的键视图情况相同。如果试图进行不恰当的操作，受限制的视图就会抛出一个`UnsupportedOperationException`

* 在集合和迭代器接口的API文档中，许多方法描述为"可选操作"。这看起来与接口的概念有所抵触。毕竟，接口的设计目的是负责给出一个类必须实现的方法。从理论的角度看，在这里给出的方法很难令人满意。一个更好的解决方案是为每个只读视图和不能改变集合大小的视图建立各自独立的两个接口。不过这将会使接口的数量成倍增长

## 9.5 算法

### 9.5.1 排序与混排

* 对于不支持随机访问的列表，`sort`方法所采用的排序手段为直接将所有元素转入一个数组，对数组进行排序，然后再将排序后的序列复制回列表

* 对于排序算法，列表必须是可修改的，但不必是可改变大小的
	* 可修改的：列表支持`set`方法
	* 可改变大小的：列表支持`add`和`remove`方法

* `java.util.Collections`方法如下所示↓：

|`java.util.Collections`方法名|作用|
|:-:|:-:|
|`static <T extends Comparable<? super T>> void sort(List<T> elements)`|使用稳定的排序算法，对列表中的元素进行排序，时间复杂度为`O(n logn)`|
|`Static void shuffle(List<?> elements)`</br>`static void shuffle(List<?> elements, Random r)`|随机地打乱列表中的元素。时间复杂度为`O(n a(n))`，`a(n)`是访问元素的平均时间|

* `java.util.List<E>`中的`default void sort(Comparator<? super T> comparator)`方法：使用给定比较器对列表排序

* `java.util.Comparator<T>`方法如下所示↓：

|`java.util.Comparator<T>`方法名|作用|
|:-:|:-:|
|`static <T extends Comparable<? super T>> Comparator<T> reverseOrder()`|生成一个比较器，将逆置`Comparable`接口提供的顺序|
|`default Comparator<T> reversed()`|生成一个比较器，将逆置这个比较器提供的顺序|

### 9.5.2 二分查找

* `java.util.Collections`中的二分查找算法
	* `static <T extends Comparable<? super T>> int binarySearch(List<T> elements, T key)`
	* `static <T> int binarySearch(List<T> elements, T key, Comparator<? super T> c)`
	* 从有序列表中搜索一个键，如果元素扩展了`AbstractSequentialList`类(即链表)，则采用线性查找，否则将采用二分查找。该方法时间复杂度为`O(a(n) logn)`，`a(n)`是访问一个元素的平均时间。这个方法将返回这个键在列表中的索引，如果在列表中不存在这个键将返回负值`i`，在这种情况下，应该将这个键插入到列表索引`-i-1`的位置上，以保持列表的有序性

### 9.5.3 简单算法

* `java.util.Collections`方法如下所示↓：

|`java.util.Collections`方法名|作用|
|:-:|:-:|
|`static <T extends Comparable<? super T>> T min(Collection<T> elements)`</br>`static <T extends Comparable<? super T>> T max(Collection<T> elements)`</br>`static <T> min(Collection<T> elements, Comparator<? super T> c)`</br>`static <T> max(Collection<T> elements, Comparator<? super T> c)`|返回集合中最小的或最大的元素(为清楚起见，参数的边界被简化了)|
|`static <T> void copy(List<? super T> to, List<T> from)`|将原列表中的所有元素复制到目标列表的相应位置上。目标列表的长度至少与原列表一样|
|`static <T> void fill(List<? super T> l, T value)`|将列表中所有位置设置为相同的值|
|`static <T> boolean addAll(Collection<? super T> c, T... values)`|将所有的值添加到集合中。如果集合改变了，则返回`true`|
|`static <T> boolean replaceAll(List<T> l, T oldValue, T newValue)`|用`newValue`取代所有值为`oldValue`的元素|
|`static int indexOfSubList(List<?> l, List<?> s)`</br>`static int lastIndexOfSubList(List<?> l, List<?> s)`|返回`l`中第一个或最后一个等于`s`子列表的索引。如果`l`中不存在等于`s`的子列表，则返回`-1`|
|`static void swap(List<?> l, int i, int j)`|交换给定偏移量的两个元素|
|`static void reverse(List<?> l)`|逆置列表中元素的顺序。时间复杂度为`O(n)`|
|`static void rotate(List<?> l, int d)`|旋转列表中的元素，将索引`i`的条目移动到位置`(i+d)%l.size()`。时间复杂度为O(n)|
|`static int frequency(Collection<?> c, Object o)`|返回`c`中与对象`o`相同的元素个数|
|`boolean disjoint(Collection<?> c1, Collection<?> c2)`|如果两个集合没有共同的元素，则返回`true`|

* `java.util.Collection<T>`中的`default boolean removeIf(Predicate<? super E> filter)`方法：删除所有匹配的元素

* `java.util.List<E>`中的`default void replaceAll(UnaryOperator<E> op)`方法：对这个列表的所有元素应用这个操作

### 9.5.4 批操作

* 许多操作会"成批"复制或删除元素，可以对视图应用批操作，也可以通过使用一个子范围视图，把批操作限制在子列表和子集上

### 9.5.5 集合与数组的转换

* 由于Java平台API的大部分内容都是在集合框架创建之前设计的，所以有时候需要在数组和集合之间进行转换
	* `Arrays.asList`可以把一个数组转换为集合.如：`String[] values = ...; HashSet<String> staff = new HashSet<>(Arrays.asList(values));`
	* 可以使用`toArray`方法从集合得到数组，但这样做的结果是得到一个`Object[]`，不能改变它的类型。尽管确定集合中包含一个特定类型的对象，但也不能使用强制类型转换。如：`Object[] values = staff.toArray();`
	* 必须使用`toArray`方法的一个变体形式，提供一个所需类型且长度为0的数组，以使得返回的数组创建为相同的数组类型。如：`String[] values = staff.toArray(new String[0]);`
	* 也可以构造一个指定大小的数组。如：`staff.toArray(new String(staff.size());`。在这种情况下，不会创建新数组

### 9.5.6 编写自己的算法

* 编写以集合作为参数的任何方法，应该尽可能地使用接口，而不是使用具体的实现
	* 如：`void fullMenu(JMenu menu, Collection<JMenuItem> items)`比`void fillMenu(JMenu, ArrayList<JMenuItem> items)`好

## 9.6 遗留的集合

### 9.6.1 `Hashtable`类

* `Hashtable`类与`HashMap`类的作用一样，拥有相同的接口
	* 与`Vector`类的方法一样，`Hashtable`的方法也是同步的
	* 如果对同步性或与遗留代码的兼容性没有任何要求，就应该使用`HashMap`；如果需要并发访问，则要使用`ConcurrentHashMap`，参见[14. 并发](#14-并发)

### 9.6.2 枚举`Enumeration<E>`

* 遗留集合使用`Enumeration`接口对元素序列进行遍历

* 在C++中，用迭代器作为参数十分普遍。在Java的编程平台中，只有极少的程序员沿用这种习惯。传递集合要比传递迭代器更为明智。集合对象的用途更大。当接受方如果需要时，总是可以从集合中获得迭代器，而且，还可以随时地使用集合的所有方法

* `java.util.Enumeration<E>`方法如下所示↓：

|`java.util.Enumeration<E>`方法名|作用|
|:-:|:-:|
|`boolean hasMoreElements()`|如果还有更多的元素可以查看，返回`true`|
|`E nextElement()`|返回被检测的下一个元素，需要先使用`hasMoreElements()`检查|

### 9.6.3 属性映射`Properties`

* 属性映射`Properties`是一个类型非常特殊的映射结构，有如下三个特性：
	* 键与值都是字符串
	* 表可以保存到一个文件中，也可以从文件中加载
	* 使用一个默认的辅助表

* 属性映射通常用于程序的特殊配置选项，参见[13. 部署Java程序](#13-部署java程序)

* `java.util.Properties`方法如下所示↓：

|`java.util.Properties`方法名|作用|
|:-:|:-:|
|`Properties()`|创建一个空的属性映射|
|`Properties(Properties defaults)`|创建一个带有一组默认值的空的属性映射|
|`String getProperty(String key)`|获得属性的对应关系；返回与键对应的字符串。如果在映射中不存在，返回默认表中与这个键对应的字符串|
|`String getProperty(String key, String defaultValue)`|获得在键没有找到时具有的默认值属性；它将返回与键对应的字符串，如果在映射中不存在，就返回默认的字符串|
|`void load(InputStream in)`|从`InputStream`加载属性映射|
|`void store(OutputStream out, String commentString)`|把属性映射存储到`OutputStream`|

### 9.6.4 栈`Stack<E>`

* `java.util.Stack<E>`方法如下所示↓：

|`java.util.Stack<E>`方法名|作用|
|:-:|:-:|
|`E push(E item)`|将`item`压入栈并返回`item`|
|`E pop()`|弹出并返回栈顶的`item`。如果栈为空则不要调用该方法|
|`E peek()`|返回栈顶元素。如果栈为空则不要调用该方法|

### 9.6.5 位集`BitSet`

* `BitSet`用于存放一个序列，如果需要高效地存储位序列就可以使用`BitSet`
	* 由于`BitSet`将位包装在字节里，所以使用`BitSet`要比使用`Boolean`对象的`ArrayList`更加高效

* C++中的`bitset`模板与Java平台的`BitSet`功能一样

* `java.util.BitSet`方法如下所示↓：

|`java.util.BitSet`方法名|作用|
|:-:|:-:|
|`BitSet(int initialCapacity)`|创建一个位集|
|`int length()`|返回位集的逻辑长度，即`1`加上位集的最高设置位的索引|
|`boolean get(int bit)`|获得一个位|
|`void set(int bit)`|设置一个位|
|`void clear(int bit)`|清除一个位|
|`void and(BitSet set)`|这个位集与另一个位集进行逻辑"AND"|
|`void or(BitSet set)`|这个位集与另一个位集进行逻辑"OR"|
|`void xor(BitSet set)`|这个位集与另一个位集进行逻辑"XOR"|
|`void andNot(BitSet set)`|这个位集与另一个位集进行与非操作，即清除这个位集中对应另一个位集中设置的所有位|

# 10. 图形程序设计

# 11. 事件处理

# 12. Swing用户界面组件

# 13. 部署Java程序

# 14. 并发

* 多进程与多线程
	* 本质的区别在于每个进程拥有自己的一整套变量，而线程则共享数据

||进程|线程|协程|
|:-:|:-:|:-:|:-:|
|定义|资源分配和拥有的基本单位|程序执行的基本单位|用户态的轻量级线程，线程内部调度的基本单位|
|切换情况|进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置|保存和设置程序计数器、少量寄存器和栈的内容|先将寄存器上下文和栈保存，等切换回来的时候再进行恢复|
|切换者|操作系统|操作系统|用户|
|切换过程|用户态->内核态->用户态|用户态->内核态->用户态|用户态(没有陷入内核)|
|调用栈|内核栈|内核栈|用户栈|
|拥有资源|CPU资源、内存资源、文件资源和句柄等|程序计数器、寄存器、栈、状态字|拥有自己的寄存器上下文和栈|
|并发性|不同进程之间切换实现并发，各自占有CPU实现并行|一个进程内部的多个线程并发执行|同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理|
|系统开销|切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大|切换时只需保存和设置少量寄存器内容，因此开销很小|直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快|
|通信方面|进程间通信需要借助操作系统|线程间可以直接读写进程数据段(如全局变量)来进行通信|共享内存、消息队列|
|使用场景|多机分布、任务间相关性比较弱|频繁创建和销毁、计算量大、任务间相关性比较强、多核分布||

## 14.1 什么是线程

* 在一个单独的线程中执行一个任务的简单过程：
	1. 将任务代码移到实现了`Runnable`接口的类的`run`方法中。`Runnable`接口代码如下所示↓：
	```Java
	public interface Runnable {
		void run();
	}
	```
	由于`Runnable`是一个函数式接口，因此可以用`lambda`表达式建立一个实例，语法为：`Runnable r = () -> {code...}`
	2. 由`Runnable`创建一个`Thread`对象，语法为：`Thread t = new Thread(r);`
	3. 启动线程：`t.start();`

* 不要直接调用`Thread`类或`Runnable`对象的`run`方法。直接调用`run`方法，只会执行同一个线程中的任务，而不会启动新线程。应该调用`Thread.strar`方法，该方法将创建一个执行`run`方法的新线程

* `java.lang.Thread`方法如下所示↓：

|`java.lang.Thread`方法名|作用|
|:-:|:-:|
|`Thread(Runnable target)`|构造一个新线程，用于调用给定目标的`run()`方法|
|`void start()`|启动这个线程，将引发调用`run()`方法。这个方法将立即返回，并且新线程将并发运行|
|`void run()`|调用关联`Runnable`的`run`方法|

* `java.lang.Runnable`中的`void run()`方法：必须覆盖这个方法啊，并在这个方法中提供所要执行的任务指令

## 14.2 中断线程

* 线程终止的情况：
	1. 线程的`run`方法执行方法体中最后一条语句后，并经由执行`return`语句返回时
	2. 出现了在方法中没有捕获的异常时

* 没有可以强制线程终止的方法，然而`interrupt`方法可以用来请求中断线程
	* 中断状态：每一个线程都具有的`boolean`标志。对一个线程调用`interrupt`方法时，线程的中断状态将会被置位。每个线程都应该不时地检查这个标志，以判断线程是否被中断
	* 通过`Thread.currentThread().isInterrupted()`检查中断状态是否被置位：首先调用静态的`Thread.currentThread`方法获得当前线程，然后调用`isInterrupted`方法
	* 如果线程被阻塞，就无法检测中断状态，这是产生`InterruptedException`异常的地方。当在一个被阻塞的线程(调用`sleep`或`wait`)上调用`interrupt`方法时，阻塞调用将会被`InterruptedException`异常中断

* 线程可以将中断作为一个终止的请求，这种线程的`run`方法如下所示↓：
	```Java
	Runnable r = () -> {
		try {
			// ...
			while (!Thread.currentThread().isInterrupted() && ...)
				// ...
		} catch (InterruptedException e) {
			// ...
		} finally {
			// ...
		}
	};
	```

* 如果在迭代中调用`sleep`方法或其他的可中断方法，`isInterrupted`检测既没有必要也没有用处
	* 如果在中断状态被置位时调用`sleep`方法，线程不会休眠，相反线程将清除这一状态并抛出`InterruptedException`
	* 因此如果循环中调用`sleep`，不会检测中断状态，相反要如下代码所述捕获`InterruptedException`异常↓：
	```Java
	Runnanle r = () -> {
		try {
			// ...
			while (...) {
				// ...
				Thread.sleep(delay);
			} catch (InterruptedException e) {
				// ...
			} finally {
				// ...
			}
			// ...
		}
	};
	```

* 如果不确定在`catch`子句中进行什么处理，可以采用如下方式：
	1. 在`catch`子句中调用`Thread.currentThread().interrupt()`来设置中断状态，这样调用者可以对其进行检测。代码如下所示↓：
	```Java
	void mySubTask() {
		// ...
		try {
			sleep(delay);
		} catch (InterruptedException e) {
			Thread.currentThread().interrupt();
		}
		// ...
	}
	```

	2. 更好的选择是用`throw InterruptedException`标记方法，不采用`try`语句块捕获异常。这样调用者或最终的`run`方法可以捕获这一异常。代码如下所示↓：
	```Java
	void mySubTask() throws InterruptedException {
		// ...
		sleep(delay);
		// ...
	}
	```

* `java.lang.Thread`方法如下所示↓：

|`java.lang.Thread`方法名|作用|
|:-:|:-:|
|`void interrupt()`|向线程发送中断请求。线程的中断状态将被设置为`true`。如果目前该线程被一个`sleep`调用阻塞，那么将抛出`InterruptedException`异常|
|`static boolean interrupted()`|测试当前线程(即正在执行这一命令的线程)是否被中断。注意这是一个静态方法。这一调用会产生副作用：它将当前线程的中断状态重置为`false`|
|`boolean isInterrupted()`|测试线程是否被终止。不像静态的中断方法，这一调用不改变线程的中断状态|
|`static Thread currentThread()`|返回代表当前执行线程的`Thread`对象|

## 14.3 线程状态

* 可以通过`getState`方法确定一个线程的当前状态。线程可以有如下6种状态↓：
	* `new`(新创建)
	* `runnable`(可运行)
	* `blocked`(被阻塞)
	* `waiting`(等待)
	* `timed waiting`(计时等待)
	* `terminated`(被终止)

### 14.3.1 新创建线程`new`

* 当用`new`操作符创建一个新线程时，如`new Thread(r)`，该线程还没有开始运行。这意味着他的状态时`new`

* 当一个线程处于`new`状态时，程序还没有开始运行线程中的代码。在程序运行之前还有一些基础工作要做

### 14.3.2 可运行线程`runnable`

* 调用`start`方法之后，线程就处于`runnable`状态
	* 一个`runnable`的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间

*  一旦一个线程开始运行，它不必始终保持运行
	* 运行中的线程被中断，目的是为了让其他线程获得运行机会
	* 线程调度的细节依赖于操作系统提供的服务。抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权，并给另一个线程运行机会。当选择下一个线程时，操作系统考虑线程的优先级，参见[14.4.1 线程优先级](#1441-线程优先级)

### 14.3.3 被阻塞线程`blocked`和等待线程`waiting`、`timed waiting`

* 当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源，直到线程调度器重新激活它。区别在于线程时怎样达到非活动状态的
	* 阻塞状态`blocked`：当一个线程试图获取一个内部的对象锁(而不是`java.util.concurrent`库中的锁)，而该所被其他线程持有，则该线程进入阻塞状态。(`java.util.concurrent`锁见[14.5.3 锁对象](#1453-锁对象)，内部对象锁见[14.5.5 `synchronized`关键字](#1455-synchronized关键字))。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态
	* 等待状态`waiting`：当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。条件见[14.5.4 条件对象](#1454-条件对象)。在调用`Object.wait`方法或`Thread.join`方法，或者是等待`java.util.concurrent`库中的`Lock`或`Condition`时，就会出现这种情况。被阻塞状态与等待状态有很大不同
	* 计时等待`timed waiting`：有几个方法有一个超时参数，调用它们导致线程进入计时等待状态，这个状态将一直保持到超时期满或者接受到适当的通知。带有超时参数的方法有`Thread.sleep`和`Object.wait`、`Thread.join`、`Lock.tryLock`以及`Condition.await`的计时版

* 当一个线程被阻塞或等待时或终止时，另一个线程被调度为运行状态。当一个线程被重新激活，调度器会检查它是否具有比当前运行线程更高的优先级。如果具有更高的优先级，调度器从当前运行线程中挑选一个，剥夺其运行权，选择一个新的线程运行

### 14.3.4 被终止的线程`terminated`

* 线程终止原因：
	1. 因为`run`方法正常退出而自然死亡
	2. 因为一个没有捕获的异常终止了`run`方法而意外死亡

* 可以调用线程的`stop`方法杀死一个线程，但是`stop`方法已经过时，不要在自己的代码中调用这个方法

## 14.4 线程属性

### 14.4.1 线程优先级

* 每一个线程都有一个优先级，默认情况下，一个线程继承它的父线程的优先级
	* 每当线程调度器有机会选择新线程时，它首先选择具有较高优先级的线程

* 线程的优先级是高度依赖于系统的。当虚拟机依赖于宿主机平台的线程实现机制时，Java线程的优先级被映射到宿主机平台的优先级上，优先级个数也许更多，也许更少
	* Windows有7个优先级别。一些Java优先级将映射到相同的操作系统优先级
	* Oracle为Linux提供的Java虚拟机中，所有线程具有相同的优先级，线程的优先级被忽略
	* 不要将程序构建为功能的正确性依赖于优先级

* 如果有几个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行
	* 每当调度器决定运行一个新线程时，首先会在具有高优先级的线程中选择，尽管这样会使低优先级的线程完全饿死

* `java.lang.Thread`方法如下所示↓：

|`java.lang.Thread`方法名|作用|
|:-:|:-:|
|`void setPriority(int newPriority)`|设置线程的优先级。优先级必须在`Thread.MIN_PRIORITY`与`Thread.MAX_PRIORITY`之间。一般使用`Thread.NORM_PRIORITY`优先级|
|`static int MIN_PRIORITY`|线程的最小优先级，值为`1`|
|`static int NORM_PRIORITY`|线程的默认优先级，值为`5`|
|`static itn MAX_PRIORITY`|线程的最高优先级，值为`10`|
|`static void yield()`|导致当前执行线程处于让步状态。如果有其他的可运行线程具有至少与此线程同样高的优先级，那么这些线程接下来会被调度。注意该方法是一个静态方法|

### 14.4.2 守护线程

* 可以通过调用`t.setDaemon(true)`将线程转换为守护线程

* 守护线程的唯一用途是为其他线程提供服务。当只剩下守护线程时，虚拟机就退出了，因为如果只剩下守护进程，就没必要继续运行程序了

* 守护线程应该永远不去访问固有资源，如文件、数据库等，因为守护线程会在任何时刻，甚至在一个操作的中间发生中断

### 14.4.3 未捕获异常处理器

* 线程的`run`方法不能抛出任何受查异常，但是非受查异常会导致线程终止。在这种情况下，线程就死亡了
	* 不需要任何`catch`子句来处理可以被传播的异常，在线程死亡之前，异常被传递到一个用于未捕获异常的处理器
	* 未捕获异常处理器必须属于一个实现`Thread.UncaughtExceptionHandler`接口的类，这个接口只有一个方法：`void uncaughtException(Thread t, Throwable e)`

* 如果不安装默认的处理器，默认的处理器为空。如果不为独立的线程安装处理器，此时的处理器就是该线程的`ThreadGroup`对象
	* 线程组是一个可以统一管理的线程集合。默认情况下，创建的所有线程属于相同的线程组，但是也可能是会建立其他的组。现在引入了更好的特性用于线程集合的操作，所以建议不要在自己的程序中使用线程组

* `java.lang.Thread`方法如下所示↓：

|`java.lang.Thread`方法名|作用|
|:-:|:-:|
|`static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler)`</br>`static Thread.UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()`|设置或获取未捕获异常的默认处理器|
|`void setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler)`</br>`Thread.UncaughtExceptionHandler getUncaughtExceptionHandler()`|设置或获取未捕获异常的处理器。如果没有安装处理器，则将线程组对象作为处理器|

* `java.lang.Thread.UncaughtExceptionHandler`中的`void uncaughtException(Thread t, Throwable e)`方法：当一个线程因未捕获异常而终止，按规定要将客户报告记录到日志中
	* `t`：由于未捕获异常而终止的线程
	* `e`：未捕获的异常对象

* `java.lang.ThreadGroup`类实现`java.lang.Thread.UncaughtExceptionHandler`接口，它的`void uncaughtException(Thread t, Throwable)`方法做如下操作：
	1. 如果该线程有父线程组，那么父线程组的`uncaughtException`方法被调用
	2. 否则，如果`Thread.getDefaultExceptionHandler`方法返回一个非空的处理器，则调用该处理器
	3. 否则，如果`Throwable`是`ThreadDeath`的一个实例，什么都不做
	4. 否则，线程的名字以及`Throwable`的栈轨迹被输出到`System.err`上(但是如果`e`是一个`ThreadDeath`对象，栈轨迹是被禁用的。`ThreadDeath`对象由`stop`方法产生，而该方法已经过时)

## 14.5 同步

* 竞争条件：在多线程应用中，两个或两个以上的线程需要共享对同一数据的存取。如果两个线程存取相同的对象，并且每一个线程都调用了一个修改该对象状态的方法，根据各线程访问数据的次序，可能会发生讹误的对象。这样一个情况通常成为竞争条件

### 14.5.3 锁对象`ReentrantLock`

* 有两种机制防止代码块受并发访问的干扰：
	1. `synchronized`关键字：自动提供一个锁以及相关的条件，对于大多数需要显式锁的情况，这是很便利的
	2. `ReentrantLock`类：

* 用`ReentrantLock`保护代码块的基本结构如下所示↓：
	```Java
	Lock myLock = new ReentrantLock();

	myLock.lock();
	try {
		// ...
	} finally {
		myLock.unlock();	// 确保抛出异常时也会释放锁
	}
	```
	* 这一结构确保任何时刻只有一个线程进入临界区。一旦一个线程封锁了锁对象，其他任何线程都无法通过`lock`语句。当其他线程调用`lock`时，它们被阻塞，直到第一个线程释放锁对象

* 如果使用锁，就不能使用[带资源的`try`语句](#725-带资源的try语句)
	* 首先解锁方法名不是`close`
	* 即使将解锁方法重命名，带资源的`try`语句也无法正常工作。它的首部希望声明一个新变量。但是如果使用一个锁，可能是想使用多个线程共享那个变量(而不是新变量)

* 锁是可重入的，因为线程可以重复地获得已经持有的锁。锁保持一个持有计数来跟踪对`lock`方法的嵌套调用。线程在每一次调用`lock`都要调用`unlock`来释放锁。因此被一个锁保护的代码可以调用另一个使用相同的锁的方法

* `java.util.concurrent.locks.Lock`方法如下所示↓：

|`java.util.concurrent.locks.Lock`方法名|作用|
|:-:|:-:|
|`void lock()`|获取这个锁；如果锁同时被另一个线程拥有，则发生阻塞|
|`void unlock()`|释放这个锁|

* `java.util.concurrent.locks.ReentrantLock`方法如下所示↓：

|`java.util.concurrent.locks.ReentrantLock`方法名|作用|
|:-:|:-:|
|`ReentrantLock()`|构建一个可以被用来保护临界区的可重入锁|
|`ReentrantLock(boolean fair)`|构建一个带有公平策略的锁。一个公平锁偏爱等待时间最长的线程。但是这一公平的保证将大大降低性能。所以默认情况下，锁没有被强制为公平的|

### 14.5.4 条件对象`Condition`

* 要使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程

* 条件对象经常被称作条件变量

* 一个锁对象可以有一个或多个相关的条件对象。可以用`newCondition`方法获得一个条件对象
	* 等待获得锁的线程和调用`await`方法使用条件对象的线程存在本质上的不同。一旦一个线程调用`await`方法，它进入该条件的等待集。当锁可用时，该线程不能马上解除阻塞。相反它处于阻塞状态，直到另一个线程调用同一条件上的`signalAll`方法时为止
	* 通常对`await`的调用应该在如下形式的循环体中↓：
	```Java
	while (条件不满足)
		condition.await();
	```
	* 当一个线程调用`await`时，它无法重新激活自身

* `signalALL`方法重新激活因为这一条件而等待的所有线程。当这些线程从等待集汇当中移出时，它们再次成为可运行的，调度器将再次激活它们。同时它们将试图重新进入该对象。一旦锁成为可用的，它们中的某个将从`await`调用返回，获得该锁并从被阻塞的地方继续执行。此时线程应该再次测试该条件，`signalAll`方法仅仅是通知正在等待的线程，因此无法确保该条件被满足

* 调用`signalAll`不会立即激活一个等待线程，它仅仅解除等待线程的阻塞，以便这些线程可以在当前线程退出同步方法之后，通过竞争实现对对象的访问

* `signal`方法随机解除等待集中某个线程的阻塞状态。这比解除所有线程的阻塞更加有效，但也存在危险。如果随机选择的线程发现自己仍然不能运行，那么它再次被阻塞。如果没有其他线程再次调用`sigal`，那么系统就死锁了

* 锁与条件对象小结：
	* 锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码
	* 锁可以管理试图进入被保护代码段的线程
	* 锁可以拥有一个或多个相关的条件对象
	* 每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程

* `java.util.concurrent.locks.Condition`方法如下所示↓：

|`java.util.concurrent.locks.Condition`方法名|作用|
|:-:|:-:|
|`void await()`|将该线程放到条件的等待集中|
|`void signalAll()`|解除该条件的等待集中的所有线程的阻塞状态|
|`void signal()`|从该条件的等待集中随机地选择一个线程，解除其阻塞状态|

* `java.util.concurrent.locks.Lock`中的`Condition newCondition()`方法：返回一个与该锁相关的条件对象

### 14.5.5 `synchronized`关键字

* Java中的每个对象都有一个内部锁，并且该锁有一个内部条件。如果一个方法用`synchronized`关键字声明，那么对象的锁将保护整个方法，即要调用该方法，线程必须获得内部的对象锁。下述两段代码是等价的↓：
	```Java
	public synchronized void method() {
		// ...
	}

	public void method() {
		this.intrinsicLock.lock();
		try {
			// ...
		} finally {
			this.intrinsicLock.unlock();
		}
	}
	```
	* 内部对象锁只有一个相关条件，`wait`方法添加一个线程到等待集中，`notifyAll`、`notify`方法解除等待线程的阻塞状态。`wait`、`notifyAll`以及`notify`方法是`Object`类的`final`方法。下述两段代码是等价的↓：
	```Java
	private Lock myLock = new ReentrantLock();
	private Condition myCondition = myLock.newCondition();
	public void method() {
		myLock.lock();
		try {
			while (条件不满足)
				myCondition.await();
			// ...
			myCondition.signalAll();
		} finally {
			myLock.unlock();
		}
	}

	public synchronized void method() {
		while (条件不满足)
			wait();
		// ...
		notifyAll();
	}
	```

* 由锁来管理那些试图进入`synchronized`方法的线程，由条件来管理那些调用`wait`的线程。

* 将静态方法声明为`synchronized`也是合法的。如果调用该方法，该方法获得相关的类对象的内部锁。如当调用`Bank`类的静态同步方法时，`Bank.class`对象的锁被锁住。因此没有其他线程可以调用同一个类的同步静态方法

* 内部锁和条件的局限：
	* 不能中断一个正在试图获得锁的线程
	* 试图获得锁时不能设定超时
	* 每个锁仅有单一的条件，这可能是不够的

* `Lock`、`Condition`对象和`synchronized`方法选择建议：
	* 最好既不使用`Lock`/`Condition`也不使用`synchronized`关键字。在许多情况下可以使用`java.util.concurrent`包中的机制，它会处理所有的加锁。如[14.6 阻塞队列](#146-阻塞队列)或并行流
	* 如果`synchronized`关键字适合程序，那么尽量使用`synchronized`关键字，这样可以减少代码数量，减少出错概率
	* 如果特别需要`Lock`/`Condition`结构提供的独有特性时，才使用`Lock`/`Condition`

* `java.lang.Object`方法如下所示↓：

	* 下述方法只能在`synchronized`方法或`synchronized`块内部调用。如果当前线程不是对象锁的持有者，该方法抛出一个`IllegalMonitorStateException`异常

|`java.lang.Object`方法名|作用|
|:-:|:-:|
|`void notifyAll()`|解除那些在该对象上调用`wait`方法的线程的阻塞状态|
|`void notify()`|随机选择一个在该对象上调用`wait`方法的线程，解除其阻塞状态|
|`void wail()`|导致线程进入等待状态直到它被通知|
|`void wait(long millis)`</br>`void wait(long millis, int nanos)`|导致线程进入等待状态直到它被通知或者经过指定的时间。`millis`：毫秒数；`nanos`：纳秒数(应小于1 000 000)|

### 14.5.6 同步阻塞

* 每个Java对象都有一个锁。线程可以通过调用同步方法获得锁，也可以通过进入一个同步阻塞获得锁

* 同步阻塞语法如下所示↓：
	```Java
	synchronized (obj) {
		// ...
		// 此时获得 obj 的锁
	}
	```

* 客户端锁定：使用一个对象的锁来实现额外的原子操作。客户端锁定是非常脆弱的，通常不推荐使用

### 14.5.7 监视器概念

* 监视器具有如下特性：
	* 监视器是只包含`private`变量的类
	* 每个监视器类的对象有一个相关的锁
	* 使用该锁对所有的方法进行加锁
		* 即如果客户端调用`obj.method()`，那么`obj`对象的锁是在方法调用开始时自动获得，并且当方法返回时自动释放该锁
		* 因为所有的变量都是私有的，这样可以确保一个线程在对对象操作时，没有其他线程能访问该变量
	* 该锁可以有任意多个相关条件(每一个条件变量管理一个独特的线程集)

* Java以不是很精确的方法采用了监视器的概念
	* 相同点：
		* Java中每一个对象有一个内部的锁和内部的条件
		* 方法可以用`synchronized`关键字声明，此时该方法表现的就像是一个监视器方法
		* 通过调用`wait`、`notifyAll`、`notify`来访问条件变量
	* 不同点(使得线程的安全性下降)：
		* 变量不要求必须是`private`
		* 方法不要求必须是`synchronized`
		* 内部锁对客户是可用的

### 14.5.8 `Volatile`变量

* `volatile`关键字为实例域的同步访问提供了一种免锁机制。如果声明一个变量为`volatile`，那么编译器和虚拟机就知道该变量是可能被另一个线程并发更新的
	* `volatile`关键字禁止使用寄存器缓存，同时禁止指令重排

* `volatile`变量不能提供原子性

### 14.5.9 `final`变量

* 从多个线程安全地读取一个变量的方法：使用锁、使用`volatile`修饰符、将变量声明为`final`

* 将变量声明为`final`，如`final Map<String, Double> map = new HahsMap<>();`
	* 其他线程会在构造函数完成之后才能看到这个`map`变量
	* 如果不使用`final`，就不能保证其他线程看到的是`map`更新后的值，它们可能都只是看到`null`，而不是新构造的`HashMap`
	* 对这个映射表的操作并不是线程安全的。如果多个线程在读写这个映射表，仍然需要进行同步

* 如果对共享变量除了赋值之外并不完成其他操作，那么可以将这些共享变量声明为`volatile`

### 14.5.10 原子性

* `java.util.concurrent.atomic`包中有很多类使用了高效的机器级指令(而不是使用锁)来保证其他操作的原子性
	* 如`AtomicInteger`类中的方法`incermentAndGet`和`decrementAndGet`分别以原子方式将一个整数自增或自减并返回

### 14.5.11 死锁

* 定义：如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁的

* 资源死锁出现的条件：
	1. 互斥条件：每个资源要么已经分配给了一个进程，要么就是可用的
	2. 占有和等待条件：已经得到了某个资源的进程可以再请求新的资源
	3. 不可抢占条件：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放
	4. 环路等待条件：死锁发生时，系统中一定有由两个或两个以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源

### 14.5.12 线程局部变量`ThreadLocal<T>`

* 为避免在线程间共享变量的风险，可以使用`ThreadLocal`辅助类为各个线程提供各自的实例
	* 如`SimpleDateFormat`类不是线程安全的，假设有一个静态变量：`public static final SimpleDateFormat data = new SimpleDateFormat("yyyy-MM-dd");`
	* 可以使用如下代码为每个线程构造一个实例：`public static final ThreadLocal<SimpleDateFormat> data = ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd"));`
	* 可以通过调用`get()`来访问：`String dateStamp = data.get().format(new Date())`
	* 在一个给定线程中首次调用`get`时，会调用`initialValue`方法。在此之后，`get`方法会返回属于当前线程的那个实例

* `java.lang.ThreadLocal<T>`方法如下所示↓：

|`java.lang.ThreadLocal<T>`方法名|作用|
|:-:|:-:|
|`T get()`|得到这个线程的当前值。如果是首次调用该方法，会调用`initialize`来得到这个值|
|`protected initialize()`|应覆盖这个方法来提供一个初始值。默认情况下，该方法返回`null`|
|`void set(T t)`|为这个线程设置一个新值|
|`void remove()`|删除对应这个线程的值|
|`static <S> ThreadLocal<S> withInitial(Supplier<? extends S> supplier)`|创建一个线程局部变量，其初始值通过调用给定的`supplier`生成|

* `java.util.concurrent.ThreadLocalRandom`中的`static ThreadLocalRandom current()`方法：返回特定于当前线程的`Random`类实例

### 14.5.13 锁测试与超时

* `tryLock`方法试图申请一个锁，在成功获得锁后返回`true`：否则立即返回`false`，而且线程可以立即离开去做其他事情。代码如下所示↓：
	```Java
	if (myLock.tryLock()) {
		// 现在线程拥有锁
		try {
			// ...
		} finally {
			myLock.unlock();
		}
	} else {
		// 线程不拥有锁，进行其他任务
	}
	```

* `java.util.concurrent.locks.Lock`方法如下所示↓：

|`java.util.concurrent.locks.Lock`方法名|作用|
|:-:|:-:|
|`boolean tryLock()`|尝试获得锁而没有发生阻塞；如果成功返回真。这个方法会抢夺可用的锁(即使该锁有公平加锁策略，即便其他线程已经等待很久)|
|`boolean tryLock(long time, TimeUnit unit)`|尝试获得锁，阻塞时间不会超过给定的值；如果成功返回`true`。如果线程被中断，抛出一个`InterruptedException`异常。`TimeUnit`是一个枚举类型，可以取的值包括`SECONDS`、`MILLISECONDS`、`MICROSECONDS`和`NANOSECONDS`|
|`void lockInterruptibly()`|获得锁，但是会不确定地发生阻塞，相当于超时设为无限的`tryLock`方法。如果线程被中断，抛出一个`InterruptedException`异常|

* `java.util.concurrent.locks.Condition`方法如下所示↓：

|`java.util.concurrent.locks.Condition`方法名|作用|
|:-:|:-:|
|`boolean await(long time, TimeUnit unit)`|进入该条件的等待集，直到线程从等待集中移除(被另一个线程调用`signalAll`或`signal`激活)或等待了指定的时间之后才解除阻塞。如果因为等待时间到了而返回就返回`false`，否则返回`true`。如果等待的线程被中断，该方法将抛出一个`InterruptedException`异常|
|`void awaitUninterruptibly()`|进入该条件的等待集，直到线程从等待集中移出才解除阻塞。如果线程被中断，该方法不会抛出`InterruptedException`异常|

### 14.5.14 读/写锁`ReentrantReadWriteLock`

* `java.util.concurrent.locks`包中定义了两个锁类：`ReentrantLock`和`ReentrantReadWriteLock`

* 使用读/写锁的必要步骤：
	1. 构造一个`ReentrantReadWriteLock`对象
		* `private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();`
	2. 抽取读锁和写锁
		* `private Lock readLock = rwl.readLock();`
		* `private Lock writeLock = rwl.writeLock();`
	3. 对所有的获取方法加读锁
	```Java
	public double getData() {
		readLock.lock();
		try {
			// ...
		} finally {
			readLock.unlock();
		}
	}
	```

	4. 对所有的修改方法加写锁
	```Java
	public void setData() {
		writeLock.lock();
		try {
			// ...
		} finally {
			writeLock.unlock();
		}
	}
	```

* `java.util.concurrent.locks.ReentrantReadWriteLock`方法如下所示↓：

|`java.util.concurrent.locks.ReentrantReadWriteLock`方法名|作用|
|:-:|:-:|
|`Lock readLock()`|得到一个可以被多个读操作共用的读锁，但会排斥所有写操作|
|`Lock writeLock()`|得到一个写锁，排斥所有其他的读操作和写操作|

### 14.5.15 为什么弃用`stop`和`suspend`方法

* 初始的Java版本定义了一个`stop`方法来终止一个线程，以及一个`suspend`方法用来阻塞一个线程直到另一个线程调用`resume`
	* `stop`、`suspend`和`resume`方法已经弃用

* `stop`方法终止所有未结束的方法，包括`run`方法。当线程被终止时，立即释放被它锁住的所有对象的锁。这会导致对象处于不一致的状态，会被其他尚未停止的线程观察到
	* 在希望停止线程的时候，应该中断线程，被中断的线程会在安全的时候停止

* `suspend`方法挂起一个持有一个锁的进程时，该锁在恢复之前是不可用的。如果调用`suspend`方法的线程试图获得同一个锁，那么程序会死锁：被挂起的线程的等待被恢复，而将其挂起的线程等待获得锁
	* 如果想安全地挂起线程，引入一个变量`suspendRequested`并在`run`方法的某个安全的地方测试它，安全的地方是指该线程没有封锁其他线程所需要的对象的地方。当该线程发现`suspendRequested`变量已经设置，将会保持等待状态直到它再次获得为止

## 14.6 阻塞队列

* 对于许多线程问题，可以通过一个或多个线程将其形式化。使用队列，可以安全地从一个线程向另一个线程传递数据

* 阻塞队列：当试图向队列添加元素而队列已满，或是想从队列移除元素而队列为空的时候，阻塞队列将导致线程阻塞
	* 工作者线程可以周期性地将中间结果存储在阻塞队列中，其他的工作者线程移除中间结果并进一步加以修改。队列会自动地平衡负载

* 阻塞队列方法如下所示↓：

|方法|正常动作|特殊情况下的动作|
|:-:|:-:|:-:|
|`add`|添加一个元素|如果队列满，则抛出`IllegalStateException`异常|
|`put`|添加一个元素|如果队列满，则阻塞|
|`offer`|添加一个元素并返回`true`|如果队列满，返回`false`|
|`element`|返回队列的头元素|如果队列空，抛出`NoSuchElementException`异常|
|`peek`|返回队列的头元素|如果队列空，则返回`null`。插入`null`是非法的|
|`remove`|移除并返回头元素|如果队列空，则抛出`NoSuchElementException`异常|
|`take`|移除并返回头元素|如果队列空，则阻塞|
|`pool`|移除并返回队列的头元素|如果队列空，则返回`null`。插入`null`是非法的|

* `java.util concurrent.LinkedBlockingQueue<E>`与`...LinkedBlockingDeque<E>`方法如下所示↓：

|`LinkedBlockingQueue`与`LinkedBlockingDeque`方法名|作用|
|:-:|:-:|
|`LinkedBlockingQueue()`</br>`LinkedBlockingDeque()`|构造一个无上限的阻塞队列或双向队列，用链表实现|
|`LinkedBlockingQueue(int capacity)`</br>`LinkedBlockingDeque(int capacity)`|根据指定容量构建一个有限的阻塞队列或双向队列，用链表实现|

* `java.util.concurrent.ArrayBlockingQueue<E>`中的如下方法：构造一个带有指定的容量和公平性设置的阻塞队列。该队列用循环数组实现。若设置了公平参数，那么等待了最长时间的线程会优先得到处理。通常公平性会降低性能，只有在确实非常需要时才使用它
	* `ArrayBlockingQueue(int capacity)`
	* `ArrayBlockingQueue(int capacity, boolean fair)`

* `java.util.concurrent.DelayQueue<E extends Delayed>`中的`DelayQueue()`方法：构造一个包含`Delayed`元素的无界的阻塞时间有限的阻塞队列。只有那些延迟已经超过时间的元素可以从队列中移除

* `java.util.concurrent.Delayed`中的`long getDelay(TimeUnit unit)`方法：得到该对象的延迟，用给定的时间单位进行度量。负值表示延迟已经结束。元素只有在延迟用完的情况下才能从`DelayQueue`移除。
	* `Delayed`必须实现`compareTo`方法，`DelayQueue`使用该方法对元素进行排序

* `java.util.concurrent.PriorityBlockingQueue<E>`中的如下方法：构造一个无边界阻塞优先队列，用堆实现
	* `PriorityBlockingQueue()`
	* `PriorityBlockingQueue(int initialCapacity)`
	* `PriorityBlockingQueue(int initialCapacity, Comparator<? super E> comparator)`
	* `initialCapacity`：优先队列的初始容量，默认值是11
	* `comparator`：用来对元素进行比较的比较器，如果没有指定，则元素必须实现`Comparable`接口

* `java.util.concurrent.BlockingQueue<E>`方法如下所示↓：

|`java.util.concurrent.BlockingQueue<E>`方法名|作用|
|:-:|:-:|
|`void put(E element)`|添加元素，在必要时阻塞|
|`E take()`|移除并返回头元素，必要时阻塞|
|`boolean offer(E element, long time, TimeUnit unit)`|添加给定的元素，如果成功放回`true`，如果必要时阻塞，直至元素已经被添加或超时|
|`E poll(long time, TimeUnit unit)`|移除并返回头元素，必要时阻塞，直至元素可用或超时用完。失败时返回`null`|

* `java.util.concurrent.BlockingDeque<E>`方法如下所示↓：

|`java.util.concurrent.BlockingDeque<E>`方法名|作用|
|:-:|:-:|
|`void putFirst(E element)`</br>`void putLast(E element)`|添加元素，必要时阻塞|
|`E takeFirst()`</br>`E takeLast()`|移除并返回头元素或尾元素，必要时阻塞|
|`boolean offerFirst(E element, long time, TimeUnit unit)`</br>`boolean offerLast(E element, long time, TimeUnit unit)`|添加给定的元素，成功时返回`true`，必要时阻塞直至元素被添加或超时|
|`E poolFirst(long time, TimeUnit unit)`</br>`E poolLast(long time, TimeUnit unit)`|移除并返回头元素或尾元素，必要时阻塞，直至元素可用或超时。失败时返回`null`|

* `java.util.concurrent.TransferQueue<E>`中的如下方法：传输一个值，或者尝试在给定的超时时间内传输这个值，这个调用将阻塞，直到另一个线程将元素删除。`tryTransfer`方法会在调用成功时返回`true`。即允许生产者线程等待，直到消费者准备就绪可以接收一个元素
	* `void boolean transfer(E element)`
	* `boolean tryTransfer(E element, long time, TimeUnit unit)`

## 14.7 线程安全的集合

* [阻塞队列](#146-阻塞队列)就是线程安全的集合。在本节中，将讨论Java类库提供的另外一些线程安全的集合

### 14.7.1 高效的映射、集和队列

* `java.util.concurrent`包提供了映射、有序集和队列的高效实现：`ConcurrentHashMap`、`ConcurrentSkipListMap`、`ConcurrentSkipListSet`和`ConcurrentLinkedQueue`
	* 这些集合使用复杂的算法，通过允许并发地访问数据结构的不同部分来使竞争极小化
	* 与大多数集合不同，`size`方法不必在常数时间内操作。确定这样的集合当前的大小通常需要遍历
	* 集合返回弱一致性的迭代器。该迭代器不一定能反映出它们被构造之后的所有的修改，但是它们不会将同一个值返回两次，也不会抛出`ConcurrentModificationException`异常(集合如果在迭代器构造之后发生改变，`java.util`包中的迭代器将抛出`ConcurrentModificationException`异常)

* 并发的散列映射表，可以高效地支持大量的读者和一定数量的写者
	* 默认情况下，如果同一时间多于可同时执行的写者线程，其他的写者线程将暂时被阻塞

* `java.util.concurrent.ConcurrentHashMap(K, V)`和`...ConcurrentSkipListMap<K, V>`方法如下所示↓：

|方法名|作用|
|:-:|:-:|
|`ConcurrentHashMap<K, V>()`</br>`ConcurrentHashMap<K, V>(int initialCapacity)`</br>`ConcurrentHashMap<K, V>(int initialCapacity, float loadFactor, int concurrencyLevel)`|构造一个可以被多线程安全访问的散列映射表。`initialCapacity`：集合的初始容量，默认值为16；`loadFactor`：控制调整。如果每一个桶的平均负载超过这个因子，表的大小会被重新调整。默认值为0.75|
|`ConcurrentSkipListMap<K, V>()`</br>`ConcurrentSkipListMap<K, V>(Comparator<? super K> comp)`|构造一个可以被多线程安全访问的有序的映射表。第一个构造器要求键实现`Comparable`接口|

* `java.util.concurrent.ConcurrentLinkedQueue<E>`中的`ConcurrentLinkedQueue<E>()`方法：构造一个可以被多线程安全访问的无边界非阻塞的队列

* `java.util.concurrent.ConcurrentLinkedSet<E>`中的如下方法：构造一个可以被多线程安全访问的有序集。第一个构造器要求元素实现`Comparable`接口
	* `ConcurrentSkipListSet<E>()`
	* `ConcurrentSkipListSet<E>(Comparator<? super E> comp)`

### 14.7.2 映射条目的原子更新

* 线程不安全的代码如下所示↓：
	```Java
	ConcurrentHashMap<String, Long> map = ...;
	Long oldValue = map.get(word);
	Long newValue = oldValue == null ? 1 : oldValue + 1;
	map.put(word, newValue);
	```

* 传统的线程安全方法：使用原子方式用一个新值替换原值(前提是之前没有其他线程把原值替换为其他值)。代码如下所示↓：
	```Java
	do {
		oldValue = map.get(word);
		newValue = oldValue == null ? 1 : oldValue + 1；
	} while (!map.replace(word, oldValue, newValue));
	```

* 可以使用一个`ConcurrentHashMap<String, AtomicLong>`，或在Java SE 8中还可以使用`ConcurrentHashMap<String, LongAdder>`。代码如下所示↓：
	```Java
	map.putIfAbsent(word, new LongAdder());	// 确保有一个 LongAdder 可以完成原子自增
	map.get(word).incerment();
	```
	* 由于`putIfAbsent`返回映射的值(可能是原来的值，或者是新设置的值)，所以可以将上述两个语句组合为：`map.putIfAbstract(word, new LongAdder()).increment();`

* Java SE 8中提供了一些可以更方便地完成原子更新的方法
	* 调用`compute`方法时可以提供一个键和一个计算新值的函数。这个函数接受键和相关联的值(如果没有值则为`null`)，它会计算新值。更新一个整数计数器的映射的示例如下所示：`map.compute(word, (k, v) -> v == null ? 1 : v + 1);`
	* `computeIfPresent`方法：只在已经有原值的情况下计算新值
	* `computeIfAbsent`方法：只在没有原值的情况下计算新值。更新一个整数计数器的映射的示例如下所示：`map.computeIfAbsent(word, k -> new LongAdder()).incerment();`

* `ConcurrentHashMap`中不允许有`null`值。有很多方法都是用`null`值来指示映射中某个给定的键不存在

* 首次增加一个键是通常需要做些特殊的处理。利用`merge`方法可以非常方便地做到这一点。这个方法有一个参数表示键不存在时使用的初始值。否则就会使用提供的函数来结合原值与初始值(与`compute`不同，该函数不处理键)
	* 如：`map.merge(word, 1L, (existingValue, newValue) -> existingValue + newValue)`
	* 可以简写为：`map.merge(word, 1L, Long::sum)`

* 如果传入`compute`或`merge`的函数返回`null`，将从映射中删除现有的条目

* 使用`compute`或`merge`时，提供的函数不能做太多工作。这个函数运行时，可能会阻塞对映射的其他更新。当然该函数也不能更新映射的其他部分

### 14.7.3 对并发散列映射的批操作

* Java SE 8为并发散列映射提供了批操作，即使有其他线程在处理映射，这些操作也能安全地执行
	* 批操作会遍历映射，处理遍历过程中找到的元素，无须冻结当前映射的快照
	* 除非恰好知道批操作运行时映射不会被修改，否则就要把结果看做是映射状态的一个近似

* 批操作分类：
	* 有三种不同的操作：
		* 搜索`search`：为每个键或值提供一个函数，直到函数生成一个非`null`的结果。然后搜索终止，返回这个函数的结果
		* 归约`reduce`：组合所有键或值，这里要使用所提供的一个累加函数
		* `forEach`：为所有键或值提供一个函数
	* 每个操作都有四个版本：
		* `operationKeys`：处理键
		* `operationValues`：处理值
		* `operation`：处理键和值
		* `operationEntries`：处理`Map.Entry`对象
	* 对于上述各个操作，需要指定一个参数化阈值。如果映射包含的元素多于这个阈值，就会并行完成批操作。如果希望批操作在一个线程中运行，可以使用阈值`Long.MAX_VALUE`。如果希望用尽可能多的线程运行批操作，可以使用阈值`1`

* `search`方法的不同版本：
	* `U searchKeys(long threshold, BiFunction<? super K, ? extends U> f)`
	* `U searchValues(long threshold, BiFunction<? super V, ? extends U> f)`
	* `U search(long threshold, BiFunction<? super K, ? super V, ? extends U> f)`
	* `U searchEntries(long threshold, BiFunction<Map.Entry<K, V>, ? extends U> f)`
	* 示例：找出第一个出现次数超过1000次的单词，需要搜索键和值：`String result = map.search(threshold, (k, v) -> v > 1000 ? k : null);`

* `forEach`方法有两种形式
	1. 为各个映射条目提供一个消费者函数，如：`map.forEach(threshold, (k, v) -> System.out.println(k + " -> " + v));`
	2. 为各个映射条目提供一个转换器函数和一个消费者函数，需要先提供转换器函数，其结果会传递到消费者，如：`map.forEach(threshold, (k, v) -> k + " -> " + v, System.out::println);`
	* 转换器可以用作为一个过滤器。只要转换器返回`null`，这个值就会被跳过，如只打印值大于1000的条目：`map.forEach(threshold, (k, v) -> v > 1000 ? k + " -> " + v : null, System.out::println);`

* `reduce`操作：用一个累加函数组合其输入
	* 示例：计算所有值的总和：`Long sum = map.reduceValues(threshold, Long::sum);`
	* 与`forEach`类似，也可以提供一个转换器函数。如计算最长的键的长度：`Integer maxlength = map.reduceKeys(threshold, String::Length, Integer::max);`
	* 转换器可以作为一个过滤器，通过返回`null`来排除不想要的输入，如统计多少个条目的值大于1000：`Long count = map.reduceValues(threshold, v -> v > 1000 ? 1L : null, Long::sum);`
	* 如果映射为空，或者所有条目都被过滤掉，`reduce`操作会返回`null`；如果只有一个元素，则返回其转换结果，不会应用累加器
	* 对于`int`、`long`和`double`输出还有相应的特殊化操作，分别由后缀`ToInt`、`ToLong`和`ToDouble`。需要把输入转化为一个基本类型值，并制定一个默认值和一个累加器函数。映射为空时返回默认值。参数列表为阈值、转换器函数、默认值、累加器函数。如：`long sum = map.reduceValuesToLong(threshold, Long::longValue, 0, Long::sum);`
	* 特殊化操作与对象版本的操作有所不同，对于对象版本的操作，只需要考虑一个元素。这里不是返回转换得到的元素，而是将与默认值累加。因此默认值必须是累加器的零元素

### 14.7.4 并发集视图

* 静态方法`newKeySet`会生成一个`Set<K>`，这实际上是`ConcurrentHashMap<K, Boolean>`的一个包装器(所有映射值都为`Boolean.TRUE`，不过因为只是要把它用作一个集合，因此并不关心具体的值)
	* 如：`Set<String> words = ConcurrentHashMap.<String>newKeySet();`
	* 如果原来有一个映射，`KeySet`方法可以生成这个映射的键集。这个集合是可变的，如果删除这个集合的元素，这个键以及相应的值会从映射中删除。不过不能向键集增加元素，因为没有相应的值可以增加
	* Java SE 8为`ConcurrentHashMap`增加了第二个`keySet`方法，包含一个默认值，可以在为集合增加元素时使用。如：`Set<String> words = map.keySet(1L); words.add("Java");`，此时如果`"Java"`在`words`中不存在，现在它会有一个值`1`

### 14.7.5 写数组的拷贝

* `CopyOnWriteArrayList`和`CopyOnWriteArraySet`是线程安全的集合，其中所有的修改线程对底层数组进行复制。如果在集合上进行迭代的线程数超过修改线程数，这样的安排是很有用的
	* 当构建一个迭代器的时候，它包含一个对当前数组的引用。如果数组后来被修改了，迭代器仍然引用旧数组，但是集合的数组已经被替换了。因而旧的迭代器拥有一致的(可能过时的)视图，访问它无须任何同步开销

### 14.7.6 并行数组计算

* 在Java SE 8中，`Arrays`类提供了大量并行化操作

* 静态`Arrays.parallelSort`方法可以对一个基本类型值或对象的数组排序。如：`String[] words = ...; Arrays.parallelSort(words);`
	* 对对象排序时，可以提供一个`Comparator`。如：`Arrays.parallelSort(words, Comparator.comparing(String::length));`
	* 对于所有方法都可以提供一个范围的边界。如：`values.parallelSort(values.length / 2, values,length);`

* `parallelSetAll`方法会用由一个函数计算得到的值填充一个数组。这个函数接收元素索引，然后计算相应位置上的值。如：`Arrays.parallelSetAll(values, i -> i % 10);`
	* 这个操作对于所有基本类型数组和对象数组都有相应的版本

* `parallelPrefix`方法用对应一个给定结合操作的 前缀的 累加结果 替换各个数组元素
	* 如：对于给定数组`value = {1, 2, 3, 4, ...}`，`Arrays.parallelPrefix(values, (x, y) -> x * y)`之后，数组将包含`{1, 1x2, 1x2x3, 1x2x3x4, ...}`

### 14.7.7 较早的线程安全集合

* 从Java的初始版本开始，Vector和Hashtable类就提供了线程安全的动态数组和散列表的实现。现在这些类被弃用了，取而代之的是ArrayList和HashMap类

* 这些类不是线程安全的，而集合库中提供了不同的机制。任何集合类都可以通过使用同步包装器变成线程安全的，如：`List<E> synchArrayList = Collections.synchronizedList(new ArrayList<E>());`、`Map<K, V> synchHashMap = Collections.synchronizedMap(new HashMap<K, V>());`。结果集合的方法使用锁加以保护，提供了线程安全访问

* 应该确保没有任何线程通过原始的非同步方法访问数据结构。最便利的方法是确保不保存任何指向原始对象的引用，简单地构造一个集合并立即传递给包装器，如上述代码示例

* 如果在另一个线程可能进行修改时要对集合进行迭代，仍然需要使用"客户端"锁定，代码示例如下↓：
	```Java
	synchronized (synchHashMap) {
		Iterator<K> iter = synchHashMap.keySet().iterator();
		while (iter.hasNext())
			// ...
	}
	```
	* 如果使用`foreach`循环必须使用同样的代码，因为循环使用了迭代器。
	* 如果在迭代过程中，别的线程修改集合，迭代器会失效，抛出`ConcurrentModificationException`异常。同步仍然是需要的，因此并发的修改可以被可靠地检测出来

* 最好使用`java.Util.Concurrent`包中定义的集合，不使用同步包装器中的。特别是，假如它
们访问的是不同的桶，由于`ConcurrentHashMap`已经精心地实现了，多线程可以访问它而且
不会彼此阻塞。有一个例外是经常被修改的数组列表。在那种情况下，同步的`ArrayList`可
以胜过`CopyOnWriteArrayList`

* `java.util.Collections`中的如下方法：构建集合视图，该集合的方法是同步的
	* `static <E> Collection<E> synchronizedCollection(Collection<E> c)`
	* `static <E> List synchronizedList(List<E> c)`
	* `static <E> Set synchronizedSet(Set<E> c)`
	* `static <E> SortedSet synchronizedSortedSet(SortedSet<E> c)`
	* `static <K, V> Map<K, V> synchronizedMap(Map<K, V> c)`
	* `static <K, V> SortedMap<K, V> synchronizedSortedMap(SortedMap<K, V> c)`

## 14.8 `Callable`与`Future`

* `Runnable`封装一个异步运行的任务，可以把它想象成为一个没有参数和返回值的异步方法。`Callable`与`Runnable`类似，但是有返回值。`Callable`接口是一个参数化的类型，只有一个方法`call`

* `FutureTask`包装器是一种非常便利的机制，可将`Callable`转换成`Future`和`Runnable`，它同时实现二者的接口。代码如下所示↓：
	```Java
	Callable<Integer> myComputation = ...;
	Future<Integer> task = new FutureTask<Integer>(myComputation);
	Thread t = new Thread(task);	// 此为 Runnable
	t.start();
	// ...
	Integer result = task.get();	// 此为 Future
	```

* `java.util.concurrent.Callable<V>`中的`V call()`方法：运行一个将产生结果的任务

* `java.util.concurrent.Future<V>`方法如下所示↓：

|`java.util.concurrent.Future<V>`方法名|作用|
|:-:|:-:|
|`V get()`</br>`V get(long time, TimeUnit unit)`|获取结果，如果没有结果可用，则阻塞直到真正得到结果。如果在计算完成之前超过指定的时间，第二个方法会抛出`TimeoutException`异常。如果运行该计算的线程被中断，两个方法都将抛出`InterruptedException`。如果计算已经完成，那么`get`方法立即返回|
|`boolean cancel(boolean mayInterrupt)`|尝试取消这一任务的运行。如果计算还没有开始，它被取消且不再开始。如果任务已经开始，并且`mayInterrupt`参数值为`true`，它就会被中断。如果成功执行了取消操作，返回`ture`|
|`boolean isCancelled()`|如果任务在完成前被取消了，返回`true`|
|`boolean isDone()`|如果任务结束，无论是正常结束、中途取消或发生异常，都返回`true`|

* `java.util.concurrent.FutureTask<V>`中的如下方法：构造一个既是`Future<V>`又是`Runnable`的对象
	* `FutureTask(Callable<V> task)`
	* `FutureTask(Runnable task, V result)`

## 14.9 执行器

* 线程池：一个线程池中包含许多准备运行的空闲线程
	* 将`Runnable`对象交给线程池，就会有一个线程调用`run`方法
	* 当`run`方法退出时，线程不会死亡，而是在池中准备为下一个请求提供服务

* 使用线程池的原因：
	* 因为涉及到与操作系统的交互，因此构建一个新的线程是有一定代价的。如果程序中创建了大量的生命期很短的线程，应该使用线程池
	* 使用线程池可以减少并发线程的数目。创建大量线程会大大降低性能甚至使虚拟机崩溃。如果有一个会创建许多线程的算法，应该使用一个线程数"固定的"线程池以限制并发线程的总数

* `Executors`类有许多静态工厂方法用来构建线程池，如下表所示↓：

|方法|描述|
|:-:|:-:|
|`newCachedThreadPool`|必要时创建新线程；空闲线程会被保留60秒|
|`newFixedThreadPool`|该池包含固定数量的线程；空闲线程会一直被保留|
|`newSingleThreadExecutor`|只有一个线程的"池"，该线程顺序执行每一个提交的任务|
|`newScheduledThreadPool`|用于预定执行而构建的固定线程池，替代`java.util.Timer`|
|`newSingleThreadScheduledExecutor`|用于预定执行而构建的单线程"池"|

### 14.9.1 线程池`ExecutorService`

* 方法`newCachedThreadPool`、`newFixedThreadPool`和`newSingleThreadExecutor`返回实现了`ExecutorService`接口的`ThreadPoolExecutor`类的对象

* 可以用如下的方法之一将一个`Runnable`对象或`Callable`对象提交给`ExecutorService`，该线程池会在方便的时候尽早执行提交的任务。调用`submit`时，会得到一个`Future`对象，可用来查询该任务的状态
	* `Future<?> submit(Runnable task)`：该方法返回值为`Future<?>`，可以使用这样一个对象来调用`isDone`、`cancel`或`isCancelled`。但是`get`方法在完成的时候只是简单地返回`null`
	* `Future<T> submit(Runnable task, T result)`：`Future`的`get`方法在完成的时候返回指定的`result`对象
	* `Future<T> submit(Callable<T> task)`：返回的`Future`对象将在计算结果准备好的时候得到它

* 关闭线程池可用方法如下所示
	* `shutdown`：该方法启动该线程池的关闭序列。被关闭的执行器不再接受新的任务。当所有任务都完成以后，线程池中的线程死亡
	* `shutdownNow`：该线程池取消尚未开始的所有任务并试图中断正在运行的线程

* 在使用线程池时应该做的事：
	1. 调用`Executors`类中静态的方法`newCachedThreadPool`或`newFixedThreadPool`
	2. 调用`submit`提交`Runnable`或`Callable`对象
	3. 如果想要取消一个任务，或如果提交`Callable`对象，那就要保存好返回的`Future`对象
	4. 当不再提交任何任务时，调用`shutdown`

* `java.util.concurrent.Executors`方法如下所示↓：

|`java.util.concurrent.Executors`方法名|作用|
|:-:|:-:|
|`ExecutorService newCachedThreadPool()`|返回一个带缓存的线程池，该池在必要的时候创建线程，在线程空闲60秒之后终止线程。对于每个任务，如果有空闲线程可用，立即让它执行任务，如果没有可用的空闲线程，则创建一个新线程|
|`ExecutorService newFixedThreadPool(int threads)`|返回一个线程池，该池中的线程数由参数指定。如果提交的任务数多余空闲的线程数，那么把得不到服务的任务放置到队列中。当其他任务完成以后再运行它们|
|`ExecutorService newSingleThreadExecutor()`|返回一个执行器，它在一个单个的线程中依次执行各个任务|

* `java.util.concurrent.ExecutorService`方法如下所示↓：

|`java.util.concurrent.ExecutorService`方法名|作用|
|:-:|:-:|
|`Future<T> submit(Callable<T> task)`</br>`Future<T> submit(Runnable task, T result)`</br>`Future<T> submit(Runnable task)`|提交指定的任务去执行|
|`void shutdown()`|关闭服务，会先完成已经提交的任务而不再接受新的任务|

* `java.util.concurrent.ThreadPoolExecutor`中的`int getLargestPoolSize()`方法：返回线程池在该执行器生命周期中的最大尺寸

### 14.9.2 预定执行`ScheduledExecutorService`

* `ScheduledExecutorService`接口具有为预定执行或重复执行任务而设计的方法，它是一种允许使用线程池机制的`java.util.Timer`的泛化

* 可以预定`Runnable`或`Callable`在初始的延迟后只运行一次，也可以预定一个`Runnable`对象周期性地运行，具体见下述表格

* `java.util.concurrent.Executors`方法如下所示↓：

|`java.util.concurrent.Executors`方法名|作用|
|:-:|:-:|
|`ScheduledExecutorService newScheduledThreadPool(int threads)`|返回一个线程池，它使用给定的线程数来调度任务|
|`ScheduledExecutorService newSingleThreadScheduledExecutor()`|返回一个执行器，它在一个单独线程中调度任务|

* `java.util.concurrent.ScheduledExecutorService`方法如下所示↓：

|`java.util.concurrent.ScheduledExecutorService`方法名|作用|
|:-:|:-:|
|`ScheduledFuture<V> schedule(Callable<V> task, long time, TimeUnit unit)`</br>`ScheduledFuture<?> schedule(Runnable task, long time, TimeUnit unit)`|预定在指定的时间之后执行任务|
|`ScheduledFuture<?> scheduleAtFixedRate(Runnable task, long initialDelay, long period, TimeUnit unit)`|预定在初始的延迟结束后，周期性地运行给定的任务，周期长度是`period`|
|`ScheduledFuture<?> scheduleWithFixedDelay(Runnable task, long initialDelay, long delay, TimeUnit unit)`|预定在初始的延迟结束后周期性地运行给定的任务，在一次调用完成和下一次调用开始之间有长度为`delay`的延迟|

### 14.9.3 控制任务组

* 可以使用一个`ExecutorService`作为线程池使用，以提高执行任务的效率。有时使用`ExecutorService`更有实际意义，控制一组相关任务。如可以在执行器中使用`shutdownNow`方法取消所有的任务

* `java.util.concurrent.ExecutorService`方法如下所示↓：

|`java.util.concurrent.ExecutorService`方法名|作用|
|:-:|:-:|
|`T invokeAny(Collection<Callable<T>> tasks)`</br>`T invokeAny(Collection<Callable<T>> tasks, long timeout, TimeUnit unit)`|执行给定的任务，返回其中一个任务的结果。第二个方法若发生超时，抛出一个`TimeoutException`异常。无法确定返回的究竟是哪个任务的结果|
|`List<Future<T>> invokeAll(Collection<Callable<T>> tasks)`</br>`List<Future<T>> invokeAll(Collection<Callable<T>> tasks, long timeout, TimeUnit unit)`|执行给定的任务，返回所有任务的结果。第二个方法若发生超时，抛出一个`TimeoutException`异常。该方法缺点是如果第一个任务恰巧花去了很多时间，则可能不得不进行等待|

* `java.util.concurrent.ExecutorCompletionService<V>`方法如下所示↓：

|`java.util.concurrent.ExecutorCompletionService<V>`方法名|作用|
|:-:|:-:|
|`ExecutorCompletionService(Executor e)`|构建一个`ExecutorCompletionService`来收集给定执行器的结果|
|`Future<V> submit(Callable<V> task)`</br>`Future<V> submit(Runnable task, V result)`|提交一个任务给底层的执行器|
|`Future<V> take()`|移除下一个已完成的结果，如果没有任何已完成的结果可用则阻塞|
|`Future<V> poll()`</br>`Future<V> poll(long time, TimeUnit unit)`|移除下一个已完成的结果，如果没有任何已完成结果可用则返回`null`。第二个方法将等待给定的时间|

### 14.9.4 `Fork-Join`框架

* `fork-join`框架专门用来支持对每个处理器内核分别使用一个线程，以完成计算密集型任务
	* 统计一个数组中有多少个元素满足某个特定的属性，可以将这个数组一分为二，分别对这两部分进行统计，再将结果相加。要采用框架可用的一种方式完成上述递归计算，如果计算会生成一种类型为`T`的结果，就需要提供一个扩展`RecursiveTask<T>`的类；如果计算不生成任何结果，则需要提供一个扩展	`RecursiveAction`的类。还需要覆盖`compute`方法来生成并调用子任务，然后合并其结果。示例代码如下所示↓：
	```Java
	class Counter extends RecursiveTack<Integer> {
		// ...
		protected Integer compute() {
			if (to - from < THRESHOLD)
				// 直接解决问题
			else {
				int mid = (from + to) / 2;
				Counter first = new Counter(values, from, mid, filter);
				Counter second = new Counter(values, mid, to, filter);
				invokeAll(first, second);	// 接受很多任务并阻塞，直到所有这些任务都已经完成
				return first.join() + second.join();	// 生成结果
			}
		}
	}
	```
	* `get`方法也可以得到当前结果，但是不常用。因为`get`方法可能抛出受查异常，而在`compute`方法中不允许抛出这些异常

* 在后台，`fork-join`框架使用了一种有效的智能方法来平衡可用线程的工作负载，这种方法称为工作密取。每个工作线程都有一个双端队列`deque`来完成任务。一个工作线程将子任务压入其双端队列的队头(只有一个线程可以访问队头，所以不需要加锁)。一个工作线程空闲时，它会从另一个双端队列的队尾"密取"一个任务。由于大的子任务都在队尾，这种密取很少出现

### 14.9.5 可完成`Future`

* `CompletableFuture`类提供了一种候选方法，与事件处理器不同，"可完成future"可以组合
	* 利用`CompletableFuture`，可以指定希望做什么，以及希望以什么顺序执行这些工作，当然这不会立即发生

* 为`CompletabelFuture<T>`对象增加一个动作如下表所示
	* 用于处理单个`future`方法
	* 对于表中所示的每个方法，还有两个`Async`形式，不过这里没有给出。一种一种形式使用一个共享`ForkJoinPool`，另一种形式有一个`Executor`参数
	* 下表中把`Fuunction<? supre T, U>`简写为`T -> U`

|方法|参数|描述|
|:-:|:-:|:-:|
|`thenApply`|`T -> U`|对结果应用一个函数|
|`thenCompose`|`T -> CompletableFuture<U>`|对结果调用函数并执行返回的`future`|
|`handle`|`(T, Throwable) -> U`|处理结果或错误|
|`thenAccept`|`T -> void`|类似于`thenApply`，不过结果为`void`|
|`whenComplete`|`(T, Throwable) -> void`|类似于`handle`，不过结果为`void`|
|`thenRun`|`Runnable`|执行`Runnable`，结果为`void`|

* 组合多个`future`的方法如下表所示↓：
	* 前三个方法并行运行一个`CompletableFuture<T>`和一个`CompletableFuture<U>`动作，并组合结果
	* 接下来三个方法并行运行两个`CompletableFuture<T>`动作。一旦其中一个动作完后，就传递它的结果，并忽略另一个结果
	* 最后的静态`allOf`和`anyOf`方法取一组可完成的`future`(数目可变)，并生成呢一个`CompletableFuture<Void>`，它会在所有这些`future`都完成时或者其中任意一个`future`完成时结束。不会传递任何结果

|方法|参数|描述|
|:-:|:-:|:-:|
|`thenCombine`|`CompletableFuture<U>, (T, U) -> V`|执行两个动作并用给定函数组合结果|
|`thenAcceptBoth`|`CompletableFuture<U>, (T, U) -> void`|与`thenCombine`类似，不过结果为`void`|
|`runAfterBoth`|`CompletableFuture<?>, Runnable`|两个都完成后执行`runnable`|
|`applyToEither`|`CompletableFuture<T>, T -> V`|得到其中一个的结果时，传入给定的函数|
|`acceptEither`|`CompletableFuture<T>, T -> void`|与`applyToEither`类似，不过结果为`void`|
|`runAfterEither`|`CompletableFuture<?>, Runnable`|其中一个完成后执行`runnable`|
|`static allOf`|`CompletableFuture<?> ...`|所有给定的`future`都完成后完成，结果为`void`|
|`static anyOf`|`CompletableFuture<?> ...`|任意给定的`future`完成后则完成，结果为`void`|

## 14.10 同步器

* `java.util.concurrent`包包含了几个能帮助管理相互合作的线程集的类，如下表所示↓：
	* 这些机制具有为线程之间的共用集结点模式提供的"预置功能"
	* 如果有一个相互合作的线程集满足这些行为模式之一，那么应该直接重用合适的库类，而不要试图提供手工的锁与条件的集合

|类|作用|说明|
|:-:|:-:|:-:|
|`CyclicBarrier`|允许线程集等待直至其中预定的线程到达一个公共障栅，然后可以选择执行一个处理障栅的动作|当大量的线程需要在它们的结果可用之前完成时|
|`Phaser`|类似于循环障栅，不过有一个可变的计数|Java SE 7中引入|
|`CountDownloadLatch`|允许线程集等待直到计数器减为0|当一个或多个线程需要等待直到指定数目的事件发生|
|`Exchanger`|允许两个线程在要交换的对象准备好时交换对象|当两个线程工作在同一数据结构的两个实例上的时候，一个向实例添加数据而另一个从实例清除数据|
|`Semaphore`|允许线程集等待直到被允许继续运行为止|限制访问资源的线程总数。如果许可数是1，常常阻塞线程直到另一个线程给出许可为止|
|`SynchronousQueue`|允许一个线程把对象交给另一个线程|在没有显式同步的情况下，当两个线程准备好将一个对象从一个线程传递到另一个时|

### 14.10.1 信号量

* 一个信号量管理许多的许可证。为了通过信号量，线程通过调用`acquire`请求许可

* 信号量仅维护一个计数，没有实际的许可对象

* 许可的数目是固定的，由此限制了通过的线程数量

* 其他线程可以通过调用`release`释放许可。任何线程都可以释放任意数目的许可，这可能会增加许可数目以至于超出初始数目。许可不是必须由获取它的线程释放

* 通常，信号量不必直接映射到通用应用场景

### 14.10.2 倒计时门栓`CountDownloadLatch`

* 倒计时门栓让一个线程集等待直到计数变为0

* 倒计时门栓是一次性的。一旦计数为0，就不能再重用了

* 一个有用的特例是计数值为1的门栓。实现一个只能通过一次的门。线程在门外等候直到另一个线程将计数器值置为0

### 14.10.3 障栅`CyclicBarrier`

* `CyclicBarrier`类实现了一个集结点，称为障栅。

* 考虑大量线程运行在一次计算的不同部分的情形。当所有部分都准备好时，需要把结果组合在一起。当一个线程完成了它的那部分任务后，让其运行到障栅处。一旦所有的线程都到达了这个障栅，障栅就撤销，线程就可以继续运行

* 障栅示例代码如下所示↓：
	1. 首先构造一个障栅，并给出参与的线程数
	```Java
	CyclicBarrier barrier = new CyclicBarrier(nthreads);
	```
	2. 每一个线程做一些工作，完成后在障栅上调用`await`：
	```Java
	public void run() {
		doWork();
		barrier.await();
		// ...
	}
	```
	* `await`方法有一个可选的超时参数：`barrier.await(1000, TimeUnit.MILLISECONDS);`

* 如果任何一个在障栅上等待的线程离开了障栅，那么障栅就被破坏了(线程离开可能是以为它调用`await`时设置了超时，或者因为它被中断了)。在这种情况下，所有其他线程的`await`方法抛出`BrokenBarrierException`异常。那些已经在等待的线程立即终止`await`的调用

* 可以提供一个可选的障栅动作，当所有线程到达障栅的时候就会执行这一动作。代码如下所示↓：
	```Java
	Runnable barrierAction = ...;
	CyclicBarrier barrier = new CyclicBarrier(nthreads, barrierAction);
	```

* 障栅被称为是循环的，因为可以在所有等待线程被释放后被重用

* 在这一点上有别于`CountDownLatch`，`CyclicBarrier`只能被使用一次

* `Phaser`类增加了更大的灵活性，允许改变不同阶段中参与线程的个数

### 14.10.4 交换器`Exchanger`

* 当两个线程在同一个数据缓冲区的两个实例上工作的时候，就可以使用交换器

* 典型的情况是，一个线程向缓冲区填入数据，另一个线程消耗这些数据。当它们都完成以后，相互交换缓冲区

### 14.10.5 同步队列`SynchronousQueue`

* 同步队列是一种将生产者与消费者线程配对的机制

* 当一个线程调用`SynchronousQueue`的`put`方法时，它会阻塞直到另一个线程调用`take`方法为止，反之亦然

* 与`Exchanger`的情况不同，数据仅仅沿着一个方向传递，从生产者到消费者

* 即使`SynchronousQueue`类实现了`BlockingQueue`接口，概念上讲，它依然不是一个队列。它没有包含任何元素，它的`size`方法总是返回0

## 14.11 线程与Swing

这一节没看
