- [7. 函数](#7-函数)
	- [7.8 重载函数](#78-重载函数)
		- [7.8.1 重载与作用域](#781-重载与作用域)
		- [7.8.2 函数匹配与实参转换](#782-函数匹配与实参转换)
		- [7.8.3 重载确定的三个步骤](#783-重载确定的三个步骤)
		- [7.8.4 实参类型转换](#784-实参类型转换)
	- [7.9 指向函数的指针](#79-指向函数的指针)
- [9. 顺序容器](#9-顺序容器)
	- [9.1 顺序容器的定义](#91-顺序容器的定义)
	- [9.2 迭代器和迭代器范围](#92-迭代器和迭代器范围)
	- [9.3 顺序容器的操作](#93-顺序容器的操作)
		- [9.3.1 容器定义的类型别名](#931-容器定义的类型别名)
		- [9.3.2 beign() & end()](#932-beign--end)
		- [9.3.3 添加元素](#933-添加元素)
		- [9.3.4 关系操作符](#934-关系操作符)
		- [9.3.5 容器大小的操作](#935-容器大小的操作)
		- [9.3.6 访问元素](#936-访问元素)
		- [9.3.7 删除元素](#937-删除元素)
		- [9.3.8 赋值与swap](#938-赋值与swap)
	- [9.4 vector容器的自增长](#94-vector容器的自增长)
	- [9.5 容器的选用](#95-容器的选用)
	- [9.6 再谈string类型](#96-再谈string类型)
		- [9.6.1 构造方法](#961-构造方法)
		- [9.6.2 修改string对象的其他方法](#962-修改string对象的其他方法)
		- [9.6.3 substr、append和replace操作](#963-substrappend和replace操作)
		- [9.6.4 string类型的查找操作](#964-string类型的查找操作)
		- [9.6.5 string对象的比较](#965-string对象的比较)
	- [9.7 容器适配器](#97-容器适配器)
		- [9.7.1 栈适配器](#971-栈适配器)
		- [9.7.2 队列和优先队列](#972-队列和优先队列)
- [10. 关联容器](#10-关联容器)
	- [10.1 pair类型](#101-pair类型)
	- [10.2 关联容器](#102-关联容器)
	- [10.3 map类型](#103-map类型)
		- [10.3.1 map对象的定义](#1031-map对象的定义)
		- [10.3.2 map定义的类型](#1032-map定义的类型)
		- [10.3.3 给map添加元素](#1033-给map添加元素)
		- [10.3.4 使用下标访问map对象](#1034-使用下标访问map对象)
		- [10.3.5 insert函数](#1035-insert函数)
		- [10.3.6 查找并读取map中的元素](#1036-查找并读取map中的元素)
		- [10.3.7 从map对象中删除元素](#1037-从map对象中删除元素)
		- [10.3.8 map对象的迭代遍历](#1038-map对象的迭代遍历)
	- [10.4 set类型](#104-set类型)
	- [10.5 multimap和multiset类型](#105-multimap和multiset类型)
		- [10.5.1 元素的添加和删除](#1051-元素的添加和删除)
		- [10.5.2 在multimap和multiset中查找元素](#1052-在multimap和multiset中查找元素)
- [11. 泛型算法](#11-泛型算法)
	- [11.1 概述](#111-概述)
	- [11.2 初窥算法](#112-初窥算法)
	- [11.3 再谈迭代器](#113-再谈迭代器)
		- [11.3.1 插入迭代器](#1131-插入迭代器)
		- [11.3.2 iostream迭代器](#1132-iostream迭代器)
		- [11.3.3 反向迭代器](#1133-反向迭代器)
		- [11.3.4 const迭代器](#1134-const迭代器)
		- [11.3.5 五种迭代器](#1135-五种迭代器)
	- [11.4 泛型算法的结构](#114-泛型算法的结构)
		- [11.4.1 算法的形参模式](#1141-算法的形参模式)
		- [11.4.2 算法的命名规范](#1142-算法的命名规范)
		- [11.5 list容器特有的算法](#115-list容器特有的算法)
- [13. 复制控制](#13-复制控制)
	- [13.1 复制构造函数](#131-复制构造函数)
	- [13.2 赋值操作符](#132-赋值操作符)
	- [13.3 析构函数](#133-析构函数)
- [15. 面向对象编程](#15-面向对象编程)
	- [15.2 定义基类和派生类](#152-定义基类和派生类)
	- [15.5 继承情况下的类作用域](#155-继承情况下的类作用域)
	- [15.6 纯虚函数](#156-纯虚函数)
- [16. 模板与泛型编程](#16-模板与泛型编程)
	- [16.1 模板定义](#161-模板定义)
		- [16.1.1 定义模板函数](#1611-定义模板函数)
		- [16.1.2 定义类模板](#1612-定义类模板)
		- [16.1.3 模板形参](#1613-模板形参)
		- [16.1.4 模板类型形参](#1614-模板类型形参)
		- [16.1.5 非类型模板形参](#1615-非类型模板形参)
		- [16.1.6 编写泛型程序](#1616-编写泛型程序)
		- [16.1.7 编译模板时的错误](#1617-编译模板时的错误)
	- [16.2 实例化](#162-实例化)
		- [16.2.1 模板实参推断](#1621-模板实参推断)
	- [16.3 模板编译模型](#163-模板编译模型)
	- [16.4 类模板成员](#164-类模板成员)
	- [16.5 一个泛型句柄类](#165-一个泛型句柄类)
		- [16.5.1 定义句柄类](#1651-定义句柄类)
		- [16.5.2 使用句柄类](#1652-使用句柄类)
	- [16.6 模板特化](#166-模板特化)
	- [16.7 重载与函数模板](#167-重载与函数模板)
- [17. 用于大型程序的工具](#17-用于大型程序的工具)
	- [17.1 异常处理](#171-异常处理)
		- [17.1.9 auto_ptr类](#1719-auto_ptr类)
- [18. 特殊工具与技术](#18-特殊工具与技术)
	- [18.1 优化内存分配](#181-优化内存分配)
		- [18.1.2 allocator类](#1812-allocator类)
		- [18.1.7 一个内存分配器基类](#1817-一个内存分配器基类)

# 7. 函数

## 7.8 重载函数

重载函数定义：出现在相同作用域中的两个函数，具有相同的名字而形参表不同

注意：任何程序都仅有一个`main`函数的实例，`main`函数不能重载

* 函数重载和重复声明的区别

	1. 如果两个函数声明的返回类型和形参表完全匹配，则将第二个函数声明视为第一个的重复声明

	2. 如果两个函数的形参表完全相同，但返回类型不同，则第二个声明是错误的

	3. 函数不能仅仅基于不同的返回类型而实现重载

	4. 函数参数有默认值和没有默认值是等价的

	5. 形参与const形参是等价的(因为形参是拷贝副本)，但是const引用形参与非const引用形参不等价，指向const类型的指针形参与指向非const类型的指针形参不等价

### 7.8.1 重载与作用域

一般的作用域规则：在函数中局部声明的名字将屏蔽在全局作用域内声明的同名名字

一般的作用域规则同样适用于重载函数名。如果局部地声明一个函数，则该函数将屏蔽而不是重载在外层作用域中声明的同名函数。因此每一个版本的重载函数都应在同一个作用域中声明

在C++中，首先进行函数名字查找，然后进行参数类型检查

### 7.8.2 函数匹配与实参转换

**函数重载确定(函数匹配)**：将函数调用与重载函数集合中的一个函数相关联的过程

匹配方法：自动提取函数调用中实际使用的实参与重载集合中各个函数提供的形参作比较，编译器实现该调用与函数的匹配

匹配结果：1、编译器找到与实参**最佳匹配**的函数，并生成调用该函数的代码；2、找不到形参与函数调用的实参匹配的函数，在这种情况下，编译器将给出编译错误信息；3、找到多个与实参匹配的函数，但没有一个是明显的最佳选择，这种情况也是错误的，该调用具有**二义性**

当多个函数的形参具有可通过隐式转换关联起来的类型，则函数匹配将相当灵活

### 7.8.3 重载确定的三个步骤

1. 候选函数

确定该调用所考虑的重载函数集合，该集合中的函数称为**候选函数**。候选函数是与被调函数同名的函数，并且在调用点上，它的声明可见。

2. 选择可行函数

可行函数定义：从候选函数中选择的一个或多个函数，它们能够用该调用中指定的实参来调用。

可行函数要求：1、函数的形参个数与该调用的实参个数相同；2、每一个实参的类型必须与对应形参的类型匹配，或者可被隐式转换为对应的形参类型

注意：如果函数具有默认实参，则调用该函数时，所用的实参可能比实际需要的少。默认实参也是实参，在函数匹配的过程中，它的处理方式与其他实参一样。调用带有默认实参的函数是可忽略这个实参，编译器自动将默认实参的值提供给被忽略的实参。因此某个调用拥有的实参可能比显示给出的多

根据实参个数选出潜在的可行函数后，必须检查实参的类型是否与对应的形参类型匹配。与任意函数调用一样，实参必须与它的形参匹配，它们的类型要么精确匹配，要么实参类型能够转换为形参类型

如果没有找到可行函数，则该调用错误

3. 寻找最佳匹配(如果有的话)

确定与函数调用中使用的实际参数匹配最佳的可行函数。这个过程考虑函数调用中的每一个实参，选择对应形参与之最匹配的一个或多个可行函数。这里所谓"最佳"的细节将在下一节中解释，其原则是实参类型与形参类型越接近则匹配越佳。因此，实参类型与形参类型之间的精确类型匹配比需要转换的匹配好

4. 含有多个形参的重载确定

如果函数调用使用了两个或两个以上的显式形参，则函数匹配会更加复杂。编译器将选出形参个数和类型都与实参匹配的函数。接下来，编译器通过依次检查每一个实参来决定哪个或哪些函数匹配最佳

如果有且仅有一个函数满足下列条件，则匹配成功：1、其每个实参的匹配都不劣于其他可行函数需要的匹配；2、至少有一个实参的匹配优于其他可行函数提供的匹配。

如果在检查了所有实参后，仍找不到唯一最佳匹配函数，则该调用错误。编译器将提示该调用具有二义性。解决这样的二义性，可通过显式的强制类型转换强制函数匹配。但是在实际应用中，调用重载函数时应尽量避免对实参做强制类型转换，需要使用强制类型转换意味着所设计的形参集合不合理

### 7.8.4 实参类型转换

为了确定最佳匹配，编译器将实参类型到相应类型的转换划分等级。转换等级如下↓：

1. 精确匹配：实参与形参类型相同

2. 通过类型提升实现的匹配，类型提升如下所示↓：

	* 所有比`int`小的整型，包括`char`、`signed char`、`unsigned char`、`short`和`unsigned short`，如果该类型的所有可能的值都能包容在`int`内，它们就会被提升为`int`，否则将被提升为`unsigned int`

	* 有符号与无符号类型之间的转换：转换规则需保护操作数的精度，`unsigned`操作数的转换依赖于机器中整型的相对大小，因此这类转换本质上依赖于机器。但是注意，如果在比较`signed int`和`unsigned int`时， `signed int`会直接转换为`unsigned int`

3. 通过标准转换实现的匹配

4. 通过类类型转换实现的匹配

* 需要类型提升或转换的匹配

* 参数匹配和枚举类型

* 重载和const形参

## 7.9 指向函数的指针

# 9. 顺序容器

|顺序容器类型|说明|
|:-:|:-:|
|顺序容器||
|vector|支持快速随机访问|
|list|支持快速插入/删除|
|deque|双端队列，支持快速随机访问|
|顺序容器适配器||
|stack|先进后出(FILO)栈|
|queue|先进先出(FIFO)队列|
|priority_queue|有优先级管理的队列|

## 9.1 顺序容器的定义

头文件↓：
```C++
#include <vector>
#include <list>
#include <deque>
```

构造函数↓：
```C++
C<T> c;     // 创建空容器，C为容器类型名，T为元素类型，c为容器变量名
C c(c2);    // 创建容器c2的副本
C c(b, e);  // 创建c，元素是迭代器b和e标示的范围内元素的副本
C c(n, t);  // 用n个值为t的元素创建容器c(只适用于顺序容器)
C c(n);     // 创建有n个值初始化元素的容器c
```

## 9.2 迭代器和迭代器范围

迭代器定义↓：
```C++
vector<int>::iterator iter = ivec.begin();    // 返回当前容器中起始元素的迭代器
vector<int>::iterator iter = ivec.end();      // 返回当前容器中末尾元素的迭代器

int iter = ivec.front();   // 返回当前容器中起始元素的引用
int iter = ivec.back();    // 返回当前容器中末尾元素的引用
```

常用迭代器运算↓：
```C++
*iter;  // 返回迭代器iter所指向元素的引用
iter->mem;  // 对iter进行解引用，获取指定元素中名为mem的成员，等效于(*iter).mem
++iter; iter++; // 使iter指向容器里的下一个元素
--iter; iter--; // 使iter指向容器里的前一个元素
iter1 == iter2; iter1 != iter2; // 比较两个迭代器是否相等，当两个迭代器指向相同位置时相等
```

vector和deque类型迭代器支持的操作↓：
```C++
iter - n; iter + n; // 产生指向容器前/后第n个元素的迭代器(必须还在容器范围内)
iter1 += iter2; iter1 -= iter2; // 将iter1加上或减去iter2的运算结果赋给iter1
iter1 - iter2;  //两个迭代器相差的位置间隔
>, <=, <, <=;   // 比较同一个容器中两个迭代器的位置关系
```

## 9.3 顺序容器的操作

### 9.3.1 容器定义的类型别名

|容器定义的类型别名|说明|
|:-:|:-:|
|size_type|无符号整型，足以存储容器最大可能长度|
|iterator|迭代器|
|const_iterator|只读迭代器|
|reverse_iterator|逆序迭代器|
|const_reverse_iterator|只读逆序迭代器|
|difference_type|足够存储两个迭代器差值的有符号整型|
|value_type|元素类型|
|reference|元素的左值类型，等价于value_type&|
|const_reference|元素的常量左值类型，等价于const value_type&|

### 9.3.2 beign() & end()

返回迭代器↓：
```C++
iterator c.begin();  //顺序迭代器，指向第一个元素
iterator c.end();    //顺序迭代器，指定最后一个元素的下一位置
iterator c.rbegin(); //逆序迭代器，指向容器的最后一个元素
iterator c.rend();   //逆序迭代器，指向容器第一个元素前面的位置
```

### 9.3.3 添加元素

在顺序容器中添加元素↓：
```C++
void c.push_back(t); // 在容器尾部添加元素t，返回void
void c.push_front(t);    // 在容器前端添加元素t，返回void(只适用于list和deque)
iterator c.insert(p, t); // 在迭代器p所指向的元素前面插入元素t(即新元素t将占据p原来所指向的位置)，返回指向新添加元素的迭代器
void c.insert(p, n, t);  // 在迭代器p所指向的元素前面插入n个元素t，返回void类型
void c.insert(p, b, e);  // 在迭代器p所指向的元素前面插入由迭代器b和e标记的范围内的元素，返回void类型
```

向容器内添加元素或使用元素初始化新容器时，是将元素值复制到容器里

### 9.3.4 关系操作符

比较的容器必须具有相同的容器类型，而且其元素类型也必须相同

容器的比较是基于容器内元素的比较

### 9.3.5 容器大小的操作

有关容器大小的操作↓：
```C++
c.size();   // 返回容器c中的元素个数
c.max_size();   // 返回容器c可容纳的最多元素个数
c.empty();  // 返回容器大小是否为0
c.resize(n);    // 调整容器c的大小，使其能容纳n个元素
// 如果n<c.size()，则不会对容器进行操作，而是直接返回
// 如果n>c.size()，采用值初始化的元素
c.resize(n, t); // 调整容器c的大小，使其能容纳n个元素，所有新添加的元素值都为t
```

### 9.3.6 访问元素

访问顺序容器内元素的操作↓：
```C++
c.front(); *c.begin();  // 返回容器c的第一个元素的引用

c.back(); *--c.end();   // 返回容器c的最后一个元素的引用

c[n];   // 返回下标为n的元素的引用(只适用于vector和deque)
c.at(n);    // 返回下标为n的元素的引用(只适用于vector和deque)
```

当使用的下标n无效时，`c[n]`行为未定义，
`c.at(n)`将会抛出out_of_range异常

### 9.3.7 删除元素

删除顺序容器内元素的操作↓：
```C++
iterator c.erase(p);
// 删除迭代器p所指向的元素，返回一个迭代器，指向被删除元素后面的元素
// 如果p指向c.end()则函数未定义

iterator c.erase(b, e);
// 删除迭代器b和e所标记的范围内的所有的元素，返回一个迭代器指向被删除元素后面的元素
// 如果e指向c.end()，则返回c.end()

void c.clear(); // 删除容器c内的所有元素
void c.pop_back();  // 删除容器c的最后一个元素
void c.pop_front(); // 删除容器c的第一个元素(只适用于list和deque)
```

### 9.3.8 赋值与swap

顺序容器的赋值操作↓：
```C++
c1 = c2;    // 删除容器c1的所有元素，然后将c2的元素复制并插入到c1

c1.swap(c2);
// 调用完函数后，c1中存放的是c2原来的元素，c2中存放的是c1中原来的元素
// 迭代器仍指向相同的元素，速度比复制操作快，容器和元素类型必须相同

c.assign(b, e);
// 重新设置c的元素，将迭代器b和e标记的范围内的元素复制到c中
// b和e必须不是指向c中元素的迭代器

c.assign(n, t); // 将容器c重新设置为存储n个值为t的元素
```

与复制容器元素的构造函数一样，如果容器类型相同，元素类型也相同，则可以使用赋值操作符(=)或assign函数赋值。如果容器类型相同/不同，元素类型不同但是相互兼容，则赋值运算必须使用assign函数。

assign函数首先删除容器中所有的元素，然后将其参数指定的新元素插入到该容器中

## 9.4 vector容器的自增长

vector容器的元素以连续的方式存放，list容器的元素不连续存储。

vector处理内存分配函数↓：
```C++
c.capacity(); // 获取在vector容器需要分配更多的存储空间之前能够存储的元素总数
c.reserve(n); // 设置vector容器预留n个元素的存储空间
```

只要有剩余的容量，vector就不必为其元素重新分配存储空间

## 9.5 容器的选用

vector容器的元素连续存放，支持随机访问，insert与erase则慢

list容器的元素不连续存放，可高效insert与erase，但是不支持随机访问，只能遍历访问

deque容器支持随机访问，在队列的两端高效insert与erase，但是在容器中间insert与erase效率低。在首尾insert元素不会使迭代器失效，在首尾erase元素会使指向被删除元素的迭代器失效，在任何其他位置insert或erase元素会使所有迭代器失效

如果只需在读取输入时在容器的中间位置插入元素，然后需要随机访问元素，则可考虑在输入时将元素读入到一个list容器，接着对此容器重新排序，使其适合顺序访问，然后将排序后的list容器复制到个vector容器。

## 9.6 再谈string类型

支持的string操作↓：
```C++
is >> s;  // 从输入流is中读取一个以空白字符分隔的字符串
getline(is, s); // 从输入流is中读取一行字符，写入s
os << s;  // 将s写到输出流os中

s1 + s2;  // 将s1和s2串接起来，产生一个新的string对象
// 关系操作符: (==和!=)以及关系运算(<、<=、>和>=)等效于(区分大小写的)字典次序的比较
```

string支持的容器操作↓：

[9.3.1 容器定义的类型别名](#931-容器定义的类型别名)列出的typedef操作，包括迭代器类型

[9.1 顺序容器的定义](#91-顺序容器的定义)列出的容器构造函数，但是不包括只需一个长度参数的构造函数

[9.3.3 添加元素](#933-添加元素)列出的vector容器所提供的添加元素的操作(无论vector容器还是string类型都不支持push_front操作)

[9.3.5 容器大小的操作](#935-容器大小的操作)列出的长度操作

[9.3.6 访问元素](#936-访问元素)列出的下标和at操作；但string类型不提供该表列出的back或front操作

[9.3.2 beign() & end()](#932-beign--end)列出的begin和end操作

[9.3.7 删除元素](#937-删除元素)列出的erase和clear操作;但string类型不提供pop_back或pop_front操作

[9.3.8 赋值与swap](#938-赋值与swap)列出的赋值操作

与vector容器的元素一样，string的字符也是连续存储的。因此，string类型支持[9.4 vector容器的自增长](#94-vector容器的自增长)描述的capacity和reserve操作。

### 9.6.1 构造方法

构造string对象的方法↓：
```C++
string s; // 空string对象s

string s(cp); // 用cp所指向的(以空字符null结束的)C风格字符串初始化
string s(cp, n);  // 初始化为cp所指向数组的前n个元素的副本
// (可以不用空字符结尾，计数器的值必须小于数组长度)

string s(s2); // 初始化为s2的副本
string s(s2, pos2);
// 初始化为s2中从下标pos2开始的字符的副本(如果pos2>s2.size()，则该操作未定义)
string s(s2, pos2, len2);
// 初始化为s2中从下标pos2开始的len2个字符的副本
// (如果pos2>s2.size()，则该操作未定义，最多只能复制s2.size()-pos2个字符)
```

### 9.6.2 修改string对象的其他方法

与容器共有的string操作↓：
```C++
iterator s.insert(p, t);  // 在迭代器p前插入元素t，返回指向新插入元素的迭代器
void s.insert(p, n, t); // 在迭代器p前插入n个值为t的元素
void s.insert(p, b, e); //在迭代器p指向的元素之前插入迭代器b和e标记范围内所有的元素

s.assign(b, e); // 用迭代器b和e标记范围内的元素替换s，对于string类型返回s，对容器类型返回void
s.assign(n, t); // 用值为t的n个副本替换s，对于string类型返回s，对容器类型返回void

iterator s.erase(p);
// 删除迭代器指向的元素，返回一个迭代器，指向被删除元素后面的元素
itorator s.erase(b, e);
// 删除迭代器b和e标记范围内所有的元素，返回一个迭代器，指向被删除元素段后面的第一个元素
```

string类型特有的版本↓：
```C++
// 除特殊声明，以下所有操作都返回s的引用
s.insert(pos, n, c);  // 在下标为pos的元素之前插入n个字符c
s.insert(pos,s2); // 在下标为pos的元素之前插入string对象s2的副本
s.insert(pos, s2, pos2, len); // 在下标为pos的元素之前插入s2中从下标pos2开始的len个字符

s.insert(pos, cp);  // 在下标为pos的元素之前插入cp所指向的以空字符结束的字符串副本
s.insert(pos, cp, len); // 在下标为pos的元素之前插入cp所指向数组的前len个字符

s.assign(s2); // 用s2的副本替换s
s.assign(s2, pos2, len);  // 用s2中从下标pos2开始的len个字符副本替换s
s.assign(cp); // 用cp所指向的以空字符结束的字符串副本替换s
s.assign(cp, len);  // 用cp所指向数组的前len个字符副本替换s

s.erase(pos,len); // 删除从下标pos开始的len个字符
```

### 9.6.3 substr、append和replace操作

substr函数↓：
```C++
// 返回当前string对象的子串
string s.substr(pos, n);  // 包含s中从下标pos开始的n个字符
string s.substr(pos); // 包含从下标pos开始到s末尾的所有字符
string s.substr();  // 返回s的副本
```

append与replace函数↓：
```C++
string s.append(args);  // 将args串接在s后面，返回s的引用
string s.replace(pos, len, args);
// 删除s中从下标pos开始的len个字符，用args指定的字符替换，返回s的引用
// (在这个版本中，args不能为b2, e2)
string s.replace(b, e, args);
// 删除迭代器b和e标记的范围内所有的字符，用args替换，返回s的引用
// (在这个版本中，args不能为s2, pos2, len2)
```

append和replace操作的参数：args

|args|说明|
|:-:|:-:|
|s2|string类型字符串s2|
|s2, pos2, len2|字符串s2中从下标pos2开始的len2个字符|
|cp|指针cp指向以空字符串结束的数组|
|cp, len2|ce指向的以空字符结束的数组中前len2个字符|
|n, c|n个字符c的副本|
|b2, e2|迭代器b2和e2标记的范围内所有字符|

可将replace视为删除一些字符然后在同一位置插入其他内容的捷径(删除的字符串与插入的字符串不一定需要长度相同)

```C++
s.replace(pos, len, args);
// 等价于
s.erase(pos, len);
s.insert(pos, args);
```

### 9.6.4 string类型的查找操作

查找操作都返回string::size_type类型的值，以下标形式标记查找匹配所发生的位置；或者返回一个名为string::npos的特殊值，说明查找没有匹配。string将npos定义为保证大于任何有效下标的值

string类型的查找操作↓：
```C++
s.find(args); // 在s中查找args的第一次出现
s.rfind(args);  // 在s中查找args的最后一次出现
s.find_first_of(args);  // 在s中查找args的任意字符的第一次出现
s.find_last_of(args);	// 在s中查找args的任意字符的最后一次出现
s.find_first_not_of(args);	// 在s中查找第一个不属于args的字符
s.find_last_not_of(args);	// 在s中查找最后一个不属于args的字符
```

string类型提供的find操作的参数↓：

|参数|说明|
|:-:|:-:|
|c, pos|从下标pos标记的位置开始，查找字符c(pos默认0)|
|s2, pos|从下标pos标记的位置开始，查找string对象s2(pos默认0)|
|cp, pos|从下标pos标记的位置开始，查找指针cp所指向的以空字符结束的C风格字符串(pos默认0)|
|cp, pos, n|从下标pos标记的位置开始，查找指针cp所指向数组的前n个字符(pos和n都没有默认值)|

### 9.6.5 string对象的比较

string对象采用字典顺序比较。对于两个string对象，关系操作符逐个字符地进行比较，直到比较到某个位置上，两个string对象对应的字符不相同为止。如果两个string对象长度不相同，并且一个string对象是另一个string对象的子串，则较短的string对象<较长的string对象

string类型的compare函数↓：
```C++
s.compare(s2);  // 比较s和s2
s.compare(pos1, n1, s2);    // s中从pos开始的n1个字符与s2比较
s.compare(pos1, n1, s2, pos2, n2);  // s中从pos1开始的n1个字符与s2中从pos2开始的n2个字符比较
s.compare(cp);  // 比较s和cp所指向的以空字符结束的字符串
s.compare(pos1, n1, cp);    // s中从pos1开始的n1个字符与cp所指向的字符串比较
s.compare(pos1, n1, cp, n2);    // s中从pos1开始的n1个字符与cp所指向字符串的前n2个字符比较
```

conpare函数返回值(s1 - args)：
* 正数：s1 > args
* 负数：s1 < args
* 0：s1 == args

## 9.7 容器适配器

容器适配器通用的操作和类型↓：
|操作和类型|说明|
|:-:|:-:|
|size_type|一种类型，足以存储此适配器类型最大对象的长度|
|value_type|元素类型|
|container_type|基础容器类型，适配器在此容器类型上实现|
|`A a;`|创建一个新的空适配器|
|`A a(c)`|创建一个新的空适配器，初始化为容器c的副本|
|关系操作符|所有适配器支持全部关系操作符(==、!=、<、<=、>、>=)|

使用适配器时，必须包含相关的头文件
```C++
#include <stack>    // stack
#include <queue>    // queue与priority_queue
```

对于给定的适配器，其元素也可以是基础容器；stack适配器所关联的基础容器可以是任意一种顺序容器类型(vector、list、deque)；queue适配器要求其关联的基础容器必须提供push_front运算，因此只能建立在list容器上；priority_queue适配器要求提供随机访问功能，因此可建立在vector或deque容器上。

适配器的关系运算由元素依次比较来实现，第一对不相等的元素将决定两者之间的小于或大于关系

### 9.7.1 栈适配器

栈适配器支持的操作↓：
```C++
s.enpty();  // 检测栈是否为空
s.size();   // 返回栈中元素的个数
s.pop();    // 删除栈顶元素，但不返回其值
s.top();    // 返回栈顶元素的值，但不删除该元素
s.push(item);   // 在栈顶压入新元素
```

### 9.7.2 队列和优先队列

优先队列priority_queue允许用户为队列中存储的元素设置优先级，将新元素放在比它优先级低的元素前面。标准库默认使用元素类型的`<`操作符来确定他们之间的优先级关系

```C++
q.empty();  // 检测队列是否为空
q.size();   // 返回队列中元素的个数
q.pop();    // 删除队首元素，但不返回其值

q.front();  // 返回队首元素的值，但不删除该元素(只适用于队列)
q.back();   // 返回队尾元素的值，但不删除该元素(只适用于队列)
q.top();    // 返回具有最高优先级的元素值，但不删除该元素(只适用于队列)
q.push(item);
// queue：在队尾压入一个新元素
// priority_queue：基于优先级的适当位置插入新元素
```

# 10. 关联容器

## 10.1 pair类型

定义在`<utility>`头文件中

pair类型提供的操作↓：
```C++
pair<T1, T2> p1;  // 创建新的pair对象，两个元素分别为T1和T2类型，采用值初始化
pair<T1, T2> p1(v1, v2);  // first成员初始化为v1，second成员初始化为v2

make_pair(v1, v2);  // 用v1和v2创建一个新的pair对象，元素类型分别是v1和v2的类型，返回pair类型

p1 < p2;  // 两个pair对象之间的<运算，遵循字典次序
// p1.first < p2.first 或者 !(p1.first < p2.first) && p1.second < p2.second，则返回true
p1 == p2; // 如果两个pair对象的first和second成员依次相等，则这两个对象相等

p.frist;  // 返回p中名为first的(公有)数据成员
p.second;  // 返回p中名为second的(公有)数据成员
```

## 10.2 关联容器

关联容器共享大部分的顺序容器操作，不提供front、push_front、back、push_back以及pop_back操作

构造函数↓：
```C++
C<T> c;     // 创建空容器，C为容器类型名，T为元素类型，c为容器变量名
C c(c2);    // 创建容器c2的副本
C c(b, e);  // 创建c，元素是迭代器b和e标示的范围内元素的副本
```

[9.3.2 beign() & end()](#932-beign--end)列出的begin和end操作

[9.3.1 容器定义的类型别名](#931-容器定义的类型别名)列出的typedef操作，包括迭代器类型(对map容器，value_map并非元素的类型，而是描述键及其关联值类型的pair类型，详见[10.3.2 map定义的类型](#1032-map定义的类型))

[9.3.4 关系操作符](#934-关系操作符)描述的关系运算

[9.3.5 容器大小的操作](#935-容器大小的操作)列出的关于容器大小的操作，但resize函数不能用于关联容器

[9.3.7 删除元素](#937-删除元素)列出的erase和clear操作，但关联容器的erase运算返回void类型


[9.3.8 赋值与swap](#938-赋值与swap)描述的clear和erase操作，但关联容器不提供assign函数

## 10.3 map类型

### 10.3.1 map对象的定义

map的构造函数↓：
```C++
map<K,V> m; // 创建一个空的map对象m，键和值得类型分别为K和V
map<K,V> m(m2); // 创建m2的副本m，m与m2必须由相同的键和值得类型
map<K,V> m(b,e);
// 创建map类型m，存储迭代器b和e标记的范围内所有元素的副本
// 元素的类型必须能转换为pair<const K, V>
```

键必须有一个相关的比较函数，比较函数必须在键类型上定义严格弱排序，即键类型数据必须支持`<`关系，如果两个键之间都不存在小于关系，则容器将之视为相同的键

### 10.3.2 map定义的类型

map类定义的类型↓：
|类型|说明|
|:-:|:-:|
|map<K,V>::key_type|在map容器中，用作索引的键的类型|
|map<K,V>::mapped_type|在map容器中，键所关联的值的类型|
|map<K,V>::value_type|一个pair类型，first元素具有const map<K,V>::key_type类型，而second元素则为map<K,V>::mapped_type类型|

对迭代器进行解引用时，将获得一个引用，指向容器中一个value_type类型的值，对于map容器，其value_type是pair类型

### 10.3.3 给map添加元素

可使用insert成员实现，或者先用下标操作符获取元素，然后给获取的元素赋值

一个给定的键只能对应于一个元素

### 10.3.4 使用下标访问map对象

```C++
map<string, int> w;
w['a'] = 1;
```

以上程序将发生：
1. 在w中查找键为'a'的元素，没有找到
2. 将一个新的键值对插入到w中，键是const string对象，保存'a'，值则采用值初始化，在本例中为0
3. 将这个新的键值对插入到w中
4. 读取新插入的元素，并将它的值赋为1

使用下标访问map容器中的元素，如果键存在于容器中，则与vector下标运算行为相同，返回该键所关联的值。如果键不存在将导致在map容器中添加一个新的元素，它的键即为该下标值，值采用值初始化，然后将新插入的元素赋值

下标操作符返回的类型是左值

### 10.3.5 insert函数

map容器提供的insert操作↓：
```C++
pair<K, bool> m.insert(e);
// e是一个用在m上的value_type类型的值
// 如果键(e.first)不在m中，则插入一个值为e.second的新元素
// 如果该键在m中已存在，则保持m不变
// 返回一个pair类型对象,包含指向键为e.first的元素的map迭代器
// 以及一个bool类型的对象，表示是否插入了该元素

void m.insert(beg, end);
// beg和end是标记元素范围的迭代器，其中的元素必须为m.value_type类型的键值对
// 对于该范围内的所有元素，如果它的键在m中不存在，则将该键及其关联的值插入到m

iterator m.insert(iter, e);
// e是一个用在m上的value_type类型的值
// 如果键(e.first)不在m中，则创建新元素，并以迭代器iter为起点搜索新元素存储的位置
// 返回一个迭代器，指向m中具有给定键的元素
```

使用insert成员函数可以避免使用下标操作符带来的不必要的初始化

### 10.3.6 查找并读取map中的元素

不修改map对象的查询操作↓：
```C++
m.count(k); // 返回m中k的出现次数(0或1)
m.find(k);
// 如果m容器中存在按k索引的元素，则返回指向该容器的迭代器
// 如果不存在，则返回超出末端迭代器
```

### 10.3.7 从map对象中删除元素

从map对象中删除元素↓:
```C++
size_type m.erase(k); // 删除m中键为k的元素，返回删除的元素个数(0或1)
void m.erase(p);  // 从m中删除迭代器p所指向的元素(p必须指向m中的元素且不能为m.end())
void m.erase(b, e); // 从m中删除由迭代器b和e所标记的范围内的元素(b和e必须指向m中的元素且b<=e)
```

### 10.3.8 map对象的迭代遍历

对迭代器进行解引用时，将获得一个引用，指向容器中一个value_type类型的值，对于map容器，其value_type是pair类型。first元素具有const map<K,V>::key_type类型，而second元素则为map<K,V>::mapped_type类型

## 10.4 set类型

set容器支持大部分的map操作

[10.2 关联容器](#102-关联容器)列出的所有通用的容器操作

[10.3.1 map对象的定义](#1031-map对象的定义)列出的构造函数

[10.3.5 insert函数](#1035-insert函数)列出的insert操作。带有一个键的insert版本返回pair类型对象，包含一个迭代器和一个bool值。迭代器指向拥有该键的元素，bool值表明是否添加了元素。使用迭代器对的insert版本返回void类型

[10.3.6 查找并读取map中的元素](#1036-查找并读取map中的元素)列出的count和find操作

[10.3.7 从map对象中删除元素](#1037-从map对象中删除元素)列出的erase操作

但set不支持下标操作符，并且没有定义mapped_type类型。在set容器中国，value_type不是pair类型，而是与key_type相同的类型。它们都是set中存储的元素类型。

与map一样，set中的键也为const，获得迭代器之后，只能对其做读操作，不能做写操作

## 10.5 multimap和multiset类型

multimap和multiset所支持的操作分别与map和set的操作相同，但是multimap不支持下标运算，

### 10.5.1 元素的添加和删除

[10.3.5 insert函数](#1035-insert函数)列出的insert操作和[10.3.7 从map对象中删除元素](#1037-从map对象中删除元素)列出的erase操作同样适用于multimap以及multiset容器，实现元素的添加和删除

multiset的insert操作，如果插入的是相同的元素，则会插入到multiset中已有的相同元素后面的位置

由于键不要求是唯一的，因此每次调用insert都会添加一个元素

带有一个键参数的erase版本将删除拥有该键的所有元素，并返回删除元素的个数。而带有一个或一对迭代器参数的版本只删除指定的元素，并返回void类型

### 10.5.2 在multimap和multiset中查找元素

关联容器map和set的元素是按顺序存储的，而multimap和multiset也一样，因此在multimap和multiset容器中，如果某个键对应多个实例，则这些实例在容器中将相邻存放

1. 使用find和count操作

count函数求出某键出现的次数

find函数返回一个迭代器，指向第一个拥有正在查找键的实例

2. 面向迭代器的解决方案

返回迭代器的关联容器操作↓：
```C++
iterator m.lower_bound(k);  // 返回一个迭代器，指向键>=k的第一个元素
iterator m.upper_bound(k);  // 返回一个迭代器，指向键>k的第一个元素
pair<iterator, iterator> m.equal_range(k);
// 返回一个迭代器的pair对象
// 它的first成员等价于m.lower_bound(k)
// 它的second成员等价于m.upper_bound(k)
```

以上操作适用于所有的关联容器

在同一个键上调用lower_bound和upper_bound，将会产生一个迭代器范围，指示出该键所关联的所有元素。如果该键在容器中存在，则会获得两个不同的迭代器：lower_bound返回的迭代器指向该键关联的第一个实例，而upper_bound返回的迭代器则指向最后一个实例的下一位置。如果该键不在multipmap中，这两个操作将返回同一个迭代器，指向依据元素的排列顺序该键应该插入的位置

# 11. 泛型算法

## 11.1 概述

find()函数↓：

```C++
iterator find(b, e, v);
// 检查两个迭代器b和e标记范围内的所有元素
// 如果找到与给定值v相同的元素，则返回指向该元素的迭代器
// 如果没有匹配的元素，则返回第二个迭代器实参e
// b和e也可以使用指针
```

泛型算法本身从不执行容器操作，只是单独依赖迭代器和迭代器操作实现，算法从不直接添加或删除元素

## 11.2 初窥算法

```C++
accumulate(b, e, v);  // 返回迭代器b和e內的元素的值与值v的和
// 容器內的元素类型必须与第三个实参的类型匹配
// 在accumulate，v作为累加的起点

find_first_of(b1, e1, b2, e2);
// 在b1和e1标记的范围內查找第一个出现的匹配b2和e2标记范围內的任意元素
// 返回指向匹配元素的迭代器，沒找到则返回e1
```

## 11.3 再谈迭代器

### 11.3.1 插入迭代器

这类迭代器与容器绑定在一起，实现在容器中插入元素的功能

插入器是一种迭代器适配器，带有一个容器参数，并生成一个迭代器，用于在指定容器中插入元素。通过插入迭代器赋值时，迭代器将会插入一个新的元素。

插入器类型:
* back_inserter：创建使用push_back实现插入的迭代器
* front_inserter：创建使用push_front实现插入的迭代器(只有当容器提供push_front操作时，才能使用front_inserter。在vector或其他没有push_front运算的容器上使用front_inserter，将产生错误)
* inserter：使用insert实现插入操作。(除了所关联的容器外，insert还带有第二个实参：指向插入起始位置的迭代器)

### 11.3.2 iostream迭代器

iostream可与输入或输出流绑定在一起，用于迭代遍历所相关联的IO流

istream_iterator用于读取输入流，ostream_iterator用于写输出流。这些迭代器将它们所对应的流视为特定类型的元素序列。使用流迭代器时，可以用泛型算法从流对象中读数据/将数据写到流对象中

iostream迭代器的构造函数↓：
```C++
istream_iterator<T> in(strm); // 创建从输入流strm中读取T类型对象的istream_iterator对象
istream_iterator<T> in; // istream_iterator对象的超出末端迭代器
ostream_iterator<T> in(strm); // 创建将T类型的对象写到输出流strm的ostream_iterator对象
ostream_iterator<T> in(strm, delim);
// 创建将T类型的对象写到输出流strm的ostream_iterator对象
// 在写入过程中使用delim作为元素的分隔符，delim是以空字符结束的字符数组(C风格字符串)
```

流迭代器只定义了最基本的迭代器操作：自增、解引用和赋值。此外可比较两个istream迭代器时候相等/不等，而ostream迭代器则不提供比较运算。

istream_iterator的操作↓：
```C++
it1 == it2;
it1 != it2;
*it;
it->mem;
++it; it++;
```

ostream_iterator只支持自增、解引用和赋值运算↓：
```C++
++it;
*it;
it = val;
```

任何已定义输入操作符(>>操作符)的类型都可以定义istream_iterator，任何已定义输出操作符(<<操作符)的类型都可以定义ostream_iterator。

### 11.3.3 反向迭代器

所有的容器类型都定义了自己的reverse_iterator类型，由rbegin和rend成员函数返回

反向迭代器是一种反向遍历容器的迭代器，既从最后一个元素到第一个元素遍历容器。

对于反向迭代器，++运算将访问前一个元素，--运算将访问下一个元素

rbrgin成员返回指向容器尾元素的迭代器，rend成员返回指向容器首元素前一位值的反向迭代器

反向迭代器需要使用--或++操作符，所以流迭代器不能创建反向迭代器

riterator.base()指向反向迭代器riterator指向的元素的下一个元素

### 11.3.4 const迭代器

算法要求用于指定范围的两个迭代器必须具有完全一样的类型

### 11.3.5 五种迭代器

迭代器种类↓：
|迭代器种类|说明|
|:-:|:-:|
|输入迭代器|读，不能写；只支持++运算|
|输出迭代器|写，不能读；只支持++运算|
|前向迭代器|读写；只支持++运算|
|双向迭代器|读写；支持++和--运算|
|随机访问迭代器|读写；支持完整的迭代器算术运算；提供在常量时间内访问容器任意位置的功能|

所有标准库容器提供的迭代器都至少达到双向迭代器的要求

## 11.4 泛型算法的结构

### 11.4.1 算法的形参模式

算法形参的含义↓：
```C++
alg(beg, end, other parms);
alg(beg, end, dest, other parms);
alg(beg, end, beg2, other parms);
alg(beg, end, beg2, end2, other parms);
// alg为算法名字，beg和end指定算法操作的元素范围
// 通常将该范围称为算法的输入范围
// dest、beg2、end2均为迭代器
```

dest形参是一个迭代器，用于指定存储输出数据的目标对象，算法假定无论需要写入多少个元素都是安全的

beg2和end2用来指定第二个输入范围，只有beg2而没有end2的算法假定以beg2开始的范围至少与beg和end指定的范围一样大

### 11.4.2 算法的命名规范

检查输入范围内的元素实现算法功能的算法通常用到`==`或`<`，其中大部分算法会提供算法的重载以允许使用比较或测试函数取代操作符的使用

检查指定值的算法默认使用`==`操作符，系统为这类算法提供另外命名的(而非重载的)版本，带有谓词函数形参，不使用重载是因为参数数目相同。带有谓词函数形参的算法，其名字带有后缀`_if`

无论算法是否检查它的元素值，都可能重新排列输入范围内的元素。在默认情况下，这些算法将重新排列的元素写回到其输入范围。标准库也为这些算法提供了另外命名的版本，将元素写到指定的输出目标，此版本的算法在名字中添加了`_copy`后缀

### 11.5 list容器特有的算法

list容器不支持随机访问，因此不能使用需要随机访问迭代器类型的算法，如sort、merge、remove、reverse、unique等

list容器特有的算法↓：
```C++
// 将lst2的元素合并到lst中，这两个list容器对象都必须有序
// lst2中的元素将被删除。合并后，lst2为空
void lst.merge(lst2); // 使用<操作符
void lst.merge(lst2, comp); // 使用comp指定的比较运算

void lst.remove(val);
void lst.remove_if(unaryPred);
// 调用lst.erase删除所有等于指定值或使指定谓词函数返回非零值的元素


lst.reverse();  // 反向排列lst中的元素

lst.sort(); // 对lst中的元素排序

// 以下函数将lst2中的元素移到lst中迭代器iter指向的元素前面。
lst.splice(iter, lst2);
// 将lst2中的所有元素移到lst中，合并后lst2为空
// lst和lst2不能是同一个list对象
lst.splice(iter, lst2, iter2);
// 只移动iter2所指向的对象，这个元素必须是lst2中的元素
// 在这种情况中，lst和lst2可以是同一个list对象
lst.splice(iter, beg, end);
// beg和end指定一个有效的范围，可以标记任意list对象内的范围，包括lst
// 当iter指向beg和end指定的范围内的一个元素时，该运算未定义


// 调用erase删除同一个值的连续副本
lst.unique(); // 使用==操作符判断元素是否相等
lst.unique(binaryPred); // 使用指定的谓词函数实现判断
```

以上不包括要求支持双向或更弱的迭代器类型的泛型算法，这类泛型算法无论是用在list容器上，还是用在其他容器上，都具有相同的成果

对于list对象，应该优先使用list容器特有的成员版本，而不是泛型算法

# 13. 复制控制

## 13.1 复制构造函数

explicit关键字的作用就是防止类构造函数的隐式自动转换

为了防止复制，类必须显式声明其复制构造函数为private,但是此时类的友元和成员扔可以进行复制.如果需要连友元和成员中的复制也禁止,则可以声明一个private复制构造函数但不对其定义

不允许复制的类对象只能作为引用传递给函数或从函数返回,它们也不能用作容器的元素

## 13.2 赋值操作符

一般一个类同时需要或者同时不需要复制构造函数和赋值操作符

## 13.3 析构函数

容器中的元素总是按逆序撤销：首先撤销下标为size()-1的元素，然后是下标为size()-2的元素......直至最后撤销下标为0的元素

如果一个类需要析构函数，则这个类同时需要赋值操作符和复制构造函数

编译器合成的析构函数按照对象创建时的逆序撤销每个非static成员。合成析构函数并不删除指针成员所指向的对象

因为析构函数不能指定形参，所以不能重载析构函数

即使编写了自己的析构函数，合成析构函数仍然会在自己编写的析构函数运行结束后运行


# 15. 面向对象编程

## 15.2 定义基类和派生类

class定义的类默认private继承，成员隐式指定为private

struct定义的类默认public继承，成员隐式指定为public

友元关系不能继承，无论友元关系的哪一端都不能继承

如果基类定义了static成员,则无论从基类派生出了多少个派生类,整个继承层次中只有一个该static成员.一般既可以使用作用域操作符,也可以使用点或箭头成员访问操作符

## 15.5 继承情况下的类作用域

继承层次中确定函数调用:

1. 首先确定进行函数调用的对象、引用或指针的静态类型
2. 在该类中查找函数，如果找不到，就在直接基类中查找，如此循着类的继承链往上找，直到找到该函数或者查找完最后一个类。如果不能在类或其相关基类中找到该名字，则调用是错误的
3. 一旦找到了该名字，就进行常规类型检查，查看如果给定找到的定义，该函数调用是否合法
4. 假定函数调用合法，编译器就生成代码。如果函数是虚函数且通过引用或指针调用，则编译器生成代码以确定根据对象的动态类型运行哪个函数版本，否则，编译器生成代码直接调用函数

## 15.6 纯虚函数

在函数形参表后面写上=0以指定纯虚函数

```C++
double  fuc_name(std::size_t) const = 0;
```

# 16. 模板与泛型编程

泛型编程就是以独立于任何特定类型的方式编写代码。使用泛型程序时，需要提供具体程序实例所操作的类型或值

面向对象编程所依赖的多态性为运行时多态性，泛型编程所依赖的多态性称为编译时多态性或参数式多态性

## 16.1 模板定义

### 16.1.1 定义模板函数

示例如下↓：

```C++
template <typename T> int compare(const T &v1, const T &v2) {
	if (v1 < v2)
		return -1;
	if (v2 < v1)
		return 1;
	return 0;
}
```

1. 模板形参表

模板形参表是用`<>`括住的一个或多个模板形参的列表，不能为空，形参之间以逗号分隔

模板形参可以是表示类型的类型形参，也可以是表示常量表达式的[非类型模板形参](#1615-非类型模板形参)。非类型形参跟在类型说明符(`class`或`typename`)之后声明

2. 使用函数模板

使用函数模板时，编译器会推断哪个模板实参绑定到模板形参，不需要显式指定。一旦编译器确定了实际的模板实参，就称它实例化了函数模板的一个实例。

编译器将确定用什么类型代替每个类型形参，以及用什么值代替每个非类型形参。推导出实际模板实参后，编译器使用实参代替相应的模板形参产生并编译该版本的函数。编译器承担了为我们使用的每种类型而编写函数的单调工作

示例如下↓：

```C++
cout << compare(1, 0) << endl;

string a("hello"), b("world");
cout << compare(a, b) << endl;
```

3. inline函数模板

inline说明符放在模板形参表之后，返回类型之前，函数声明示例如下↓：

```C++
template<typename T> inline T min(const T&, const T&);
```

### 16.1.2 定义类模板

1. 类模板声明示例↓：

```C++
template <typename Type> class Queue {
public:
	Queue();	// 默认构造函数
	Type &front();	// 返回队列头部元素
	const Type &front() const;
	void push(const Type &)	// 向队尾添加元素
	void pop();	// 从队头删除元素
	bool empty() const;	// 返回队列是否为空
private:
	// ...
};
```

2. 使用类模板示例↓：

使用类模板时，必须为模板形参显式指定实参。编译器使用实参来实例化这个类的特定类型版本。实质上，编译器用用户提供的实际特定类型代替Type，重新编写类。

```C++
Queue<int> qi;
Queue<vector<double>> qvd;
Queue<string> qs;
```

### 16.1.3 模板形参

可以给模板形参赋予的唯一含义是区别形参是类型形参还是非类型形参。如果是类型形参，则该形参表示未知类型，如果是非类型形参，则该形参表示未知值

如果希望使用模板形参所表示的类型和值，则使用与对应模板形参相同的名字

1. 模板形参作用域

模板形参的名字可以在声明为模板形参之后直到模板声明或定义的末尾处使用

模板形参遵循常规名字屏蔽规则。与全局作用域中声明的对象、函数或类型同名的模板形参会屏蔽全局名字

2. 使用模板形参名字的限制

用作模板形参的名字不能在模板内部重用，示例如下↓：

```C++
template <typename T> T fun(const T &a, const T &b) {
	typedef double T;	// 错误，不能重新定义T
}
```

这意味着模板形参的名字只能在同一模板形参表中使用一次，但能在不同的模板中重用

3. 模板声明

像其他函数一样，模板可以只声明而不定义，声明必须指出函数或类是一个模板，同一模板的声明和定义中，模板形参的名字不必相同，示例如下↓：

```C++
// 以下两行声明指向同一个定义
template<typename T> T calc(const T&, const T&);
template<typename U> U calc(const U&, const U&);

// 上述声明的定义
template<typename Type> Type calc(const Type& a, const Type& b) {
	// ...
}
```

每个模板类型形参前面必须带上关键字`class`或`typename`，每个非类型形参前面必须带上类型名字，省略关键字或类型说明符是错误的

### 16.1.4 模板类型形参

类型形参由关键字`class`或`typename`后接说明符构成。在模板形参表中，这两个关键字具有相同的含义，都指出后面所接的名字表示一个类型

模板类型形参可作为类型说明符用在模板中的任何地方，与内置类型说明符或类类型说明符的使用方式完全相同。具体而言，它可以用于指定返回类型或函数形参类型以及在函数体中用于变量声明或强制类型转换

1. `typename`与`class`没有区别

`typename`与`class`可以互换使用并且可以在同一模板形参表中使用，但是`typename`是作为标准C++的组成部分加入到C++中的，因此旧的程序更有可能只用关键字`class`

2. 在模板定义内部指定类型

除了定义数据成员或函数成员之外，类还可以定义类型成员。例如，标准库的容器类定义了不同的类型，如`size_type`，使我们能够以独立于机器的方式使用容器。如果要在函数模板内部使用这样的类型，必须告诉编译器正在使用的名字指的是一个类型。必须显式地这样做，因为编译器不能通过检查得知，由类型形参定义的名字何时是一个类型何时是一个值。参考如下代码↓：

```C++
template <typename Parm, class U> Parm fun(Parm *array, U value) {
	Parm::size_type *p;
	// 如果Parm::size_type是一个类型，则这是一个声明
	// 如果Parm::size_type是一个对象，则这是一个乘法
	// (编译器默认size_type为对象)
}
```

在上述代码中，size_type必定是绑定到Parm的那个类型的成员，但不确定size_type是一个类型成员还是一个数据成员，默认情况下，编译器假定这样的名字指定数据成员，而不是类型成员。如果希望编译器将size_type当作类型，则必须显示告诉编译器这样做，代码示例如下↓：

```C++
template <typename Parm, class U> Parm fun(Parm *array, U value) {
	typename Parm::size_type *p;
}
```

通过在成员名前加上关键字`typename`作为前缀，可以告诉编译器将成员当做类型。通过编写`typename Parm::size_type`，指出绑定到Parm的类型的size_type成员是类型的名字。当然这一声明给用来实例化`fun`的类型增加了一个职责：那些类型必须具有名为size_type的成员，而且该成员是一个类型

如果拿不准是否需要以`typename`指明一个名字是一个类型，那么指定它是个好主意。在类型之前指定`typename`没有坏处，因此即使`typename`是不必要的，也没有关系

### 16.1.5 非类型模板形参

在调用函数时非类型模板形参将用值代替，值的类型在模板形参表中指定。模板非类型形参是模板定义内部的常量值，在需要常量表达式的时候，可使用非类型形参(如指定数组长度)。代码示例如下↓：

```C++
// 函数fun是一个含有一个类型模板形参和一个非类型模板形参的函数模板
// 函数本身接受一个形参，该形参是数组的引用
template <class T, size_t N> void array_init(T (&parm)[N]) {
	for (size_t i = 0; i != N; ++i)
		parm[i] = 0;
}

// 当调用array_init时，编译器从数组实参计算非类型形参的值
int x[42];
array_init(x);	// 实例化 array_init(int(&)[42])

double y[10];
array_init(y);	// 实例化 array_init(double(&)[10])
```

* 类型等价性与非类型形参

对模板的非类型形参而言，求值结果相同的表达式将认为是等价的，示例代码如下↓：

```C++
int x[42];
const int sz = 40;
int y[sz + 2];

// 下面两个函数均实例化 array_init(int(&)[42])
array_init(x);
array_init(y);
```

### 16.1.6 编写泛型程序

编写模板时，代码不可能针对特定类型，但模板代码总是要对将使用的类型做一些假设。如下代码↓：

```C++
template <typename T> int compare(const T &v1, const T &v2) {
	if (v1 < v2)
		return -1;
	if (v2 < v1)
		return 1;
	return 0;
}
```

虽然compare函数从技术上说对任意类型都是有效的，但实际上，实例化的版本可能是非法的。产生的程序是否合法，取决于函数中使用的操作以及所用类型支持的操作。直到编译器看见compare调用并且T绑定到一个实际类型时，才知道形参的类型，使用哪个`<`操作符完全取决于实参类型。如果用不支持`<`操作符的对象调用compare，则该调用将是无效的。

在函数模板内部完成的操作限制了可用于实例化该函数的类型，因此编写代码时保证用作函数实参的类型实际上支持所用的任何操作，以及保证在模板使用那些操作的环境中那些操作运行正常

编写模板代码时，对实参类型的要求尽可能少是很有益的

### 16.1.7 编译模板时的错误

一般而言，编译模板时，编译器可能会在三个阶段中标识错误：

1. 编译模板定义本身时。在这个阶段中编译器一般不能发现许多错误，可以检测到诸如漏掉分号或变量名拼写错误一类的语法错误

2. 在编译器见到模板的使用时。在这个阶段，编译器仍没有很多检查可做。对于函数模板的调用，许多编译器只检查实参的数目和类型是否恰当，编译器可以检测到实参太多或太少,也可以检测到假定类型相同的两个实参是否真的类型相同。对于类模板，编译器可以检测提供的模板实参的正确数目

3. 在实例化的时候，只有在这个时候可以发现类型相关的错误。根据编译器管理实例化的方式(将在[16.3 模板编译模型](#163-模板编译模型)讨论)，有可能在链接时报告这些错误

重要的是，要认识到在编译模板定义的时候，对程序是否有效所知不多。类似地，甚至可能会在已经成功编译了使用模板的每个文件之后出现编译错误,只在实例化期间检测错误的情况很少,错误检测可能发生在链接时。

## 16.2 实例化

定义：模板本身不是类或函数。编译器用模板产生指定的类或函数的特定类型版本。产生模板的特定类型实例的过程称为**实例化**

实现阶段：模板在使用时将进行实例化，类模板在引用实际模板类型时实例化，函数模板在调用它或用它对函数指针进行初始化或赋值时实例化

1. 类的实例化

当引用实际模板类类型时，如`Queue<int>`，编译器会通过重新编写`Queue`模板，用类型`int`代替模板形参的每次出现而创建`Queue<int>`类

类模板的每次实例化都会产生一个独立的类类型。为int类型实例化的`Queue`与任意其他`Queue`类型没有关系，对其他`Queue`类型的成员也没有特殊的访问权限

2. 类模板形参是必需的

使用类模板，必须显示指定模板实参。类模板不定义类型，只有特定的实例才定义了类型。特定的实例化是通过提供模板实参与每个模板形参匹配而定义的。模板实参在用`,`分隔并用`<>`括住的列表中指定

3. 函数模板实例化

使用函数模板时，编译器通常会推断模板实参，编译器推断出模板实参类型之后编写模板函数的不同实例

### 16.2.1 模板实参推断

**模板实参推断**：从函数实参确定模板实参的类型和值的过程

1. 多个类型形参的实参必须完全匹配

模板类型形参可以用作一个以上函数形参的类型。在这种情况下，模板类型推断必须为每个对应的函数实参产生相同的模板实参类型。如果推断的类型不匹配，则调用将会出错。代码示例如下↓：

```C++
// 模板函数定义
template<typename T> int compare(const T& v1, const T& v2) {
	if (v1 < v2)
		return -1;
	if (v2 < v1)
		return 1;
	return 0;
}

// 模板函数调用
short s;
compare(s, 1024);	// error
// 无法实例化 compare(short, int)
// 必须是 compare(short, short) 或 compare(int, int)
```

2. 类型形参的实参的受限转换

一般而言，编译器不会转换实参以匹配已有的实例化，相反会产生新的实例。除了产生新的实例化之外，编译器只会执行两种转换：

1、const转换：接受const引用或const指针的函数可以分别用非const对象的引用或指针来调用，无须产生新的实例化。如果函数接收非引用类型，形参类型和实参都忽略const，即无论传递const或非const对象给接收非引用类型的函数，都是用相同的实例化

2、数组或函数到指针的转换：如果模板形参不是引用类型，则对数组或函数类型的实参应用常规指针转换。数组实参将当做指向其第一个元素的指针，函数实参当做指向函数类型的指针

## 16.3 模板编译模型

## 16.4 类模板成员

## 16.5 一个泛型句柄类

### 16.5.1 定义句柄类

Handle类的行为类似于指针:复制Handle对象将不会复制基础对象，复制之后，两个Handle对象将引用同一基础对象。要创建Handle对象，用户需要传递属于由Handle管理的类型(或从该类型派生的类型)的动态分配对象的地址，从此刻起，Handle将"拥有"这个对象。而且，一旦不再有任意Handle对象与该对象关联，Handle类将负责删除该对象

```C++
template<class T> class Handle {
public:
	// 未绑定句柄
	Handle(T *p = 0) : ptr(p), use(new size_t(1)) {}
	// 操作符重载以支持指针行为
	T& operator*();
	T* operator->();
	const T& operator*() const;
	const T* operator->() const;
	// 复制控制，常规指针操作，但是最后一个Handle删除对象
	Handle(const Handle& h) : ptr(h.ptr), use(h.use) {++*use;}
	Handle& operator=(const Handle&);
	~Handle() {rem_ref();}

private:
	T* ptr; // 共享对象
	size_t *use;  // 指向ptr的Handle数目
	void rem_ref() {
		if (--*use == 0) {
			delete ptr;
			delete use;
		}
	}
}
```

```C++
template<class T> inline Handle<T>& Handle<T>::operator=(const Handle &rhs) {
	++*rhs.use;	// 防止自身赋值
	rem_ref();	// 需要时减少使用计数并删除指针
	ptr = rhs.ptr;
	use = rhs.use;
	return *this;
}

template<class T> inline T& Handle<T>::operator*() {
	if (ptr)
		return *ptr;
	throw std::runtime_error("dereference of unbound Handle");
}

template<class T> inline T* Handle<T>::operator->() {
	if (ptr)
		return ptr;
	throw std::runtime_error("access through unbound Handle");
}
```

### 16.5.2 使用句柄类

```C++
{
	Handle<int> hp(new int(42));
	{
		Handle<int> hp2 = hp;	// 复制指针，use计数增加
		cout << *hp << " " << *hp2 << endl;	// 打印 42 42
		*hp2 = 10;
	}
	cout << *hp << endl;	// 打印 10
}
```

## 16.6 模板特化

## 16.7 重载与函数模板

# 17. 用于大型程序的工具

## 17.1 异常处理

### 17.1.9 auto_ptr类

auto_ptr类只能用于管理从new返回的一个对象，不能管理动态分配的数组，不能将auto_ptr存储在标准库容器中。

```C++
#include <memory>

auto_ptr<T> ap; // 创建名为ap的未绑定的auto_ptr对象
auto_ptr<T> ap(p);  // ap拥有指针p指向的对象，该构造函数为explicit
auto_ptr<T> ap; // ap1保存原来存储在ap2中的指针，将所有权转给ap1，ap2成为未绑定的auto_ptr对象

ap1 = ap2;  // 将所有权从ap2转给ap1，删除ap1指向的对象并使ap1指向ap2指向的对象，使ap2成为未绑定的
~ap;  // 析构函数，删除ap指向的对象
*ap;  // 返回对ap所绑定的对象的引用
ap->; // 返回ap保存的指针

ap.reset(p);  // 如果p与ap的值不同，则删除ap指向的对象并将ap绑定到p
ap.release(); // 返回ap所保存的指针并且使ap成为未绑定的
ap.get(); // 返回ap保存的指针
```

普通指针复制/赋值后，两个指针指向同一个对象

auto_ptr复制/赋值后，右操作数让出对基础对象的所有职责并重置为未绑定的auto_ptr对象，左操作数指向基础对象，赋值还删除左操作数原来指向的对象

因为复制/赋值是破坏性操作，所以不能将auto_ptr对象存储在标准容器中。标准容器类要求在复制/赋值之后两个对象相等

# 18. 特殊工具与技术

## 18.1 优化内存分配

### 18.1.2 allocator类

allocator类是一个模板，它提供类型化的内存分配以及对象构造与撤销

标准allocator类与定制算法↓:

```C++
allocator<T> a; // 定义名为a的allocator对象，可以分配内存或构造T类型的对象

a.allocate(n);  // 分配原始的未构造内存以保存T类型的n个对象

a.deallocate(p, n);
// 释放内存，在名为p的T*指针中包含的地址处保存T类型的n个对象
// 运行调用deallocate之前在该内存中构造的任意对象的destroy是用户的责任

a.construct(p, t);
// 在T*指针p所指内存中构造一个新元素
// 运行T类型的复制构造函数用t初始化该对象

a.destroy();  // 运行T*指针p所指对象的析构函数

uninitialized_copy(b, e, b2);
// 从迭代器b和e指出的输入范围将元素复制到从迭代器b2开始的未构造的原始内存中
// 该函数在目的地构造元素，而不是给他们赋值
// 假定由b2指出的目的地足以保存输入范围中元素的副本

uninitialized_fill(b, e, t);
// 将由迭代器b和e指出的范围中的对象初始化为t的副本
// 假定该范围是未构造的原始内存。使用复制构造函数构造对象

uninitialized_fill_n(b, e, t, n);
// 将由迭代器b和e指出的范围中至多n个队形初始化为t的副本
// 假定范围至少为n个元素大小。使用复制构造函数构造对象
```

```C++
allocator<T> alloc;

T* newelements = alloc.allocate(newcapacity);
// 等价于
T* newelements = static_cast<T*> (operator new[](newcapacity * sizeof(T)));

alloc.construct(first_free, t);
// 等价于
new (first_free) T(t);

alloc.deallocate(elements, end - elements);
// 等价于
operator delete[](elements);
// 等价于
```

### 18.1.7 一个内存分配器基类

自由列表:改进内置库的new和delete函数，预先分配一块原始内存来保存未构造的对象，创建新元素的时候，可以在一个预先分配的对象中构造；释放元素的时候，将他们放回预先分配对象的块中，而不是将内存实际返还给系统。

CachedObj类有简单的接口，只是分配和管理已分配但还未构造对象的自由列表。只能用于不包含在继承层次中的类型。与成员new和delete操作不同，CachedObj类没有办法根据对象的实际类型分配不同大小的对象:它的自由列表保存单一大小的对象。因此它只能用于不作基类使用的类

声明:
```C++
template<class T> class CachedObj {
public:
	void *operator new(std::size_t);
	void operator delete(void *, std::size_t);
	virtual ~CachedObj(){}
protected:
	T *next;
private:
	static void add_to_freelist(T*);	// 将对象放在自由列表
	static std::allocator<T> alloc_mem;
	static T *freeStore;	// 指向自由列表的表头
	static const std::size_t chunk;	// 指定每当自由列表为空时将分配的对象的数目
}
```

实现:
```C++
template<class T> void *CachedObj<T>::operator new(size_t sz) {
	// 从自由列表返回一个对象，如果自由列表为空，new必须首先分配chunk数目的新内存
	if (sz != sizeof(T))
		throw std::runtime_error ("CachedObj: wrong size object in operator new");
	if (!freeStore) {
		T *array = alloc_mem.allocate(chunk);
		for (size_t i = 0; i != chunk; ++i)
			add_to_freelist(&array[i]);
	}
	T *p = freeStore;
	freeStore = freeStore->CachedObj<T>::next;
	return p;	// 被返回的对象是未构造的
}

template<class T> void CachedObj<T>::operator delete(void *p, size_t) {
	// operator delete成员只负责管理内存，在析构函数中已经清除了对象本身
	// delete表达式在调用operator delete之前调用析构函数
	if (p != 0)
		add_to_freelist(static_cast<T*>(p));
}

template <class T> void CachedObj<T>::add_to_freelist(T *p) {
	// 设置next指针，并且在将对象加到自由列表时更新freeStore指针
	p->CachedObh<T>::next = freeStore;
	freeStore = p;
}

// 静态数据成员
template <class T> allocate<T> CachedObj<T>::alloc_mem;
template <class T> T *CachedObj<T>::freeStore = 0;
template <class T> const size_t CachedObj<T>::chunk = 24;
```

使用:
```C++
class Screen : public CachedObj<Screen> {
	// 接口与实现不需要改变
}

template <class Type> class QueueItem : public CachedObj<QueueItem<Type>> {
	// 接口与实现不需要改变
}
```
