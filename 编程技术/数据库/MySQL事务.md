# 1. 概述

* 事务定义：是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；事务是一组不可再分割的操作集合

# 2. 事务特性(ACID

1. 原子性：事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做
2. 一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态
3. 隔离性：一个事务的执行不能被其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰
4. 持久性：也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响

# 3. 事务分类

* 事务分为隐式事务和显式事务
	* 隐式事务：没有明显的开始和结束标记，都具有自动提交事务的功能。如`insert`、`update`、`delete`语句
	* 显式事务：具有明显的开启和结束标记

* 除非显示的开启一个事务，否则每个查询都被当成一个单独的事务自动执行。使用显式事务的前提是禁用自动提交事物的功能

# 4. 开启事务的步骤

1. 开始事务(可选)：`start transaction;`
2. 编写事务中的SQL语句：`...`
3. 提交事务：`commit;`
4. 回滚事务：`rollback;`
5. 设置回滚点：`savepoint point_name`
	* 回滚到回滚点处：`rollback to point_name`

# 5. 事务并发时出现的问题

* 问题出现原因：对于同时运行的多个事务，当这些事务访问数据库中相同的数据时，如果没有采用必要的隔离机制，就会发生并发问题

* 并发问题：对于两个事务，在事务1执行过程中(即事务1已经开始执行并且还未执行结束)
	* 脏读：事务2对数据进行了增删改查，但是未提交事务，事务1读取未提交的数据。若事务2回滚，则事务1就读到了脏数据
	* 不可重复读：事务1发生了两次读操作，两个读操作之间失误2对数据修改了操作，此时事务1两次读到的数据不一致
		* 不可重复读关注点在数据更新和删除，通过行级锁可以实现可重复读的隔离级别
	* 幻读：事务1在读取某个范围内的记录时，事务2在该范围内插入了新的记录，当事务1再次读取该范围的记录时，会产生幻行
		* 相对不可重复读，幻读更关注其他事务的新增数据。通过行级锁可以避免不可重复读，但无法解决幻读的问题，想要解决幻读，只能通过Serializable隔离级别来实现

# 6. 事务的隔离性

* 原因：为了避免出现并发问题，MySQL通过提供事务的隔离级别，用来隔离并发运行的各个事务，使它们相互不受影响

* 定义：一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性就越差

* 事务的隔离级别
	1. `read uncommitted`：读未提交数据
		* 允许事务读取未被其他事务提交的变更
		* 问题：会导致脏读、不可重复读、幻读
	2. `read committed`：读已提交数据
		* 只允许事务读取已经被其他事务提交的变更
		* 问题：避免脏读，允许不可重复读和幻读
	3. `repeatable read`：可重复读
		* 确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事务对这个字段进行更新(update)
		* 问题：避免脏读和不可重复读，允许幻读
	4. `serializable`：串行化
		* 按照串行顺序执行事务，在事务持续期间，禁止其他事务对该表执行插入、更新和删除操作
		* 问题：避免脏读 、不可重复读、幻读，但是执行效率慢

* 默认隔离级别：
	* `oracle`：`read committed`
	* `mysql`：`repeatable read`

* 操作：
	* `set session transaction isolation level read uncommitted;`：设置当前mysql连接的隔离级别，如果只设置当前的隔离级别，也就是session，那么另外一个并发的“mysqy程序”的隔离级别不会受到当前连接的影响，而是保持默认的repeatable read
	* `set global transaction isolation level read uncommitted;`：设置数据库系统的全局的隔离级别，如果是设置全局的事务隔离级别，则整个mysql数据库（包括所有打开的mysql程序连接）的隔离级别都会随之改变，除非服务器重启，不然就不会恢复默认了