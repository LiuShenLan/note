[数据库中间件详解](https://zhuanlan.zhihu.com/p/87144535)

# 1. 数据库拆分

* 数据库拆分过程基本遵循的顺序：垂直拆分、读写分离、分库分表(水平拆分)

## 1.1 垂直拆分

* 定义：将一个包含了很多表的数据库，根据表的功能的不同，拆分为多个小的数据库，每个库包含部分表
	* 还有一种较少遇到的情况：将一个包含了很多字段的大表拆分为多个小表，每个表包含部分字段

* 缺点：使得单个用户请求的响应时间变长，原因在于，在单体应用的场景下，所有的业务都可以在一个节点内部完成，而垂直拆分之后，通常会需要进行RPC调用(远程过程调用)

* 优点：虽然单个请求的响应时间增加了，但是整个服务的吞吐量却会大大的增加

## 1.2 读写分离

* 定义：为应对用户数量和并发量的上升，将数据库设置成读写分离状态，即一个Master节点(主库)对应多个Slave节点(从库)。可以将Slave节点的数据理解为master节点数据的全量备份

* 实现过程：
	1. master节点接收用户的写请求，并写入到本地二进制文件(binary log)中
	2. Slave通过一个I/O线程与Master建立连接，发送binlog dump指令
	3. Master将binlog数据推送给Slave，Slave将接收到的binlog保存到本地的中继日志(relay log)中
	4. Slave通过另一个线程SQL thread应用本地的relay log，将数据同步到Slave库中

* 程序开发过程：
	1. 当更新数据时，应用将数据写入master主库，主库将数据同步给多个slave从库
	2. 当查询数据时，应用选择某个slave节点读取数据

* 优点：实现了数据库读能力的水平扩展。通过配置多个slave节点，可以有效的避免过大的访问量对单个库造成的压力

* 缺点：
	* 对数据库管理员：多了集群运维工作。如：集群搭建、主从切换、从库扩容、缩容、Slave节点增减等
	* 对开发人员：
		1. 读写分离功能：对SQL类型进行判断，如果是select等读请求，就走从库，如果是insert、update、delete等写请求，就走主库
		2. 主从数据同步延迟问题：因为数据是从master节点通过网络同步给多个slave节点，因此必然存在延迟。因此有可能出现我们在master节点中已经插入了数据，但是从slave节点却读取不到的问题。对于一些强一致性的业务场景，要求插入后必须能读取到，因此对于这种情况，我们需要提供一种方式，让读请求也可以走主库，而主库上的数据必然是最新的
		3. 事务问题：如果一个事务中同时包含了读请求(如select)和写请求(如insert)，如果读请求走从库，写请求走主库，由于跨了多个库，那么本地事务已经无法控制，属于分布式事务的范畴。而分布式事务非常复杂且效率较低。因此对于读写分离，目前主流的做法是，事务中的所有SQL统一都走主库，由于只涉及到一个库，本地事务就可以搞定
		4. 感知集群信息变更：如果访问的数据库集群信息变更了，例如主从切换了，写流量就要到新的主库上；又例如增加了从库数量，流量需要可以打到新的从库上；又或者某个从库延迟或者失败率比较高，应该将这个从库进行隔离，读流量尽量打到正常的从库上

## 1.3 分库分表(水平拆分)

* 原因：业务表中的数据量过大时，任何的CURD操作(`CREATE`、`UPDATE`、`READ`、`DELETE`)都极其耗费资源。即使设置了索引，也无法掩盖因为数据量过大而导致的数据库性能下降。而经过水平拆分后的业务表，能够将原本的一张表维护的海量数据分配给N个子表进行存储和维护

## 1.3.1 分类

* 只分表：将数据库`db`中的表`table`拆分为两个表`table_0`和`table_1`，这两个表还位于同一个库中
	* 适用场景：如果库中的多个表中只有某张表或者少数表数据量过大，那么只需要针对这些表进行拆分，其他表保持不变

* 只分库：将数据库`db`拆分为两个库`db_0`和`db_1`，同时在两个数据库中各自新建一个表`table`，两个数据库中的表`db_0.table`和`db_1.table`各自只存原来表`db.table`中的部分数据

* 分库分表：将`db`库拆分为`db_0`和`db_1`两个库，`db_0`中包含`table_0`、`table_1`两个分表，`db_1`中包含`table_2`、`table_3`两个分表

### 1.3.2 优点

* 读写分离实现了数据库读能力的水平扩展，分库分表实现了数据库写能力的水平扩展

1. 存储能力的水平扩展：
	* 在读写分离的情况下，每个集群中的master和slave基本上数据是完全一致的，从存储能力来说，在存在海量数据的情况下，可能由于磁盘空间的限制，无法存储所有的数据
	* 在分库分表的情况下，可以搭建多个mySQL主从复制集群，每个集群只存储部分分片的数据，实现存储能力的水平扩展

2. 写能力的水平扩展：
	* 在读写分离的情况下，由于每个集群只有一个master，所有的写操作压力都集中在这一个节点上，在写入并发非常高的情况下，这里会成为整个系统的瓶颈
	* 在分库分表的情况下，每个分片所属的集群都有一个master节点，都可以执行写入操作，实现写能力的水平扩展。此外减小建立索引开销，降低写操作的锁操作耗时等，都会带来很多显然的好处

### 1.3.3 缺点

1. 基本数据库的增删改功能：
	* 分库分表之后，单库单表的SQL语句需要处理成多条语句，分别到每个库上执行，步骤如下所示↓：
	1. SQL解析：SQL进行解析，得到需要插入的记录的id字段的值
	2. SQL路由：SQL路由包括库路由和表路由。库路由用于确定这条记录应该插入哪个库，表路由用于确定这条记录应该插入哪个表
	3. SQL改写：因为一条记录只能插入到一个库中，因此需要对SQL进行改写，每个库只插入对应的记录
	4. SQL执行：一条SQL经过改写后变成了多条SQL，为了提升效率应该并发的到不同的库上去执行，而不是按照顺序逐一执行
	5. 结果集合并：每个SQL执行之后，都会有一个执行结果，需要对分库分表的结果集进行合并，从而得到一个完整的结果

2. 分布式id
	* 在分库分表后，我们不能再使用mySQL的自增主键。因为在插入记录的时候，不同的库生成的记录的自增id可能会出现冲突。因此需要有一个全局的id生成器

3. 分布式事务
	* 原因：因为涉及到了同时更新多个分片数据，因此需要保证要么同时成功，要么同时失败
	* XA事务：MySQL支持XA事务，但是效率较低
	* 柔性事务：柔性事务是目前比较主流的方案，包括：最大努力通知型、可靠消息最终一致性方案以及TCC两阶段提交
	* 无论XA事务还是柔性事务，实现起来都非常复杂

4. 动态扩容
	* 定义：增加分库分表的数量，一般要伴随着数据迁移，但也有不需要进行数据迁移的方案

# 2. 数据库中间件设计方案

* 背景：读写分离和分库分表带来了巨大的好处，但是也面临了极大的挑战。因此数据库中间件对开发人员屏蔽底层的实现细节，无论读写分离还是分库分表，都可以像操作单库单表一样操作

* 分类：典型的数据库中间件设计方案分为：`proxy`和`smart-client`

## 2.1 `proxy`方案

* 实现：独立部署一个代理服务，这个代理服务背后管理多个数据库实例。在应用中，通过一个普通的数据源鱼代理服务器建立连接，所有的sql操作语句都发送给这个代理服务，由这个代理服务去操作底层数据库，得到结果并返回给应用

* 优点：
	1. 多语言支持：如果代理服务实现了某个数据库(如MySQL)的通信协议，那么就可以将其看成一个MySQL服务器
	2. 对业务开发透明：由于可以把proxy当成mysql服务器，所以业务开发不需要进行太多代码改造，既可以完成接入

* 缺点：
	1. 实现复杂：因为proxy需要实现被代理的数据库server端的通信协议，实现难度较大。通常proxy模式的数据库中间件，实际上只能代理某一种数据库
	2. proxy本身需要保证高可用：由于应用由直接访问数据库改成了访问proxy，因此proxy必须保证高可用
	3. 租户隔离：可能有多个应用访问proxy代理的底层数据库，必然会对proxy自身的内存、网络、cpu等产生资源竞争，proxy需要需要具备隔离的能力

## 2.2 `smart-client`方案

* 实现：修改业务代码，引入支持读写分离或者分库分表的功能呢的sdk
	* 通常smart-client是在连接池或者driver的基础上进行了一层封装，smart-client内部与不同的库建立连接。应用程序产生的sql交给smart-client进行处理，其内部对sql进行必要的操作

* 优点：
	1. 实现简单：proxy需要实现数据库的服务端协议，但是smart-client不需要实现客户端通信协议。原因在于，大多数据数据库厂商已经针对不同的语言提供了相应的数据库驱动drive，客户端的通信协议已经在driver层面做过了。因此smart-client模式的中间件，通常只需要在此基础上进行封装即可
	2. 天然去中心化：smart-client的方式，由于本身以sdk的方式，被应用直接引入，随着应用部署到不同的节点上，且直连数据库，中间不需要有代理层。因此相较于proxy而言，除了网络资源之外，基本上不存在任何其他资源的竞争，也不需要考虑高可用的问题。只要应用的节点没有全部宕机，就可以访问数据库。(这里的高可用是相比proxy而言，数据库本身的高可用还是需要保证的)

* 缺点：
	1. 通常仅支持某一种语言
	2. 版本升级困难：因为应用使用数据源代理就是引入一个jar包的依赖，在有多个应用都对某个版本的jar包产生依赖时，一旦这个版本有bug，所有的应用都需要升级。而数据库代理升级则相对容易，因为服务是单独部署的，只要升级这个代理服务器，所有连接到这个代理的应用自然也就相当于都升级了

# 3. 读写分离核心要点

## 3.1 基本路由功能

* 作用：在读写分离的情况下，实现基本的路由功能

* 过程：【SQL】->【判断是否开启事务】->【判断SQL中是否有hint或者在API中执行】->【判断是否是写操作】

* SQL类型判断：区分读SQL与写SQL
	* 写SQL在主库上执行，包括：`insert`、`update`、`delete`、`create`、`alter`、`truncate`...
	* 读SQL在从库上执行，包括：`select`、`show`、`desc`、`explain`...

* 强制走主库：
	* 原因：有的时候，对于一些强一致性的场景，需要写入后，必须能读取到数据。由于主从同步存在延迟，可能会出现主库写入，而从库查不到的情况。这次时候，我们需要使用强制走主库的功能
	* 实现方案：分为hint和API
	* hint：开发人员在sql上做一些特殊的标记，数据库中间件识别到这个标记，就知道这个sql需要走主库
	* API：通过代码的方式来添加sql走主库的标识，hint通常只能加在某个sql上。如果我们希望多个sql同时都走主库，也不希望加hint，则可以通过api的方式，其内部主要利用语言的thread local线程上下文特性

## 3.2 从路由策略

* 背景：通常在一个集群中，只会有一个master，但是有多个slave。当判断是一个读请求时，需要判断选择哪个slave

* 简单的选择策略：随机选择、按照权重进行选择、轮训、就近路由

## 3.3 HA(高可用性)、Scalable(可扩展性)

* 实现：无论是HA，还是Scalable，对于数据库中间件（不论是proxy或者smart-client）来说，只是配置信息发生了变更，因此通常会将所有的配置变更信息写到一个配置中心，然后配置心中监听这个配置的变更

* 过程：监控服务对集群进行监控，当发生变更时，将变更的信息 push 到配置中心中，数据库中间件（proxy 或 smart-client）接收到配置变更，应用最新的配置。而整个过程，对于业务代码基本是无感知的

* 注意：通常监控服务监控到集群信息变更，推送到配置中心，再到数据库中间件，必然存在一些延迟。对于一些场景，例如主从切换，没有办法做到彻底的业务无感知。当然，对于多个从库中，某个从库宕机的情况下，是可以做到业务无感知的

# 4. 分库分表核心要点

* 在分库分表情况下，数据库中间件内部执行一个批量插入SQL的过程如下所示↓：

1. SQL解析：首先对SQL进行解析，得到抽象语法树，从语法树中得到一些关键SQL信息
2. SQL路由：SQL路由包括库路由和表路由。库路由用于确定这条记录应该操作哪个分库，表路由用于确定这条记录应该操作哪个分表
3. SQL改写：将SQL改写成正确的执行方式。例如，对于一个批量插入SQL，同时插入4条记录。但实际上用户希望4个记录分别存储到一个分表中，那么就要对SQL进行改写成4条SQL，每个SQL都只能插入1条记录
4. SQL执行：一条SQL经过改写后可能变成了多条SQL，为了提升效率应该并发的去执行，而不是按照顺序逐一执行
5. 结果集合并：每个SQL执行之后，都会有一个执行结果，我们需要对分库分表的结果集进行合并，从而得到一个完整的结果

## 4.1 SQL解析

* 作用：得到一个抽象语法树(AST)，通过这个语法树可以简单的获取到SQL的一些执行

* 步骤：一般需要经过词法解析和语法解析两个阶段，最终得到一个语法树

## 4.2 SQL路由

* 背景：路由规则是分库分表的基础，其规定了数据应该按照怎样的规则路由到不同的分库分表中。数据库中间件通常支持用户自定义路由规则

* 路由规则本质：路由规则本质上是一个脚本表达式，数据库中间件通过内置的脚本引擎对表达式进行计算，确定最终要操作的分库、分包

* 路由字段：用来计算分库、分表的字段。无论是执行`INSERT`、`UPDATE`、`DELETE`、`SELECT`等语句，SQL中都应该包含路由字段，否则`SELECT`无法确定要插入哪个分库或分表；`UPDATE`、`DELETE`、`SELECT`等则因为不知道操作哪个分库分表，需要对所有分表进行操作

## 4.3 SQL改写

* 通常对于`INSERT`、`UPDATE`、`DELETE`等，改写相对简单。比较复杂的是`SELECT`语句的改写，对于一些复杂的`SELECT`语句，改写过程中会进行一些优化，例如将子查询改成`JOIN`，过滤条件下推等

* 因为SQL改写很复杂，所以很多数据库中间件并不支持复杂的SQL（通常有一个支持的SQL），只能支持一些简单的OLTP场景
	* OLTP：Online Transaction Processing System，在线事务处理系统
	* OLAP：Online Analytical Processing System，在线分析处理系统

## 4.4 SQL执行

* 经过改写后的SQL，会产生多个SQL，需要到不同的分片上去执行
	* 通常会使用一个线程池，将每个SQL包装成一个任务，提交到线程池里面并发的去执行，以提升效率
	* 改写产生的多个SQL需要保证同时成功，如果有一个失败，则整体失败

## 4.5 结果集合并

* 结果集合并是数据库中间件的一大难点，需要具体情况具体分析
	* 查询条件：大部分中间件都支持`=`、`IN`作为查询条件，且可以作为分区字段。但是对于`NOT IN`、`BETWEEN…AND`、`LIKE`、`NOT LIKE`等，只能作为普通的查询条件，因为根据这些条件，无法记录到底是在哪个分库或者分表，只能全表扫描
	* 聚合函数：大部分中间件都支持`MAX`、`MIN`、`COUNT`、`SUM`，但是对于`AVG`可能只是部分支持。另外，如果是函数嵌套、分组（`GROUP BY`）聚合，可能也有一些数据库中间件不支持
	* 子查询：分为`FROM`部分的子查询和`WHERE`部分的子查询。大部分中对于子查询的支持都是非常有限，例如语法上兼容，但是无法识别子查询中的分区字段，或者要求子查询的表名必须与外部查询表名相同，又或者只能支持一级嵌套子查询
	* `JOIN`：对于`JOIN`的支持通常很复杂，如果做不到过滤条件下推和流式读取，在中间件层面，基本无法对`JOIN`进行支持，因为不可能把两个表的所有分表，全部拿到内存中来进行`JOIN`，内存早就崩了。当然也有一些取巧的办法，一个是Binding Table，另外一个是小表广播
	* 分页排序：通常中间件都是支持`ORDER BY`和`LIMIT`的。但是在分库分表的情况下，分页的效率较低。在分页的情况下，通常建议使用`where id > ? limit 10`的方式来进行查询，应用记住每次查询的最大的记录id。之后查询时，每个分表只需要从这个id之后，取记录即可，而不是取offset+rows条记录

* Binding Table：适用于两个表之间存在关联关系，路由规则相同。例如，有user表和user_account表，由于user_account与user表强关联，我们可以将这两个表的路由规则设置为完全一样，那么对于某个特定用户的信息，其所在的user分表和user_account分表必然唯一同一个分库下，后缀名相同的分表中。在join时，某一个分库内的join，就可以拿到这个用户以及账号的完整信息，而不需要进行跨库join，这样就不需要把用户的数据库拿到内存中来进行join

* 小表广播：通常是某一个表的数据量比较少，另外一个表数据量比较大。此时大表进行分库分表，但是小表需要进行分库分表。为了达到JOIN的目的，可以将小表表在每个分库内都实时同步一份完整的数据。这样，在JOIN的时候，数据库中间件只需要将分库JOIN的结果进行简单合并即可

## 4.6 二级索引

* 背景：通常情况下，分库分表的时候分区字段只有一个，使用其他字段，则需要扫描所有分表，效率很低

* 实现：将按照非分区字段的第二个字段插入的数据，进行一份全量拷贝。通过同步组件，重新按照第二个插入到另一个分库分表集群中，这个集群就成为二级索引，或者叫辅维度同步。此后，对于根据分区字段的操作，就在原来的分库分表集群中进行操作；根据第二个字段的操作，就到二级索引集群中去进行操作

* 注意：更新操作，只能操作原集群，二级索引集群只能执行查询操作。原集群的增量数据变更信息，实时的通过同步组件，同步到二级索引集群中

## 4.7 分布式ID生成器

* 背景：在分科分表的情况下，数据库的自增主键无法使用，需要使用一个分布式的ID生成器

* 分布式ID生成器需要满足的条件：唯一、趋势递增(减少落库时的索引开销)、高性能、高可用

## 4.8 分布式事务

* 背景：在分库分表的情况下，由于操作多个分库，此时就涉及到分布式事务。通常情况下，数据库中间件，只会保证单个分库的事务，也就是说，业务方在创建一个事务的时候，必须要保证事务中的所有操作，必须最终都在一个分库中执行

* 在微服务的架构下，事务的问题更加复杂