[数据库中间件详解](https://zhuanlan.zhihu.com/p/87144535)

# 1. 数据库拆分

* 数据库拆分过程基本遵循的顺序：垂直拆分、读写分离、分库分表(水平拆分)

## 1.1 垂直拆分

* 定义：将一个包含了很多表的数据库，根据表的功能的不同，拆分为多个小的数据库，每个库包含部分表
	* 还有一种较少遇到的情况：将一个包含了很多字段的大表拆分为多个小表，每个表包含部分字段

* 缺点：使得单个用户请求的响应时间变长，原因在于，在单体应用的场景下，所有的业务都可以在一个节点内部完成，而垂直拆分之后，通常会需要进行RPC调用

* 优点：虽然单个请求的响应时间增加了，但是整个服务的吞吐量却会大大的增加

## 1.2 读写分离

* 定义：为应对用户数量和并发量的上升，将数据库设置成读写分离状态，即一个Master节点(主库)对应多个Slave节点(从库)。可以将Slave节点的数据理解为master节点数据的全量备份

* 实现过程：
	1. master节点接收用户的写请求，并写入到本地二进制文件(binary log)中
	2. Slave通过一个I/O线程与Master建立连接，发送binlog dump指令
	3. Master将binlog数据推送给Slave，Slave将接收到的binlog保存到本地的中继日志(relay log)中
	4. Slave通过另一个线程SQL thread应用本地的relay log，将数据同步到Slave库中

* 程序开发过程：
	1. 当更新数据时，应用将数据写入master主库，主库将数据同步给多个slave从库
	2. 当查询数据时，应用选择某个slave节点读取数据

* 优点：实现了数据库读能力的水平扩展。通过配置多个slave节点，可以有效的避免过大的访问量对单个库造成的压力

* 缺点：
	* 对数据库管理员：多了集群运维工作。如：集群搭建、主从切换、从库扩容、缩容、Slave节点增减等
	* 对开发人员：
		1. 读写分离功能：对sql类型进行判断，如果是select等读请求，就走从库，如果是insert、update、delete等写请求，就走主库
		2. 主从数据同步延迟问题：因为数据是从master节点通过网络同步给多个slave节点，因此必然存在延迟。因此有可能出现我们在master节点中已经插入了数据，但是从slave节点却读取不到的问题。对于一些强一致性的业务场景，要求插入后必须能读取到，因此对于这种情况，我们需要提供一种方式，让读请求也可以走主库，而主库上的数据必然是最新的
		3. 事务问题：如果一个事务中同时包含了读请求(如select)和写请求(如insert)，如果读请求走从库，写请求走主库，由于跨了多个库，那么本地事务已经无法控制，属于分布式事务的范畴。而分布式事务非常复杂且效率较低。因此对于读写分离，目前主流的做法是，事务中的所有sql统一都走主库，由于只涉及到一个库，本地事务就可以搞定
		4. 感知集群信息变更：如果访问的数据库集群信息变更了，例如主从切换了，写流量就要到新的主库上；又例如增加了从库数量，流量需要可以打到新的从库上；又或者某个从库延迟或者失败率比较高，应该将这个从库进行隔离，读流量尽量打到正常的从库上

## 1.3 分库分表(水平拆分)

* 原因：业务表中的数据量过大时，任何的CURD操作(`CREATE`、`UPDATE`、`READ`、`DELETE`)都及其耗费资源。即使设置了索引，也无法掩盖因为数据量过大而导致的数据库性能下降。而经过水平拆分后的业务表，能够将原本的一张表维护的海量数据分配给 N 个子表进行存储和维护

## 1.3.1 分类

* 只分表：将数据库`db`中的表`table`拆分为两个表`table_0`和`table_1`，这两个表还位于同一个库中
	* 适用场景：如果库中的多个表中只有某张表或者少数表数据量过大，那么只需要针对这些表进行拆分，其他表保持不变

* 只分库：将数据库`db`拆分为两个库`db_0`和`db_1`，同时在两个数据库中各自新建一个表`table`，两个数据库中的表`db_0.table`和`db_1.table`各自只存原来表`db.table`中的部分数据

* 分库分表：将`db`库拆分为`db_0`和`db_1`两个库，`db_0`中包含`table_0`、`table_1`两个分表，`db_1`中包含`table_2`、`table_3`两个分表

### 1.3.2 优点

* 读写分离实现了数据库读能力的水平扩展，分库分表实现了数据库写能力的水平扩展

1. 存储能力的水平扩展：
	* 在读写分离的情况下，每个集群中的master和slave基本上数据是完全一致的，从存储能力来说，在存在海量数据的情况下，可能由于磁盘空间的限制，无法存储所有的数据
	* 在分库分表的情况下，可以搭建多个mysql主从复制集群，每个集群只存储部分分片的数据，实现存储能力的水平扩展

2. 写能力的水平扩展：
	* 在读写分离的情况下，由于每个集群只有一个master，所有的写操作压力都集中在这一个节点上，在写入并发非常高的情况下，这里会成为整个系统的瓶颈
	* 在分库分表的情况下，每个分片所属的集群都有一个master节点，都可以执行写入操作，实现写能力的水平扩展。此外减小建立索引开销，降低写操作的锁操作耗时等，都会带来很多显然的好处

### 1.3.3 缺点

1. 基本数据库的增删改功能
	* 分库分表之后，单库单表的SQL语句需要进行处理成多条语句，分别到每个库上执行，步骤如下所示↓：
	1. SQL解析：sql进行解析，得到需要插入的记录的id字段的值
	2. SQL路由：sql路由包括库路由和表路由。库路由用于确定这条记录应该插入哪个库，表路由用于确定这条记录应该插入哪个表
	3. SQL改写：因为一条记录只能插入到一个库中，因此需要对sql进行改写，每个库只插入对应的记录
	4. SQL执行：一条sql经过改写后变成了多条sql，为了提升效率应该并发的到不同的库上去执行，而不是按照顺序逐一执行
	5. 结果集合并：每个sql执行之后，都会有一个执行结果，需要对分库分表的结果集进行合并，从而得到一个完整的结果

2. 分布式id
	* 在分库分表后，我们不能再使用mysql的自增主键。因为在插入记录的时候，不同的库生成的记录的自增id可能会出现冲突。因此需要有一个全局的id生成器

3. 分布式事务
	* 原因：因为涉及到了同时更新多个分片数据，因此需要保证要么同时成功，要么同时失败
	* XA事务：MySQL支持XA事务，但是效率较低
	* 柔性事务：柔性事务是目前比较主流的方案，包括：最大努力通知型、可靠消息最终一致性方案以及TCC两阶段提交
	* 无论XA事务还是柔性事务，实现起来都非常复杂

4. 动态扩容
	* 定义：增加分库分表的数量，一般要伴随着数据迁移，但也有不需要进行数据迁移的方案

# 2. 数据库中间件

* 背景：读写分离和分库分表带来了巨大的好处，但是也面临了极大的挑战。因此数据库中间件对开发人员屏蔽底层的实现细节，无论读写分离还是分库分表，都可以像操作单库单表一样操作
