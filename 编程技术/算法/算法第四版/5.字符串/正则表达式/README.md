### 使用正则表达式描述模式
模式的描述由三种基本操作和作为操作数的字符组成.
这里用语言指代一个字符串的集合(可能是无限的), 用模式指代一种语言的详细说明.
* 连接操作:
    * AB指定了语言{AB}, 它含有一个由两个字符组成的字符串, 由A和B连接
* 或操作:
    * 在模式中指定多种可能的匹配.
    * 如果在两个选择之间指定了一个或运算符, 那么它们都将属于同一种语言.
    * 用"|"表示或运算符. A|B指定的语言是{A, B}.
    * 连接的操作优先级高于或操作
* 闭包操作:
    * 可以将模式的部分重复任意的次数.
    * 模式的闭包是将模式和自身连接任意多次(包括零次)而得到的所有字符串组成的语言.
    * 将"*"标记在需要被重复的模式之后以表示闭包.
    * 闭包的操作优先级高于连接操作.
    * AB*指定的语言由一个A和零个或多个B的字符串组成;
    * A*B指定的语言由零个或多个A和一个B的字符串组成;
    * 空字符串的记号是€,它存在于所有文本字符串之中(包括A*)
* 括号:
    * 使用括号来改变默认的优先级顺序

#### 定义
一个正则表达式可以是:
* 空字符串€:
字符串的集合为空,含有0个元素
* 单个字符:
字符串的集合含有一个元素,即该字符本身
* 包含在括号中的另一个正则表达式:
字符串的集合与括号内的正则表达式相同
* 两个或多个连接起来的正则表达式:
字符串的集合为这两个正则表达式分别表示的集合的叉乘
(按照正则表达式中指定的顺序,
由一个字符串集合中的元素和另一个字符串集合中的元素相连接所能够组合而成的所有字符串)
* 由或运算符分隔的两个或多个正则表达式:
字符串的集合为两个正则表达式所分别表示的字符串集合的并集
* 由闭包运算符标记的一个正则表达式:
字符串的集合由€(空字符串)或将被修饰的正则表达式所表示的字符串集合重复任意次所得到的所有字符串所组成

### 缩略写法

#### 字符集描述符
|记法|名称|含义|
|:-:|:-:|:-:|
|.|通配符|表示任意字符|
|包含在[]中的字符|指定的集合|表示这些字符中的任意一个|
|包含在[],由"-"分割|范围集合|表示范围中的任意一个或多个字符|
|包含在[]中,首字母为"^"|补集|任意非该括号内的字符|

#### 闭包的简写(指定操作数的重复次数)
|记法|选项|举例|原始写法|
|:-:|:-:|:-:|:-:|
|+|至少重复一次|(AB)+|(AB)(AB)*|
|?|重复0或1次|(AB)?|€\|AB|
|由{}指定次数|重复指定次数|(AB){3}|(AB)(AB)(AB)|
|由{}指定范围|重复指定范围的次数|(AB){1-2}|(AB)\|(AB)(AB)|

#### 转义序列
构造正则表达式的元字符:"\\"、"\."、"|"、"*"、"("和")"。
我们使用以反斜杠开头的转义序列来将元字符和字母表中的字符区别开来.

一个转义序列可以是一个"\\"加上单个字符(这就表示这个字符本身).

其他转义序列表示了特殊字符和空白字符:
* "\\t"表示一个制表符,
* "\\n"表示一个换行符,
* "\\s"表示任意空白字符

### 非确定有限状态自动机
* 定义的NFA(非确定状态有限自动机)特点:
    * 长度为M的正则表达式中的每个字符在所对应的NFA中都有且只有一个对应的状态.
NFA的起始状态为0并含有一个(虚拟的)接受状态M
    * 字母表中的字符所对应的状态都有一条从它指出的边,
这条边指向模式中的下一个字符所对应的状态(黑色的边)
    * 元字符"(", ")", "|"和"*"所对应的状态至少含有一条指出的边(红色的边)
这些边可能指向其他的任意状态
    * 有些状态有多条指出的边,但一个状态只能有一条指出的黑色边
    * 约定将所有的模式都包含在括号中,
因此NFA的第一个状态对应的是左括号,
而最后一个状态对应的是右括号
(并能够转换为接受状态)

* 在NFA中状态的转换有一下两种方式
    * 如果当前状态和字母表中的一个字符相对应且文本中的当前字符和该字符匹配,
自动机可以扫过文本中的该字符并(由黑色的边)转换到下一个状态.
将这种转换称为匹配转换
    * 自动机可以通过红色的边切换到另一个状态二部扫描文本中的任何字符.
将这种转换称为€-转换,
也就是说它所对应的"匹配"是一个空字符串€

判断一个长度为M的正则表达式所对应的NFA能否识别一段长度为N的文本所需的时间在最坏情况下和MN成正比

### 构造与正则表达式对应的NFA

#### 连接操作
状态的匹配转换和字母表中的字符的对应关系就是连接操作的实现.

#### 括号
将正则表达式字符串中所有左括号的索引压人栈中.
当遇到一个右括号，用后文所述的方式将左括号从栈中弹出.
栈可以很自然地处理嵌套的括号

#### 闭包操作
闭包运算符(*)只可能出现在:

(i)单个字符之后(此时将在该字符和"*"之间添加相互指向的两条€-转换);

(ii)右括号之后(此时将在对应的左括号(即栈顶元素)和"*"之间添加相互指向的两条€-转换)

#### 或表达式
在形如(A|B)的正则表达式中,A和B也都是正则表达式.

处理方式是添加两条€-转换:

一条从左括号所对应的状态指向B中的第一个字符所对应的状态,

另一条从"|"字符所对应的状态指向右括号所对应的状态.

将正则表达式字符串中"|"运算符的索引(以及如上文所述的左括号的索引)压入栈中,
这样在到达右括号时这些所需信息都会在栈的顶部.
这些€-转换使得NFA能够在这两者之间进行选择.

此时并没有像平常一样添加一条从"|"运算符所对应的状态到下一个字符所对应的状态的€-转换——
NFA离开“或”运算符的唯一方式就是通过某种状态转换到达右括号所对应的状态
