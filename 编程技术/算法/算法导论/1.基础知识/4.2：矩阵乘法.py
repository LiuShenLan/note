"""
暴力算法
"""
def brute_force(a,b):
    c=[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]
    for i in range(len(a)):
        for j in range(len(a)):
            for k in range(len(a)):
                c[i][j]+=a[i][k]*b[k][j]
    return c

"""
简单递归算法
"""
# 将数组划分为四部分进行计算,与暴力算法的运行时间相同,为O(n^2)没有优化
# A=[[A11,A12],[A21,A22]]
# B=[[B11,B12],[B21,B22]]
# C=[[C11,C12],[C21,C22]]

# C11=A11*B11+A12*B12
# C12=A11*B12+A12*B22
# C21=A21*B11+A22*B21
# C22=A21*B12+A22*B22

"""
Strassen算法
"""
# 时间复杂度为O(n^lg7)
# A=[[A11,A12],[A21,A22]]
# B=[[B11,B12],[B21,B22]]
# C=[[C11,C12],[C21,C22]]

# S1=B12-B22
# S2=A11+A12
# S3=A21+A22
# S4=B21-B11
# S5=A11+A22
# S6=B1+B22
# S7=A12-A22
# S8=B21+B22
# S9=A11-A21
# S10=B11+B12

# P1=A11*S1   =A11*B12-A11*B22
# P2=S2*B22   =A11*B22+A12*B22
# P3=S3*B11   =A21*B11+A22*B11
# P4=A22*S4   =A22*B21-A22*B11
# P5=S5*S6    =A11*B11+A11*B22+A22*B11+A22*B22
# P6=S7*S8    =A12*B21+A12*B22-A22*B21-A22*B22
# P7=S9*S10   =A11*B11+A11*B12-A21*B11-A21*B12

# C11=P5+P4-P2+P6
# C12=P1+P2
# C21=P3+P4
# C22=P5+P1-P3-P7

if __name__ == '__main__':
    a=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]
    b=[[16,15,14,13],[12,11,10,9],[8,7,6,5],[4,3,2,1]]
    print("矩阵aXb,a =",a,"b =",b)

    # 暴力算法
    c=brute_force(a,b)
    print("暴力算法:",c)