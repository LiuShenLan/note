- [运行shell脚本方法](#运行shell脚本方法)
	- [作为可执行程序](#作为可执行程序)
	- [作为解释器参数](#作为解释器参数)
- [变量](#变量)
	- [定义](#定义)
	- [字符串](#字符串)
		- [单引号](#单引号)
		- [双引号](#双引号)
		- [操作](#操作)
	- [数组](#数组)
	- [注释](#注释)
- [传递参数](#传递参数)
- [数组](#数组-1)
- [运算符](#运算符)
	- [算数运算符](#算数运算符)
	- [关系运算符](#关系运算符)
	- [布尔运算符](#布尔运算符)
	- [逻辑运算符](#逻辑运算符)
	- [字符串运算符](#字符串运算符)
	- [文件测试运算符](#文件测试运算符)
- [echo命令](#echo命令)
- [printf命令](#printf命令)
- [test指令](#test指令)
	- [数值测试](#数值测试)
	- [字符串测试](#字符串测试)
	- [文件测试](#文件测试)
- [流程控制](#流程控制)
	- [分支](#分支)
		- [if](#if)
		- [if else](#if-else)
		- [if else-if else](#if-else-if-else)
		- [case](#case)
	- [循环](#循环)
		- [for循环](#for循环)
		- [while循环](#while循环)
		- [无限循环](#无限循环)
		- [until 循环](#until-循环)
		- [跳出循环](#跳出循环)
- [函数](#函数)
- [输入输出重定向](#输入输出重定向)
	- [重定向命令](#重定向命令)
	- [输出重定向](#输出重定向)
	- [输入重定向](#输入重定向)
	- [重定向解析](#重定向解析)
	- [Here Document](#here-document)
	- [不显示输出](#不显示输出)
- [文件包含](#文件包含)


# 运行shell脚本方法
## 作为可执行程序
cd 相应目录

chmod +x ./test.sh  #使脚本具有执行权限

./test.sh  #执行脚本

## 作为解释器参数
直接运行解释器，其参数就是 shell 脚本的文件名

/bin/sh test.sh

这种方式运行的脚本，不需要在第一行指定解释器信息

# 变量
## 定义
定义变量时，变量不加美元$符号，同时变量名和等号之间不能有空格

命名：只能使用英文字母，数字和下划线，首个字符不能以数字开头，中间不能有空格，可以使用下划线（_），不能使用标点符号，不能使用bash里的关键字（可用help命令查看保留关键字）

除了显式地直接赋值，还可以用语句给变量赋值，如：for file in `ls /etc`或for file in $(ls /etc)，以上语句将 /etc 下目录的文件名循环出来。

已定义的变量，可以被重新定义

* 使用
使用一个定义过的变量，只要在变量名前面加美元符号即可

变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界

readonly \<variable_name\>：将变量定义为只读变量，只读变量的值不能被改变

unset \<variable_name\>：删除变量

* 类型
局部变量：局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。

环境变量：所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。

shell变量：shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行

## 字符串
字符串可以用单引号，也可以用双引号，也可以不用引号

### 单引号
单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的

单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用

### 双引号
双引号里可以有变量

双引号里可以出现转义字符

### 操作
* 双引号拼接：

x="hello"

y="hi, "$x" !"

z="hi, ${x} !"

echo $y $z：输出为：hi, hello ! hi, hello !

* 单引号拼接：

x='hello'

y='hi, '$x' !'

z='hi, ${x} !'

echo $y $z：输出为：hi, hello ! hi, ${x} !

* 获取字符串长度：

echo ${#string_name}：输出string_name的长度
* 提取子字符串：

echo ${string_name:a:b} # 输出从第a+1个字符串开始的b个字符
* 查找子字符串：

echo `expr index "$string_name" ab` ：输出字符a或b的位置(哪个字母先出现就计算哪个)，第一个字符为1而不是0
## 数组

bash支持一维数组（不支持多维数组），并且没有限定数组的大小。数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0

* 定义数组：

在 Shell 中，用括号来表示数组，数组元素用"空格"符号分割开。定义数组的一般形式为：

array_name=(value1 value2 ... valuen)

还可以单独定义数组的各个分量：

array_name\[0]=value0
* 读取数组：

读取数组元素值的一般格式是：

${array_name\[下标]}

使用 @ 符号可以获取数组中的所有元素，例如：

echo ${array_name\[@]}

* 获取数组的长度：

获取数组长度的方法与获取字符串长度的方法相同，例如：

length=${#array_name\[@]}：取得数组元素的个数

length=${#array_name\[*]}：取得数组元素的个数

length=${#array_name\[n]}：取得数组单个元素的长度
## 注释

以 # 开头的行就是注释，会被解释器忽略

多行注释还可以使用以下格式：EOF也可以用其他符号，如 ! ' 代替

:\<\<EOF

注释内容...

注释内容...

EOF
# 传递参数

可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推

* $0：为执行的文件名
* $#：传递到脚本的参数个数
* $*：以一个单字符串显示所有向脚本传递的参数。如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数
* $$：脚本运行的当前进程ID号
* $!：后台运行的最后一个进程的ID号
* $@：与$*相同，但是使用时加引号，并在引号中返回每个参数。如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数
* $-：显示Shell使用的当前选项，与Linux中的set功能相同。
* $?：显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。
* $* 与 $@ 区别：
	* 相同点：都是引用所有参数。
	* 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " * " 等价于 "1 2 3"（传递了一个参数），而 "@" 等价于 "1" "2" "3"（传递了三个参数）
# 数组
数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小，数组元素的下标由0开始

Shell 数组用括号来表示，元素用"空格"符号分割开，语法格式如下：array_name=(value1 ... valuen)

也可以使用下标来定义数组：array_name\[n]=valuen

${array_name\[index]}：读取数组元素值

${array_name\[*]}、${array_name\[@]}：获取数组中的所有元素

${#array_name\[*]}、${#array_name\[@]}：获取数组长度，与获取字符串长度的方法相同
# 运算符

原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。

expr 是一款表达式计算工具，使用它能完成表达式的求值操作。

val=`expr 2 + 2`

echo "两数之和为 : $val"

输出为：两数之和为 : 4

表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2

完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号而是`
## 算数运算符

* `expr $a + $b`		a+b
* `expr $a - $b`		a-b
* `expr $a \* $b`		a*b	乘号(*)前边必须加反斜杠(\)才能实现乘法运算；
* `expr $a / $b`		a/b
* `expr $a % $b`	a%b
* a=$b			赋值
* \[ $a == $b ]		a=b则返回True，否则返回False
* \[ $a != $b ]		a!=b则返回True，否则返回False

## 关系运算符

关系运算符只支持数字，不支持字符串，除非字符串的值是数字

* \[ $a -eq $b ]		a=b则返回True
* \[ $a -ne $b ]		a!=b则返回True
* \[ $a -gt $b ]		a\>b则返回True
* \[ $a -lt $b ]		a\<b则返回True
* \[ $a -ge $b ]		a\>=b则返回True
* \[ $a -le $b ]		a\<=b则返回True

## 布尔运算符

* \[ \<表达式1\> -a \<表达式1\> ]		与运算，表达式全部为True则返回True
* \[ \<表达式1\> -o \<表达式1\> ]		或运算，表达式至少有一个为True则返回True
* \[ ! \<表达式\> ]					非运算，表达式为True则返回False
## 逻辑运算符

* \[ \<表达式1\> && \<表达式1\> ]		逻辑AND，表达式全部为True则返回True
* \[ \<表达式1\> || \<表达式1\> ]		逻辑OR，表达式至少有一个为True则返回True

## 字符串运算符

* \[ $a = $b ]		两个字符串相等则返回True
* \[ $a != $b ]		两个字符串不相等则返回True
* \[ -z $a ]			字符串长度为0则返回True
* \[ -n "$a" ]			字符串长度不为0则返回True
* \[ $a ]			字符串不为空则返回True

## 文件测试运算符

文件测试运算符用于检测 Unix 文件的各种属性
* \[ -b $file ]			文件是块设备文件则返回True
* \[ -c $file ]			文件是字符设备文件则返回True
* \[ -d $file ]			文件是目录则返回True
* \[ -f $file ]			文件是普通文件（既不是目录，也不是设备文件）则返回True
* \[ -g $file ]			文件设置了 SGID 位则返回True
* \[ -k $file ]			文件设置了粘着位(Sticky Bit)则返回True
* \[ -p $file ]			文件是有名管道则返回True
* \[ -u $file ]			文件设置了 SUID 位则返回True
* \[ -r $file ]			文件可读则返回True
* \[ -w $file ]			文件可写则返回True
* \[ -x $file ]			文件可执行则返回True
* \[ -s $file ]			文件不为空返回则返回True
* \[ -e $file ]			文件（包括目录）存在则返回True
* \[ -S $file ]			文件socket则返回True
* \[ -L $file ]			文件存在并且是一个符号链接则返回True
# echo命令

用于字符串的输出，命令格式：echo string

* 显示普通字符串
	* echo "string"
	* echo string
	* 双引号可以省略
* 显示转义字符
	* echo \\"
* 显示变量
	* read name
	* echo "$name It is a test"
	* read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量
* 显示换行
	* echo -e "OK! \\n"
	* -e 开启转义
* 显示不换行
	* echo -e "OK! \\c"
	* -e 开启转义 \\c 不换行
* 显示结果定向至文件
	* echo "It is a test" \> myfile
* 原样输出字符串，不进行转义或取变量(用单引号)
	* echo '$name\\"'
	* 输出：$name\\"
* 显示命令执行结果
	* echo `date`
	* 这里使用的是反引号 `, 而不是单引号 '。
	* 结果将显示当前日期
	* Thu Jul 24 10:08:46 CST 2014
# printf命令

printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \\n。
* printf  format-string  \[arguments...]
	* format-string: 为格式控制字符串，用双引号或单引号
	* arguments: 为参数列表。
%s %c %d %f都是格式替代符

%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。

%-4.2f 指格式化为小数，其中.2指保留2位小数。
* 转义序列
	* \\a		警告字符，通常为ASCII的BEL字符
	* \\b		后退
	* \\c		抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略
	* \\f		换页（formfeed）
	* \\n		换行
	* \\r		回车（Carriage return）
	* \\t		水平制表符
	* \\v		垂直制表符
	* \\\\		一个字面上的反斜杠字符
	* \\ddd		表示1到3位数八进制值的字符。仅在格式字符串中有效
	* \\0ddd	表示1到3位的八进制值字符
# test指令

test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试
## 数值测试
* test $\[num1] -eq $\[num2]	num1==num2则返回True
* test $\[num1] -ne $\[num2]	num1!=num2则返回True
* test $\[num1] -gt $\[num2]		num1\>num2则返回True
* test $\[num1] -ge $\[num2]	num1\>=num2则返回True
* test $\[num1] -lt $\[num2]		num1\<num2则返回True
* test $\[num1] -le $\[num2]		num1\<=num2则返回True
* 代码中的 \[] 执行基本的算数运算，如：result=$\[a+b] # 注意等号两边不能有空格
## 字符串测试
* test $str1 = $str2			str1==str2则返回True
* test $str1 != $str2			str1!=str2则返回True
* test -z $str1				str1长度为0则返回True
* test -n $str1				str1长度不为0则返回True
## 文件测试
* test -e \<文件名\>			文件存在则返回True
* test -r \<文件名\>			文件存在且可读则返回True
* test -w \<文件名\>			文件存在且可写则返回True
* test -x \<文件名\>			文件存在且可执行则返回True
* test -s \<文件名\>			文件存在且至少有一个字符则返回True
* test -d \<文件名\>			文件存在且为目录则返回True
* test -f \<文件名\>			文件存在且为普通文件则返回True
* test -c \<文件名\>			文件存在且为字符型特殊文件则返回True
* test -b \<文件名\>			文件文件存在且为块特殊文件则返回True

Shell还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为："!"最高，"-a"次之，"-o"最低
# 流程控制
## 分支
### if
```shell
if 条件
then
	命令
	...
fi
```
写成一行（适用于终端命令提示符）：
`if [ 条件 ]; then 命令; fi`
### if else
```shell
if 条件
then
	命令
	...
else
	命令
fi
```
### if else-if else
```shell
if 条件1
then
	命令
elif 条件2
then
	命令
else
	命令
fi
```
### case
case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令
```shell
case 值 in
模式1)
	command
	;;
模式2）
	command
	;;
*）
	command
	;;
esac
```

取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;

取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令

也可以将多个模式进行合并
```shell
模式1|模式2|模式3）
	command
	;;
```
## 循环
### for循环
```shell
for var in item1 item2 ... itemN
do
	command1
	command2
	...
	commandN
done
```
写成一行：
`for var in item1 item2 ... itemN; do command1; command2… done;`

当变量值在列表里，for循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的shell命令和语句。in列表可以包含替换、字符串和文件名

in列表是可选的，如果不用它，for循环使用命令行的位置参数
### while循环
```shell
while condition
do
	command
done
```

let "var++"：var自增一

使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量
### 无限循环
```shell
while :
do
	command
done
```
```shell
while true
do
	command
done
```
```shell
for (( ; ; ))
```
### until 循环
until 循环执行一系列命令直至条件为 true 时停止。

until 循环与 while 循环在处理方式上刚好相反。

一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用
```shell
until condition
do
	command
done
```

condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环
### 跳出循环

continue命令不会跳出所有循环，仅仅跳出当前循环

break命令允许跳出所有循环（终止执行后面的所有循环）
# 函数
```shell
[ function ] funname [()]
{
	action;
	[return int;]
}
```
可以带\[ function ] funname () 定义，也可以直接funname () 定义,不带任何参数

参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)

函数返回值在调用该函数后通过 $? 来获得

所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可
* 函数参数
	* 调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数...
	* 注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n\>=10时，需要使用${n}来获取参数
	* 特殊字符：
		* $#	传递到脚本的参数个数
		* $*	以一个单字符串显示所有向脚本传递的参数
		* $$	脚本运行的当前进程ID号
		* $!	后台运行的最后一个进程的ID号
		* $@	与$*相同，但是使用时加引号，并在引号中返回每个参数
		* $-	显示Shell使用的当前选项，与set命令功能相同
		* $?	显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误
# 输入输出重定向
## 重定向命令
* command \> file		将输出重定向到 file
* command \< file		将输入重定向到 file
* command \>\> file		将输出以追加的方式重定向到 file
* n \> file				将文件描述符为 n 的文件重定向到 file
* n \>\> file				将文件描述符为 n 的文件以追加的方式重定向到 file
* n \>& m				将输出文件 m 和 n 合并
* n \<& m				将输入文件 m 和 n 合并
* \<\< tag				将开始标记 tag 和结束标记 tag 之间的内容作为输入

需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）
## 输出重定向

重定向一般通过在命令间插入特定的符号来实现。特别的，这些符号的语法如下所示：
* command1 \> file1
	* 上面这个命令执行command1然后将输出的内容存入file1

注意任何file1内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，使用\>\>操作符
## 输入重定向

和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：
* command1 \< file1

这样，本来需要从键盘获取输入的命令会转移到文件读取内容

注意：输出重定向是大于号(\>)，输入重定向是小于号(\<)
* command1 \< infile \> outfile：同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中
## 重定向解析

一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：
* 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。
* 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。
* 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。

默认情况下，command \> file 将 stdout 重定向到 file，command \< file 将stdin 重定向到 file。

* $ command 2 \> file：stderr 重定向到 file
* $ command 2 \>\> file：stderr 追加到 file 文件末尾，2 表示标准错误文件(stderr)。
* $ command \> file 2\>&1或者\$ command \>\> file 2\>&1：将 stdout 和 stderr 合并后重定向到 file
* $ command \< file1 \>file2：将 stdin 重定向到 file1，将 stdout 重定向到 file2
## Here Document
Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序

它的基本的形式如下：
```shell
command \<\< delimiter
	document
delimiter
```

它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command

注意：

结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。

开始的delimiter前后的空格会被忽略掉。

delimiter可替换为任意字符串
## 不显示输出

如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：
* $ command \> /dev/null
	* /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到"禁止输出"的效果。
* $ command \> /dev/null 2\>&1：屏蔽 stdout 和 stderr
注意：0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。
# 文件包含

Shell 可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。

Shell 文件包含的语法格式如下：

`. filename`   # 注意点号(.)和文件名中间有一空格；或`source filename`

注：被包含的文件 test1.sh 不需要可执行权限。

eg：filename如果是在当前文件夹下的test1.sh，则为. ./test1.sh 或 source ./test1.sh
